# 메타 광고 플랫폼 종합 기획서

## 📋 프로젝트 개요

### 목표
- Meta Marketing API를 활용한 광고 데이터 분석 웹서비스
- 광고 자동 포스팅 및 관리 시스템
- 모듈화/컴포넌트 기반의 확장 가능한 플랫폼

### 핵심 가치 제안
- **실시간 성과 분석**: 광고 캠페인의 실시간 모니터링 및 인사이트 제공
- **자동화**: 광고 생성, 최적화, 관리의 자동화로 효율성 극대화
- **모듈성**: 기능을 쉽게 붙였다 뗄 수 있는 플러그인 아키텍처
- **지능형 최적화**: AI 기반 성과 예측 및 최적화 추천

### 아키텍처 철학
- **컴포넌트 기반**: 독립적이고 재사용 가능한 모듈 설계
- **확장성**: 수평적 확장이 가능한 마이크로서비스 지향
- **신뢰성**: 99.9% 가용성을 위한 장애 복구 시스템
- **성능**: 실시간 처리를 위한 최적화된 데이터 파이프라인

---

## 🔍 Meta API 분석 결과

### API 제약사항 및 대응 전략

#### Rate Limiting
- **app_id_util_pct**: 앱 레벨 사용률 (0-100%)
- **acc_id_util_pct**: 계정 레벨 사용률 (0-100%)
- **대응**: 적응형 Rate Limiting 시스템 구현

#### 데이터 접근 제한
- **13개월 룰**: reach/impression 데이터 13개월 이상 시 제한
- **쿼리 복잡도**: 복잡한 breakdown 조합 시 성능 저하
- **대응**: 쿼리 최적화 및 배치 처리 시스템

#### 에러 처리 전략
- **Error Code 100**: 잘못된 매개변수 → 검증 로직
- **Error Code 190**: 액세스 토큰 문제 → 토큰 갱신
- **Error Code 613**: 요청 한도 초과 → 대기 및 재시도
- **Error Code 80000**: 내부 오류 → 백오프 재시도

### Meta Insights API 활용

#### Breakdown 데이터 분석
- **인구통계**: age, gender, country, region
- **디바이스**: device_platform, platform_position, publisher_platform
- **시간**: hourly_stats_aggregated_by_advertiser_time_zone
- **행동**: action_type, action_target_id, action_destination

#### 최적화 전략
- **필드 선택**: 필요한 필드만 요청하여 응답 크기 최소화
- **날짜 범위**: 적절한 기간 설정으로 성능 향상
- **비동기 작업**: 대용량 데이터는 async job으로 처리
- **캐싱 계층**: 자주 사용되는 데이터 캐싱

### 추적 및 전환 사양 시스템

#### 핵심 개념
- **추적 사양(tracking_specs)**: 광고에서 사람들의 행동을 로깅
- **전환 사양(conversion_specs)**: v2.4부터 읽기 전용, optimization_goal 사용
- **메타 사양**: 단일 객체에 여러 행동 유형을 추적

### 마케팅 믹스 모델링(MMM) 분석 시스템

#### 핵심 특징
- **전용 API**: `breakdowns=mmm` 매개변수로 특화된 데이터 추출
- **독립성**: 다른 breakdown과 병행 사용 불가, 독립적 처리 필요
- **제한된 범위**: 광고 세트 수준(`level=adset`)에서만 제공
- **핵심 지표**: impressions, spend (추산치) 제공

#### MMM 데이터 활용 전략

**비즈니스 관리자 수준 통합**
```typescript
interface BusinessManagerMMMQuery {
  businessId: string;
  ownedAccounts: string[];
  clientAccounts: string[];
  aggregationStrategy: 'SUM' | 'WEIGHTED_AVERAGE' | 'SEPARATE';
}

class BusinessManagerMMMCollector {
  async collectAllAccountsMMM(businessId: string): Promise<MMMData[]> {
    // 1. owned_ad_accounts 수집
    const ownedAccounts = await this.getOwnedAccounts(businessId);

    // 2. client_ad_accounts 수집
    const clientAccounts = await this.getClientAccounts(businessId);

    // 3. 각 계정별 MMM 데이터 순차 수집
    const allMMMData = await Promise.all([
      ...ownedAccounts.map(acc => this.collectAccountMMM(acc.id)),
      ...clientAccounts.map(acc => this.collectAccountMMM(acc.id))
    ]);

    return this.aggregateResults(allMMMData);
  }
}
```

**MMM 전용 필터링 시스템**
```typescript
interface MMMFilterValidation {
  allowedFilters: {
    'campaign.id': ['IN', 'NOT_IN'];
    'campaign.name': ['CONTAIN', 'NOT_CONTAIN'];
    'adset.id': ['IN', 'NOT_IN'];
    'adset.name': ['CONTAIN', 'NOT_CONTAIN'];
    'country': ['IN'];
    'region': ['IN'];
    'dma': ['IN'];
    'device_platform': ['IN'];
    'publisher_platform': ['IN'];
    'platform_position': ['IN'];
  };
}

class MMMFilterValidator {
  validateFilter(field: string, operator: string): boolean {
    const allowedOps = this.allowedFilters[field];
    return allowedOps?.includes(operator) || false;
  }
}
```

#### 마케팅 효과 측정 확장

**채널 기여도 분석**
- MMM 데이터를 통한 정확한 마케팅 채널별 효과 측정
- 크로스 채널 상호작용 분석 및 시너지 효과 계산
- 증분 효과(Incremental Effect) 측정을 통한 순수 기여도 산출

**예산 최적화 모델링**
- MMM 데이터 기반 최적 예산 배분 모델 구축
- 한계 효용 분석을 통한 채널별 추가 투자 수익률 예측
- 시장 포화도 고려한 장기적 투자 전략 수립

### Lift Studies 기반 실험 검증 시스템

#### 핵심 특징
- **무작위 대조 실험**: 실험군과 대조군 임의 배정으로 인과관계 입증
- **실시간 실험**: 실제 캠페인과 동시 진행되는 라이브 실험
- **제한된 접근**: Meta 담당자를 통한 액세스 권한 획득 필요
- **통계적 엄밀성**: p-value, 신뢰구간 등 과학적 검증 방법 적용

### 분할 테스트(Split Test) 시스템

#### 핵심 특징
- **A/B 테스트 자동화**: 타겟 분할 자동화 및 그룹 간 중복 방지
- **다변수 테스트**: 타겟팅, 게재 최적화, 크리에이티브, 예산 등 다양한 변수 테스트
- **통계적 무결성**: 한 번에 하나의 변수만 테스트하여 과학적 검증 보장
- **실시간 성과 비교**: KPI 기반 효율성 지표 실시간 측정

#### 분할 테스트 제한사항
- **광고주당 최대 동시 연구**: 100개
- **연구당 최대 셀**: 150개
- **셀당 최대 광고 항목**: 100개
- **변수 분리 원칙**: 테스트의 과학적 무결성을 위한 단일 변수 테스트 권장

### 광고 볼륨 관리 시스템

#### 핵심 특징
- **실시간 볼륨 모니터링**: 게재 중이거나 검토 중인 광고 수 실시간 추적
- **페이지별 제한 관리**: 2021년 초 도입된 페이지당 광고 제한 정책 준수
- **지능형 상태 판별**: effective_status와 configured_status 기반 정확한 광고 상태 추적
- **미래 제한 예측**: future_limit_activation_date를 통한 선제적 제한 대응

#### 볼륨 제한 체계
- **개별 계정 제한**: current_account_ads_running_or_in_review_count
- **페이지 수준 제한**: ads_running_or_in_review_count per actor_id
- **비즈니스 관리자 제한**: ad_limit_scope_business_manager_id 기반
- **동적 제한 적용**: 스케줄 기반 시간별 볼륨 카운팅

#### 자동 권장사항 시스템
- **zero_impression**: 노출 없는 광고 식별 및 정리 권장
- **learning_limited**: 학습 제한 광고 최적화 권장
- **top_campaigns_with_ads_under_cap**: 볼륨 여유 있는 캠페인 활용 권장
- **top_adsets_with_ads_under_cap**: 효율적 광고 세트 확장 권장

### 광고 규칙 엔진 시스템

#### 핵심 특징
- **중앙 규칙 관리**: 광고를 쉽고 효율적으로 자동 관리하는 통합 서비스
- **이중 실행 모드**: Schedule Based (정기 실행) + Trigger Based (실시간 반응)
- **고급 필터링**: 메타데이터, 인사이트, 고급 조건을 조합한 정교한 타겟팅
- **자동 액션 실행**: 조건 충족 시 사전 정의된 액션 자동 수행

#### 규칙 엔진 구조
- **평가 사양(Evaluation Spec)**: 규칙 적용 대상 및 조건 정의
- **실행 사양(Execution Spec)**: 조건 충족 시 수행할 액션 정의
- **다층 필터링**: entity_type, 메타데이터, 인사이트 데이터 기반 정교한 조건
- **실시간 트리거**: 광고 상태 변경 즉시 규칙 평가 및 실행

#### 광고 규칙 엔진 활용 전략

**규칙 설계 시스템**
```typescript
interface AdRuleConfig {
  name: string;
  evaluation_spec: {
    evaluation_type: 'SCHEDULE' | 'TRIGGER';
    filters: RuleFilter[];
    trigger?: RuleTrigger;
  };
  execution_spec: {
    execution_type: 'PAUSE' | 'UNPAUSE' | 'BUDGET_UPDATE' | 'BID_UPDATE';
    execution_options: any;
  };
  status: 'ENABLED' | 'DISABLED';
}

interface RuleFilter {
  field: string;
  value: any;
  operator: 'GREATER_THAN' | 'LESS_THAN' | 'EQUAL' | 'IN_RANGE' | 'NOT_IN_RANGE' | 'IN' | 'NOT_IN';
}

class AdRuleEngine {
  async createPerformanceRule(config: PerformanceRuleConfig): Promise<string> {
    // 1. 성과 기반 규칙 생성 (CPA, ROAS, CTR 등)
    const evaluationSpec = this.buildPerformanceEvaluation(config);

    // 2. 자동 액션 정의 (일시정지, 예산 조정 등)
    const executionSpec = this.buildAutoActionExecution(config);

    // 3. 광고 규칙 생성 및 활성화
    return this.createRule({
      name: config.name,
      evaluation_spec: evaluationSpec,
      execution_spec: executionSpec,
      status: 'ENABLED'
    });
  }

  async createScheduleBasedRule(schedule: string, conditions: RuleFilter[], actions: ExecutionSpec): Promise<string> {
    // 정기적 실행 규칙 (일일, 주간, 월간)
    // 예: 매일 오전 9시 성과 검토 후 자동 최적화
  }

  async createTriggerBasedRule(trigger: RuleTrigger, conditions: RuleFilter[], actions: ExecutionSpec): Promise<string> {
    // 실시간 반응 규칙
    // 예: 광고 상태 변경, 성과 지표 임계값 초과 시 즉시 대응
  }
}
```

**실용적 규칙 예시**
```typescript
// 1. 성과 기반 자동 일시정지 규칙
const performancePauseRule = {
  name: "High CPA Auto Pause",
  evaluation_spec: {
    evaluation_type: "SCHEDULE",
    filters: [
      { field: "entity_type", value: "AD", operator: "EQUAL" },
      { field: "time_preset", value: "LAST_7_DAYS", operator: "EQUAL" },
      { field: "cpa", value: 50.00, operator: "GREATER_THAN" },
      { field: "spent", value: 100.00, operator: "GREATER_THAN" }
    ]
  },
  execution_spec: {
    execution_type: "PAUSE"
  }
};

// 2. 예산 소진율 기반 자동 조정 규칙
const budgetOptimizationRule = {
  name: "Budget Rebalancing",
  evaluation_spec: {
    evaluation_type: "TRIGGER",
    filters: [
      { field: "entity_type", value: "ADSET", operator: "EQUAL" },
      { field: "estimated_budget_spending_percentage", value: [120, 200], operator: "IN_RANGE" }
    ],
    trigger: {
      type: "metadata_change",
      field: "estimated_budget_spending_percentage"
    }
  },
  execution_spec: {
    execution_type: "BUDGET_UPDATE",
    execution_options: { increase_percentage: 20 }
  }
};

// 3. 실시간 성과 모니터링 규칙
const realTimeOptimizationRule = {
  name: "Real-time Performance Monitor",
  evaluation_spec: {
    evaluation_type: "TRIGGER",
    filters: [
      { field: "entity_type", value: "AD", operator: "EQUAL" },
      { field: "time_preset", value: "TODAY", operator: "EQUAL" },
      { field: "ctr", value: 0.5, operator: "LESS_THAN" },
      { field: "spent", value: 20.00, operator: "GREATER_THAN" }
    ],
    trigger: {
      type: "insights_change",
      field: "ctr"
    }
  },
  execution_spec: {
    execution_type: "PAUSE"
  }
};
```

#### 광고 볼륨 활용 전략

**볼륨 모니터링 시스템**
```typescript
interface AdsVolumeConfig {
  account_id: string;
  page_id?: string;
  show_breakdown_by_actor: boolean;
  recommendation_type?: 'zero_impression' | 'learning_limited' | 'top_campaigns_with_ads_under_cap' | 'top_adsets_with_ads_under_cap';
}

interface AdsVolumeResponse {
  ads_running_or_in_review_count: number;
  current_account_ads_running_or_in_review_count: number;
  actor_id: string;
  actor_name?: string;
  limit_on_ads_running_or_in_review: number;
  future_limit_activation_date?: string;
  future_limit_on_ads_running_or_in_review?: number;
  recommendations: VolumeRecommendation[];
}

class AdsVolumeManager {
  async monitorAccountVolume(accountId: string): Promise<VolumeStatus> {
    // 1. 현재 볼륨 상태 확인
    const volumeData = await this.getVolumeData(accountId);

    // 2. 제한 임계값 분석
    const thresholdAnalysis = this.analyzeThresholds(volumeData);

    // 3. 알림 및 경고 생성
    const alerts = this.generateAlerts(thresholdAnalysis);

    return { volumeData, thresholdAnalysis, alerts };
  }

  async optimizeVolumeUsage(accountId: string): Promise<OptimizationResult> {
    // 1. 권장사항 수집
    const recommendations = await this.getRecommendations(accountId);

    // 2. 자동 최적화 실행
    const optimizationActions = await this.executeOptimizations(recommendations);

    return { recommendations, optimizationActions };
  }
}
```

**볼륨 최적화 엔진**
```typescript
interface VolumeOptimizationRule {
  trigger: 'threshold_warning' | 'threshold_critical' | 'future_limit_approaching';
  action: 'pause_low_performers' | 'consolidate_ads' | 'redistribute_budget';
  threshold: number;
  priority: 'high' | 'medium' | 'low';
}

class VolumeOptimizer {
  async applyVolumeOptimization(accountId: string, rules: VolumeOptimizationRule[]): Promise<OptimizationResult> {
    const volumeStatus = await this.getVolumeStatus(accountId);

    for (const rule of rules) {
      if (this.shouldTriggerRule(rule, volumeStatus)) {
        await this.executeOptimization(rule, volumeStatus);
      }
    }
  }

  async predictFutureLimits(accountId: string): Promise<LimitPrediction> {
    // 미래 제한 예측 및 선제적 대응 계획
    const futureData = await this.getFutureLimitData(accountId);
    const prediction = this.calculateLimitPrediction(futureData);

    return { prediction, recommendedActions: this.generatePreemptiveActions(prediction) };
  }
}
```

#### 분할 테스트 활용 전략

**테스트 설계 시스템**
```typescript
interface SplitTestConfig {
  name: string;
  description: string;
  start_time: number;
  end_time: number;
  type: 'SPLIT_TEST';
  cells: SplitTestCell[];
}

interface SplitTestCell {
  name: string;
  treatment_percentage: number;
  adsets?: string[];
  campaigns?: string[];
}

class SplitTestManager {
  async createSplitTest(businessId: string, config: SplitTestConfig): Promise<string> {
    // 1. 테스트 설계 검증
    this.validateTestDesign(config);

    // 2. 통계적 검정력 계산
    const powerAnalysis = await this.calculateStatisticalPower(config);

    // 3. 분할 테스트 생성
    return this.createStudy(businessId, config);
  }

  validateTestDesign(config: SplitTestConfig): void {
    // 단일 변수 테스트 원칙 검증
    // 비교 가능한 테스트 크기 확인
    // 신뢰도 수준 설정 검증
  }
}
```

**테스트 분석 엔진**
```typescript
interface SplitTestResults {
  cellId: string;
  cellName: string;
  treatmentPercentage: number;
  metrics: {
    impressions: number;
    clicks: number;
    conversions: number;
    spend: number;
    cpa: number;
    ctr: number;
    conversionRate: number;
  };
  statisticalSignificance: number;
  confidenceInterval: [number, number];
}

class SplitTestAnalyzer {
  async analyzeTestResults(studyId: string): Promise<SplitTestInsights> {
    // 1. 테스트 결과 수집
    const results = await this.fetchTestResults(studyId);

    // 2. 통계적 유의성 검증
    const significance = this.calculateStatisticalSignificance(results);

    // 3. 승자 셀 결정
    const winner = this.determineWinningCell(results, significance);

    // 4. 권장사항 생성
    const recommendations = this.generateActionRecommendations(winner, results);

    return { results, winner, recommendations, significance };
  }

  determineWinningCell(results: SplitTestResults[], significance: number): SplitTestResults | null {
    // p-value < 0.05 기준 통계적 유의성 검증
    if (significance < 0.05) {
      // 목표 지표 기준 최고 성과 셀 선택 (예: 가장 낮은 CPA)
      return results.reduce((best, current) =>
        current.metrics.cpa < best.metrics.cpa ? current : best
      );
    }
    return null; // 통계적 유의성 없음
  }
}
```

#### Lift Studies 활용 전략

**실험 설계 시스템**
```typescript
interface LiftStudyConfig {
  name: string;
  description: string;
  startTime: number;
  endTime: number;
  observationEndTime: number;
  type: 'LIFT';
  cells: StudyCell[];
  objectives: StudyObjective[];
  viewers: string[];
}

interface StudyCell {
  name: string;
  description: string;
  treatmentPercentage: number;  // 광고를 보는 그룹 비율
  controlPercentage: number;    // 광고를 보지 않는 그룹 비율
  adAccounts?: string[];
  campaigns?: string[];
}

class LiftStudyManager {
  async createLiftStudy(businessId: string, config: LiftStudyConfig): Promise<string> {
    // 1. 실험 설계 검증
    this.validateStudyDesign(config);

    // 2. 최적 실험군/대조군 비율 계산
    const optimizedCells = await this.optimizeCellRatios(config.cells);

    // 3. Lift Study 생성
    return this.createStudy(businessId, { ...config, cells: optimizedCells });
  }
}
```

**결과 분석 엔진**
```typescript
interface LiftStudyResults {
  cellId: string;
  populationTest: number;
  populationControl: number;
  conversionsIncremental: number;
  conversionsConfidence: number;
  conversionsIncrementalLower: number;
  conversionsIncrementalUpper: number;
  conversionsCPiC: number;
  conversionsIncrementalShare: number;
}

class LiftResultsAnalyzer {
  async analyzeLiftResults(studyId: string): Promise<LiftInsights> {
    // 1. 결과 데이터 수집
    const results = await this.fetchStudyResults(studyId);

    // 2. 통계적 유의성 검증
    const significance = this.validateStatisticalSignificance(results);

    // 3. 실질적 의미 평가
    const practicalSignificance = this.assessPracticalSignificance(results);

    // 4. 의사결정 권장사항 생성
    const recommendations = this.generateRecommendations(results, significance);

    return { results, significance, practicalSignificance, recommendations };
  }
}
```

#### 고급 실험 설계

**다중 실험군 전략**
- 여러 광고 전략 동시 비교 (예: 타겟팅 A vs B vs 대조군)
- 예산 배분 최적화 (80% vs 60% vs 40% vs 대조군)
- 크리에이티브 효과 측정 (영상 vs 이미지 vs 대조군)

**실험 기간 최적화**
- 최소 유효 표본 크기 계산
- 시즌성 고려한 실험 기간 설정
- 관찰 기간(observation period) 최적화

#### 주요 추적 패턴

**앱 관련 추적**
```json
{
  "action.type": "mobile_app_install",
  "application": "APP_ID"
}
{
  "action.type": "app_custom_event",
  "application": "APP_ID"
}
```

**웹사이트 전환 추적**
```json
{
  "action.type": "offsite_conversion",
  "fb_pixel": "PIXEL_ID"
}
{
  "action.type": "link_click",
  "object": "URL"
}
```

**소셜 참여 추적**
```json
{
  "action.type": "post_engagement",
  "post": "POST_ID",
  "page": "PAGE_ID"
}
```

#### 다중 픽셀 추적 전략
```json
[
  {"action.type": "offsite_conversion", "fb_pixel": 1},
  {"action.type": "offsite_conversion", "fb_pixel": 2},
  {"action.type": "offsite_conversion", "fb_pixel": 3}
]
```

---

## 🏗️ 핵심 기능 설계

### 1. 광고 데이터 분석 모듈

#### 실시간 성과 모니터링
- **대시보드**: 핵심 KPI 실시간 표시
- **알림 시스템**: 임계값 초과 시 자동 알림
- **트렌드 분석**: 시계열 데이터 기반 패턴 인식

#### 세분화된 리포팅
- **Breakdown 분석**: 인구통계, 디바이스, 위치별 성과
- **캠페인 비교**: 여러 캠페인의 성과 비교 분석
- **ROI/ROAS 분석**: 투자 대비 수익률 계산

#### 예측 분석
- **성과 예측**: 머신러닝 기반 미래 성과 예측
- **예산 최적화**: 예측 모델 기반 예산 배분 추천
- **A/B 테스트**: 통계적 유의성 기반 테스트 결과 분석

### 2. 광고 자동 포스팅 모듈

#### 캠페인 자동 생성
- **템플릿 시스템**: 재사용 가능한 캠페인 템플릿
- **동적 크리에이티브**: 데이터 기반 자동 크리에이티브 생성
- **타겟팅 최적화**: 과거 데이터 기반 오디언스 타겟팅

#### 스케줄링 시스템
- **시간 기반**: 특정 시간/날짜에 자동 실행
- **조건 기반**: 성과 지표 달성 시 자동 실행
- **이벤트 기반**: 외부 이벤트 발생 시 자동 실행

#### 자동 최적화
- **입찰 조정**: 성과 기반 자동 입찰가 조정
- **예산 재배분**: 성과 좋은 광고 세트로 예산 이동
- **일시정지/재개**: 성과 기준에 따른 자동 제어

### 4. 마케팅 믹스 모델링(MMM) 분석 모듈

#### MMM 데이터 수집 시스템
- **다중 계정 관리**: 비즈니스 관리자 수준의 통합 데이터 수집
- **비동기 처리**: 대용량 MMM 데이터의 효율적 처리
- **CSV 최적화**: export_format=csv를 활용한 대용량 데이터 다운로드
- **데이터 검증**: MMM 전용 필터링 규칙 검증 및 오류 처리

#### 마케팅 효과 측정
- **채널 기여도 분석**: 각 마케팅 채널의 순수 기여도 측정
- **증분 효과 계산**: 유기적 성장 대비 광고 효과 분리 측정
- **시너지 분석**: 채널 간 상호작용 및 복합 효과 분석
- **ROI/ROAS 정밀 계산**: MMM 데이터 기반 정확한 수익률 측정

#### 예산 최적화 AI
- **최적 배분 모델**: MMM 데이터 기반 채널별 예산 최적화
- **한계 효용 분석**: 추가 투자 시 예상 수익률 계산
- **시장 포화도 모니터링**: 채널별 성장 한계점 및 포화도 분석
- **장기 전략 수립**: 시간별 트렌드 기반 중장기 투자 계획

### 5. 광고 효과 검증 모듈 (Lift Studies)

#### 무작위 대조 실험 시스템
- **실험 설계 자동화**: 최적 실험군/대조군 비율 자동 계산
- **다중 실험군 관리**: 여러 광고 전략 동시 비교 테스트
- **실시간 모니터링**: 실험 진행 상황 및 예비 결과 실시간 추적
- **윤리적 실험**: 대조군 노출 최소화를 통한 기회비용 감소

### 6. 광고 볼륨 관리 모듈 (Ads Volume Management)

#### 실시간 볼륨 모니터링 시스템
- **다층 제한 추적**: 계정/페이지/비즈니스 관리자 수준별 볼륨 모니터링
- **임계값 기반 알림**: 80%, 90%, 95% 임계값 도달 시 자동 알림
- **미래 제한 예측**: future_limit_activation_date 기반 선제적 대응
- **배우별 세분화**: 페이지별/계정별 상세 볼륨 분석

#### 지능형 볼륨 최적화
- **성과 기반 정리**: 노출 없는 광고(zero_impression) 자동 식별 및 정리
- **학습 제한 해결**: learning_limited 광고 자동 최적화 권장
- **효율적 재배치**: 볼륨 여유 있는 캠페인/광고 세트로 예산 재배분
- **자동 통합**: 중복/비효율 광고 자동 통합 및 최적화

#### 선제적 제한 대응
- **미래 제한 모니터링**: 향후 적용될 제한 사항 사전 추적
- **자동 스케줄 조정**: 제한 적용 전 광고 스케줄 자동 재조정
- **우선순위 기반 관리**: 성과 기준 광고 우선순위 자동 조정
- **다중 계정 밸런싱**: 여러 계정 간 볼륨 균형 자동 관리

### 7. 분할 테스트 관리 모듈 (Split Testing)

#### A/B 테스트 자동화 시스템
- **테스트 설계 자동화**: 변수 분리 원칙 기반 과학적 테스트 설계
- **다변수 테스트 관리**: 타겟팅, 크리에이티브, 예산 등 다양한 변수 개별 테스트
- **실시간 성과 비교**: KPI 기반 효율성 지표 실시간 모니터링
- **자동 의사결정**: 통계적 유의성 기반 승자 셀 자동 식별

#### 통계적 검증 시스템
- **통계적 유의성 검증**: p-value < 0.05 기준 자동 검정
- **신뢰구간 계산**: 95% 신뢰구간 자동 산출 및 해석
- **검정력 분석**: 최소 유효 표본 크기 계산 및 테스트 기간 최적화
- **효과 크기 측정**: 실질적 의미가 있는 차이인지 판단

#### 자동 최적화 시스템
- **승자 셀 확대**: 통계적 유의성 확보 시 자동 예산 재배분
- **패자 셀 정지**: 성과 기준 미달 시 자동 광고 일시정지
- **연속 테스트**: 승자 셀 기반 후속 최적화 테스트 자동 생성
- **학습 루프**: 테스트 결과 기반 향후 캠페인 자동 개선

#### 통계적 유의성 검증
- **신뢰도 구간 계산**: 95% 신뢰구간 자동 계산 및 해석
- **p-value 분석**: 통계적 유의성 자동 검정
- **베이지안 분석**: 사전 확률 업데이트를 통한 더 정확한 추론
- **효과 크기 측정**: 실질적 의미가 있는 효과인지 판단

#### 증분 효과 측정
- **순수 증분 효과**: 광고로 인한 실제 추가 전환 정량화
- **CPiC 계산**: Cost Per Incremental Conversion 자동 산출
- **장기 효과 추적**: 캠페인 종료 후 지속 효과 측정
- **브랜드 효과 분석**: 직접 전환 외 브랜드 인지도 영향 측정

#### 의사결정 지원 시스템
- **자동 권장사항**: 통계적 유의성 기반 액션 플랜 제시
- **예산 재배분**: 실험 결과 기반 실시간 예산 최적화
- **캠페인 제어**: 성과 기준에 따른 자동 캠페인 조정
- **리스크 관리**: 실험 실패 시 자동 롤백 시스템

### 8. 추적 및 전환 관리 시스템

#### 추적 사양 관리
- **템플릿 라이브러리**: 광고 목표별 기본 추적 사양 템플릿
- **커스텀 빌더**: 사용자 정의 추적 사양 생성 도구
- **다중 추적**: 여러 픽셀/이벤트 동시 추적 설정

#### 전환 퍼널 분석
- **단계별 분석**: 노출 → 클릭 → 전환 각 단계 성과
- **이탈 지점 식별**: 전환율이 떨어지는 구간 파악
- **최적화 제안**: 퍼널 개선을 위한 액션 플랜

#### 성과 측정 확장
- **행동별 리포팅**: 추적된 모든 행동의 세분화된 분석
- **전환 가치 추적**: 매출 기반 ROI/ROAS 정확한 계산
- **어트리뷰션 모델링**: 다양한 어트리뷰션 모델 적용

### 9. 광고 규칙 엔진 모듈 (Ad Rules Engine)

#### 중앙 규칙 관리 시스템
- **통합 규칙 대시보드**: 모든 자동화 규칙의 중앙 관리 및 모니터링
- **규칙 템플릿 라이브러리**: 업종별/목표별 사전 정의된 규칙 템플릿
- **시각적 규칙 빌더**: 드래그 앤 드롭 방식의 직관적 규칙 생성 도구
- **규칙 시뮬레이션**: 적용 전 규칙의 예상 효과 미리보기

#### 이중 실행 모드 시스템

**스케줄 기반 실행 (Schedule-Based Rules)**
- **DAILY**: 광고 계정 시간대 자정 실행
- **HOURLY**: 매시간 정시 실행
- **SEMI_HOURLY**: 30분 간격 실행
- **CUSTOM**: 정교한 맞춤 스케줄
  - start_minute/end_minute: 정확한 실행 시간 제어 (30분 단위)
  - days: 특정 요일 지정 (0=일요일, 6=토요일)
  - 시간 범위 및 다중 스케줄 조합 지원

**트리거 기반 실행 (Trigger-Based Rules) - 실시간 모니터링**
- **METADATA_CREATION**: 광고 객체 생성 즉시 트리거
- **METADATA_UPDATE**: 메타데이터 변경 시 트리거 (대기시간: 몇 초)
- **STATS_CHANGE**: 인사이트 데이터 false→true 변화 시 트리거 (대기시간: ~7.5분)
- **STATS_MILESTONE**: 특정 값의 배수 도달 시 트리거 (impressions≥1000, clicks≥10 등)
- **DELIVERY_INSIGHTS_CHANGE**: 게재 최적화 인사이트 변경 시 트리거 (베타)

**고급 트리거 제어**
- **debounce_time**: 중복 실행 방지를 위한 대기 시간
- **operator 지원**: GREATER_THAN, LESS_THAN, IN_RANGE, NOT_IN_RANGE
- **복합 조건**: 트리거 + 필터의 논리적 AND 조합

#### 고급 조건 필터링 시스템
- **메타데이터 필터**: 캠페인명, 광고 세트명, 태그 등 기본 정보 기반 조건
- **인사이트 데이터 필터**: CPA, ROAS, CTR, 전환율 등 성과 지표 기반 조건
- **복합 조건**: AND/OR 논리 연산자를 활용한 복잡한 조건 조합
- **동적 임계값**: 과거 성과 대비 상대적 임계값 및 시장 벤치마크 비교

#### 자동 액션 실행 시스템 (9가지 실행 유형)

**Meta 공식 실행 유형 완전 지원**
- **NOTIFICATION**: 강조된 알림 전송 및 일일 요약 이메일
- **PAUSE/UNPAUSE**: 광고 객체 일시정지 및 재개
- **CHANGE_BUDGET**: 광고 세트 예산 동적 조정
- **CHANGE_CAMPAIGN_BUDGET**: 캠페인 예산 동적 조정
- **CHANGE_BID**: 광고 세트 입찰가 동적 조정
- **ROTATE**: 광고 순환 시스템 (활성 광고 일시정지 → 다음 광고 활성화)
- **REBALANCE_BUDGET**: 지능형 예산 재배분 시스템
- **PING_ENDPOINT**: Webhook 연동을 통한 외부 시스템 알림

**고급 실행 제어 옵션**
- **execution_count_limit**: 개별 광고별 최대 실행 횟수 제한
- **action_frequency**: 동일 액션 간 최소 대기 시간 (분 단위)
- **user_ids**: 알림 수신자 및 일일 요약 이메일 구독자 설정
- **change_spec**: 정교한 예산/입찰가 변경 사양 (amount, limit, unit, target_field)

#### 스마트 학습 시스템
- **성과 패턴 학습**: 과거 규칙 실행 결과를 학습하여 임계값 자동 조정
- **계절성 인식**: 시즌, 요일, 시간대별 성과 패턴 인식 및 적용
- **예외 상황 처리**: 특수 이벤트, 프로모션 기간 등 예외 상황 자동 감지
- **A/B 테스트 통합**: 규칙 효과성을 위한 자동 A/B 테스트 실행

#### 규칙 모니터링 및 거버넌스
- **실행 로그**: 모든 규칙 실행의 상세 기록 및 추적
- **성과 분석**: 규칙별 ROI 및 효과성 측정
- **안전장치**: 과도한 변경 방지를 위한 안전 임계값 설정
- **승인 워크플로우**: 중요 규칙의 수동 승인 프로세스

#### 실무 규칙 예시 (Meta API 공식 사양 기반)

**1. 스케줄 기반 예산 조정 규칙 (CHANGE_BUDGET)**
```json
{
  "name": "High Frequency Budget Reducer",
  "schedule_spec": {
    "schedule_type": "CUSTOM",
    "schedule": [
      {
        "start_minute": 0,
        "days": [2, 5]  // 화요일, 금요일 자정
      }
    ]
  },
  "evaluation_spec": {
    "evaluation_type": "SCHEDULE",
    "filters": [
      {
        "field": "entity_type",
        "value": "ADSET",
        "operator": "EQUAL"
      },
      {
        "field": "time_preset",
        "value": "LIFETIME",
        "operator": "EQUAL"
      },
      {
        "field": "impressions",
        "value": 8000,
        "operator": "GREATER_THAN"
      },
      {
        "field": "frequency",
        "value": 5.0,
        "operator": "GREATER_THAN"
      }
    ]
  },
  "execution_spec": {
    "execution_type": "CHANGE_BUDGET",
    "execution_options": [
      {
        "field": "change_spec",
        "value": {
          "amount": -30,
          "unit": "PERCENTAGE"
        },
        "operator": "EQUAL"
      },
      {
        "field": "execution_count_limit",
        "value": 5,
        "operator": "EQUAL"
      },
      {
        "field": "action_frequency",
        "value": 10080,  // 1주일 간격
        "operator": "EQUAL"
      }
    ]
  }
}
```

**2. target_field 기반 동적 입찰가 조정 규칙 (CHANGE_BID)**
```json
{
  "name": "Dynamic CPA Bid Adjustment",
  "schedule_spec": {
    "schedule_type": "DAILY"
  },
  "evaluation_spec": {
    "evaluation_type": "SCHEDULE",
    "filters": [
      {
        "field": "id",
        "value": [123, 456, 789],
        "operator": "IN"
      },
      {
        "field": "time_preset",
        "value": "LIFETIME",
        "operator": "EQUAL"
      },
      {
        "field": "mobile_app_install",
        "value": 100,
        "operator": "GREATER_THAN"
      },
      {
        "field": "cost_per_mobile_app_install",
        "value": [4.5, 5.5],
        "operator": "NOT_IN_RANGE"  // 10% 허용 오차 범위
      }
    ]
  },
  "execution_spec": {
    "execution_type": "CHANGE_BID",
    "execution_options": [
      {
        "field": "change_spec",
        "value": {
          "amount": 5.0,                    // 목표 CPA $5.0
          "limit": [2.0, 10.0],            // 입찰가 범위 제한
          "target_field": "cost_per_mobile_app_install"
        },
        "operator": "EQUAL"
      }
    ]
  }
}
```

**3. 트리거 기반 실시간 알림 규칙 (STATS_CHANGE)**
```json
{
  "name": "High CPA Real-time Alert",
  "evaluation_spec": {
    "evaluation_type": "TRIGGER",
    "trigger": {
      "type": "STATS_CHANGE",
      "field": "cost_per_purchase_fb",
      "value": 1000,  // $10.00 = 1000 센트
      "operator": "GREATER_THAN"
    },
    "filters": [
      {
        "field": "entity_type",
        "value": "AD",
        "operator": "EQUAL"
      },
      {
        "field": "time_preset",
        "value": "LAST_3_DAYS",
        "operator": "EQUAL"
      },
      {
        "field": "reach",
        "value": 5000,
        "operator": "GREATER_THAN"
      }
    ]
  },
  "execution_spec": {
    "execution_type": "PAUSE",
    "execution_options": [
      {
        "field": "user_ids",
        "value": [123456, 789012],
        "operator": "EQUAL"
      }
    ]
  }
}
```

**4. 메타데이터 생성 모니터링 규칙 (METADATA_CREATION)**
```json
{
  "name": "New Ad Creation Monitor",
  "evaluation_spec": {
    "evaluation_type": "TRIGGER",
    "trigger": {
      "type": "METADATA_CREATION"
    },
    "filters": [
      {
        "field": "entity_type",
        "value": "AD",
        "operator": "EQUAL"
      },
      {
        "field": "campaign.objective",
        "value": ["APP_INSTALLS"],
        "operator": "IN"
      }
    ]
  },
  "execution_spec": {
    "execution_type": "PING_ENDPOINT"
  }
}
```

**5. 통계 마일스톤 규칙 (STATS_MILESTONE)**
```json
{
  "name": "Comment Milestone Tracker",
  "evaluation_spec": {
    "evaluation_type": "TRIGGER",
    "trigger": {
      "type": "STATS_MILESTONE",
      "field": "post_comment",
      "value": 1,
      "operator": "EQUAL"
    },
    "filters": [
      {
        "field": "entity_type",
        "value": "CAMPAIGN",
        "operator": "EQUAL"
      },
      {
        "field": "time_preset",
        "value": "LIFETIME",
        "operator": "EQUAL"
      }
    ]
  },
  "execution_spec": {
    "execution_type": "NOTIFICATION",
    "execution_options": [
      {
        "field": "user_ids",
        "value": [123456],
        "operator": "EQUAL"
      }
    ]
  }
}
```

**6. 예산 재조정 규칙 (REBALANCE_BUDGET)**
```json
{
  "name": "Smart Budget Rebalancing",
  "schedule_spec": {
    "schedule_type": "DAILY"
  },
  "evaluation_spec": {
    "evaluation_type": "SCHEDULE",
    "filters": [
      {
        "field": "entity_type",
        "value": "ADSET",
        "operator": "EQUAL"
      },
      {
        "field": "effective_status",
        "value": ["ACTIVE"],
        "operator": "IN"
      },
      {
        "field": "frequency",
        "value": 4.0,
        "operator": "GREATER_THAN"
      }
    ]
  },
  "execution_spec": {
    "execution_type": "REBALANCE_BUDGET",
    "execution_options": [
      {
        "field": "rebalance_spec",
        "value": {
          "rebalance_method": "PROPORTIONAL",
          "performance_metric": "cost_per_result",
          "rebalance_threshold": 0.8
        },
        "operator": "EQUAL"
      }
    ]
  }
}
```

**7. 고급 필터링 집계 규칙 (AGGREGATE)**
```json
{
  "name": "Multi-Ad Reach Optimization",
  "schedule_spec": {
    "schedule_type": "CUSTOM",
    "schedule": [
      {
        "start_minute": 390,  // 오전 6시 30분
        "days": [1, 3, 5]     // 월, 수, 금
      }
    ]
  },
  "evaluation_spec": {
    "evaluation_type": "SCHEDULE",
    "filters": [
      {
        "field": "aggregation_id",
        "value": [1234, 5678, 9012],
        "operator": "IN"
      },
      {
        "field": "aggregate(reach)",
        "value": 50000,
        "operator": "GREATER_THAN"
      },
      {
        "field": "aggregate(frequency)",
        "value": 3.5,
        "operator": "GREATER_THAN"
      }
    ]
  },
  "execution_spec": {
    "execution_type": "CHANGE_BUDGET",
    "execution_options": [
      {
        "field": "change_spec",
        "value": {
          "amount": -15,
          "unit": "PERCENTAGE"
        },
        "operator": "EQUAL"
      }
    ]
  }
}
```

**8. 공식 필드 활용 효율성 규칙 (FORMULA)**
```json
{
  "name": "Budget Utilization Efficiency",
  "schedule_spec": {
    "schedule_type": "DAILY"
  },
  "evaluation_spec": {
    "evaluation_type": "SCHEDULE",
    "filters": [
      {
        "field": "entity_type",
        "value": "ADSET",
        "operator": "EQUAL"
      },
      {
        "field": "today_spent / adset.daily_budget",
        "value": 0.9,
        "operator": "GREATER_THAN"
      },
      {
        "field": "0.7 * cost_per_result + 0.3 * frequency",
        "value": 8.0,
        "operator": "LESS_THAN"
      }
    ]
  },
  "execution_spec": {
    "execution_type": "CHANGE_BUDGET",
    "execution_options": [
      {
        "field": "change_spec",
        "value": {
          "amount": 25,
          "unit": "PERCENTAGE"
        },
        "operator": "EQUAL"
      }
    ]
  }
}
```

**9. 프리픽스 인사이트 고급 필터링 (PREFIXED_INSIGHTS)**
```json
{
  "name": "Campaign Level Performance Monitor",
  "schedule_spec": {
    "schedule_type": "SEMI_HOURLY"
  },
  "evaluation_spec": {
    "evaluation_type": "SCHEDULE",
    "filters": [
      {
        "field": "entity_type",
        "value": "AD",
        "operator": "EQUAL"
      },
      {
        "field": "campaign.28d_view_7d_click:last_7d_spent",
        "value": 5000,
        "operator": "GREATER_THAN"
      },
      {
        "field": "adset.yesterday_cost_per_result",
        "value": 12.0,
        "operator": "GREATER_THAN"
      }
    ]
  },
  "execution_spec": {
    "execution_type": "PAUSE"
  }
}
```

**10. Webhook 통합 PING_ENDPOINT 규칙**
```json
{
  "name": "Real-time Performance Alert System",
  "evaluation_spec": {
    "evaluation_type": "TRIGGER",
    "trigger": {
      "type": "STATS_CHANGE",
      "field": "cost_per_purchase",
      "value": 2000,  // $20.00 = 2000 센트
      "operator": "GREATER_THAN"
    },
    "filters": [
      {
        "field": "entity_type",
        "value": "ADSET",
        "operator": "EQUAL"
      },
      {
        "field": "time_preset",
        "value": "TODAY",
        "operator": "EQUAL"
      },
      {
        "field": "purchases",
        "value": 10,
        "operator": "GREATER_THAN"
      }
    ]
  },
  "execution_spec": {
    "execution_type": "PING_ENDPOINT",
    "execution_options": [
      {
        "field": "webhook_url",
        "value": "https://api.example.com/alerts/meta-rules",
        "operator": "EQUAL"
      },
      {
        "field": "payload_template",
        "value": {
          "alert_type": "high_cpa",
          "object_id": "{object_id}",
          "current_cpa": "{cost_per_purchase}",
          "threshold": 2000,
          "timestamp": "{execution_time}"
        },
        "operator": "EQUAL"
      }
    ]
  }
}
```

**11. 복합 스케줄 실행 규칙 (COMPLEX_SCHEDULE)**
```json
{
  "name": "Business Hours Campaign Optimization",
  "schedule_spec": {
    "schedule_type": "CUSTOM",
    "schedule": [
      {
        "start_minute": 540,   // 오전 9시
        "end_minute": 1080,    // 오후 6시
        "days": [1, 2, 3, 4, 5] // 평일
      },
      {
        "start_minute": 720,   // 오후 12시
        "end_minute": 840,     // 오후 2시
        "days": [0, 6]         // 주말
      }
    ]
  },
  "evaluation_spec": {
    "evaluation_type": "SCHEDULE",
    "filters": [
      {
        "field": "entity_type",
        "value": "CAMPAIGN",
        "operator": "EQUAL"
      },
      {
        "field": "objective",
        "value": ["CONVERSIONS", "LEAD_GENERATION"],
        "operator": "IN"
      },
      {
        "field": "last_3d_cost_per_result",
        "value": 15.0,
        "operator": "LESS_THAN"
      }
    ]
  },
  "execution_spec": {
    "execution_type": "CHANGE_CAMPAIGN_BUDGET",
    "execution_options": [
      {
        "field": "change_spec",
        "value": {
          "amount": 20,
          "unit": "PERCENTAGE",
          "limit": [1000, 50000]  // $10 - $500 범위
        },
        "operator": "EQUAL"
      }
    ]
  }
}
```

**12. ROAS 기반 동적 최적화 규칙 (ROAS_OPTIMIZATION)**
```json
{
  "name": "Dynamic ROAS Target Adjustment",
  "schedule_spec": {
    "schedule_type": "DAILY"
  },
  "evaluation_spec": {
    "evaluation_type": "SCHEDULE",
    "filters": [
      {
        "field": "id",
        "value": [123, 456, 789],
        "operator": "IN"
      },
      {
        "field": "time_preset",
        "value": "LAST_ND_14_8",
        "operator": "EQUAL"
      },
      {
        "field": "attribution_window",
        "value": "7D_VIEW_1D_CLICK",
        "operator": "EQUAL"
      },
      {
        "field": "hours_since_creation",
        "value": 168,  // 7일
        "operator": "GREATER_THAN"
      },
      {
        "field": "website_purchase_roas",
        "value": [0.95, 1.05],  // ±5% 허용 범위
        "operator": "NOT_IN_RANGE"
      }
    ]
  },
  "execution_spec": {
    "execution_type": "CHANGE_BID",
    "execution_options": [
      {
        "field": "change_spec",
        "value": {
          "amount": 1.0,  // 목표 ROAS 1.0
          "target_field": "website_purchase_roas",
          "limit": [0.5, 5.0]  // 입찰가 조정 범위
        },
        "operator": "EQUAL"
      },
      {
        "field": "execution_count_limit",
        "value": 3,
        "operator": "EQUAL"
      },
      {
        "field": "action_frequency",
        "value": 1440,  // 24시간 간격
        "operator": "EQUAL"
      }
    ]
  }
}
```

---

## 🏛️ 기술 아키텍처

### 적응형 Rate Limiting 시스템

#### 동적 조절 알고리즘
```typescript
interface RateLimitConfig {
  appUtilThreshold: number;    // app_id_util_pct 임계값
  accUtilThreshold: number;    // acc_id_util_pct 임계값
  backoffMultiplier: number;   // 백오프 배수
  maxRetries: number;          // 최대 재시도
}

class AdaptiveThrottler {
  adjustRequestInterval(utilization: number): number {
    if (utilization > 90) return 5000;  // 5초 대기
    if (utilization > 80) return 3000;  // 3초 대기
    if (utilization > 70) return 1000;  // 1초 대기
    return 500;  // 기본 500ms
  }
}
```

### 3단계 캐싱 시스템

#### 계층별 캐싱 전략
- **L1 - Memory Cache**: 초단기 데이터 (1-5분)
- **L2 - Redis**: 단기 데이터 (1-24시간)
- **L3 - Database**: 장기 데이터 (1일-1년)

#### 캐시 무효화 전략
- **TTL 기반**: 시간 기반 자동 만료
- **이벤트 기반**: 데이터 변경 시 즉시 무효화
- **LRU 정책**: 메모리 압박 시 최근 사용도 기반 제거

### 비동기 작업 처리 시스템

#### Job Queue Architecture
```typescript
interface AsyncJob {
  id: string;
  type: 'COMPLEX_QUERY' | 'BULK_OPERATION' | 'REPORT_GENERATION' | 'MMM_COLLECTION' | 'LIFT_STUDY';
  payload: any;
  priority: 'HIGH' | 'MEDIUM' | 'LOW';
  retryCount: number;
  status: 'PENDING' | 'RUNNING' | 'COMPLETED' | 'FAILED';
}

class JobManager {
  async processComplexQuery(query: InsightsQuery): Promise<JobResult> {
    // 13개월 초과 데이터 처리
    // 복잡한 breakdown 조합 최적화
    // 배치 처리로 API 호출 최소화
  }

  async processMMMCollection(businessId: string): Promise<MMMJobResult> {
    // 비즈니스 관리자 수준 MMM 데이터 수집
    // 다중 계정 순차 처리
    // CSV 내보내기 최적화
    // 대용량 데이터 스트리밍 처리
  }

  async processLiftStudy(studyConfig: LiftStudyConfig): Promise<LiftStudyJobResult> {
    // Lift Study 생성 및 관리
    // 실험 진행 상황 모니터링
    // 결과 분석 및 통계적 검증
    // 자동 권장사항 생성
  }

  async processSplitTest(testConfig: SplitTestConfig): Promise<SplitTestJobResult> {
    // Split Test 생성 및 관리
    // 테스트 진행 상황 실시간 모니터링
    // 통계적 유의성 자동 검증
    // 승자 셀 식별 및 자동 최적화
    // 연속 테스트 자동 생성
  }

  async processVolumeOptimization(accountId: string): Promise<VolumeOptimizationJobResult> {
    // 광고 볼륨 실시간 모니터링
    // 임계값 기반 자동 알림 및 최적화
    // 성과 기반 광고 정리 및 통합
    // 미래 제한 예측 및 선제적 대응
    // 다중 계정 볼륨 밸런싱
  }
}
```

### 광고 볼륨 관리 시스템

#### 볼륨 모니터링 엔진
```typescript
interface VolumeMonitoringConfig {
  accountId: string;
  pageIds?: string[];
  thresholds: {
    warning: number;    // 80% 경고
    critical: number;   // 90% 위험
    emergency: number;  // 95% 긴급
  };
  monitoringInterval: number; // 분 단위
}

class VolumeMonitoringEngine {
  async startContinuousMonitoring(config: VolumeMonitoringConfig): Promise<void> {
    // 1. 실시간 볼륨 상태 추적
    const monitoringLoop = setInterval(async () => {
      const volumeStatus = await this.checkVolumeStatus(config.accountId);

      // 2. 임계값 기반 알림 생성
      const alerts = this.generateThresholdAlerts(volumeStatus, config.thresholds);

      // 3. 자동 대응 액션 실행
      if (alerts.length > 0) {
        await this.executeEmergencyActions(alerts, volumeStatus);
      }
    }, config.monitoringInterval * 60 * 1000);
  }

  async executeEmergencyActions(alerts: VolumeAlert[], status: VolumeStatus): Promise<void> {
    for (const alert of alerts) {
      switch (alert.severity) {
        case 'emergency':
          await this.pauseLowPerformingAds(status.accountId);
          break;
        case 'critical':
          await this.consolidateSimilarAds(status.accountId);
          break;
        case 'warning':
          await this.flagForReview(status.accountId);
          break;
      }
    }
  }
}
```

#### 자동 볼륨 최적화 시스템
```typescript
interface VolumeOptimizationStrategy {
  type: 'zero_impression_cleanup' | 'learning_limited_fix' | 'campaign_consolidation' | 'budget_redistribution';
  priority: number;
  automationLevel: 'automatic' | 'assisted' | 'manual';
}

class AutoVolumeOptimizer {
  async optimizeAccountVolume(accountId: string): Promise<OptimizationReport> {
    // 1. 현재 상태 분석
    const analysis = await this.analyzeVolumeEfficiency(accountId);

    // 2. 최적화 전략 수립
    const strategies = this.planOptimizationStrategies(analysis);

    // 3. 자동 최적화 실행
    const results = await this.executeOptimizations(strategies);

    return {
      beforeOptimization: analysis.currentState,
      afterOptimization: analysis.projectedState,
      actionsExecuted: results.actions,
      volumeReduction: results.volumeReduction,
      performanceImpact: results.performanceImpact
    };
  }

  async handleZeroImpressionAds(accountId: string): Promise<CleanupResult> {
    // 노출 없는 광고 자동 식별 및 정리
    const zeroImpressionAds = await this.identifyZeroImpressionAds(accountId);

    // 성과 기록 분석 후 안전한 광고만 정리
    const safeToRemove = this.filterSafeToRemoveAds(zeroImpressionAds);

    // 자동 정리 실행
    const cleanupResults = await this.pauseAds(safeToRemove);

    return {
      totalAdsAnalyzed: zeroImpressionAds.length,
      adsPaused: cleanupResults.length,
      volumeReduction: cleanupResults.length,
      estimatedPerformanceImpact: 'none'
    };
  }
}
```

### 분할 테스트 관리 시스템

#### 테스트 라이프사이클 관리
```typescript
interface SplitTestLifecycle {
  testId: string;
  businessId: string;
  status: 'DRAFT' | 'PENDING' | 'ACTIVE' | 'COMPLETED' | 'FAILED';
  createdAt: Date;
  startTime: Date;
  endTime: Date;
  cells: SplitTestCell[];
  results?: SplitTestResults[];
}

class SplitTestOrchestrator {
  async manageSplitTestLifecycle(testId: string): Promise<void> {
    // 1. 테스트 상태 모니터링
    const test = await this.getTestStatus(testId);

    // 2. 테스트 단계별 자동 처리
    switch (test.status) {
      case 'ACTIVE':
        await this.monitorActiveTest(testId);
        break;
      case 'COMPLETED':
        await this.processCompletedTest(testId);
        break;
    }

    // 3. 자동 최적화 및 확장
    await this.applyOptimizations(testId);
  }

  async optimizeTestDesign(config: SplitTestConfig): Promise<OptimizedSplitTestConfig> {
    // 통계적 검정력 계산
    const power = this.calculateStatisticalPower(config);

    // 최소 표본 크기 계산
    const minSampleSize = this.calculateMinSampleSize(config);

    // 최적 셀 분할 비율 계산
    const optimalRatio = this.calculateOptimalCellRatio(minSampleSize, power);

    return { ...config, optimizedCells: optimalRatio };
  }
}
```

#### 자동 최적화 엔진
```typescript
interface AutoOptimizationRule {
  trigger: 'statistical_significance' | 'performance_threshold' | 'time_limit';
  action: 'scale_winner' | 'pause_loser' | 'create_follow_up' | 'redistribute_budget';
  threshold: number;
  confidence: number;
}

class SplitTestOptimizer {
  async applyAutoOptimization(testId: string, rules: AutoOptimizationRule[]): Promise<OptimizationResult> {
    const results = await this.getTestResults(testId);
    const significance = this.calculateStatisticalSignificance(results);

    for (const rule of rules) {
      if (this.shouldTriggerRule(rule, results, significance)) {
        await this.executeOptimization(rule, results);
      }
    }
  }

  async createFollowUpTest(winnerCell: SplitTestResults): Promise<string> {
    // 승자 셀 기반 후속 테스트 설계
    // 새로운 변수 테스트 (예: 크리에이티브 최적화)
    // 자동 테스트 생성 및 시작
  }
}
```

### Lift Studies 실험 관리 시스템

#### 실험 라이프사이클 관리
```typescript
interface LiftStudyLifecycle {
  studyId: string;
  businessId: string;
  status: 'DRAFT' | 'PENDING' | 'ACTIVE' | 'COMPLETED' | 'FAILED';
  createdAt: Date;
  startTime: Date;
  endTime: Date;
  observationEndTime: Date;
}

class LiftStudyOrchestrator {
  async manageLiftStudyLifecycle(studyId: string): Promise<void> {
    // 1. 실험 상태 모니터링
    const study = await this.getStudyStatus(studyId);

    // 2. 실험 단계별 자동 처리
    switch (study.status) {
      case 'ACTIVE':
        await this.monitorActiveStudy(studyId);
        break;
      case 'COMPLETED':
        await this.processCompletedStudy(studyId);
        break;
    }

    // 3. 알림 및 보고서 생성
    await this.generateStudyReports(studyId);
  }

  async optimizeExperimentDesign(config: LiftStudyConfig): Promise<OptimizedConfig> {
    // 통계적 검정력 계산
    const power = this.calculateStatisticalPower(config);

    // 최소 표본 크기 계산
    const minSampleSize = this.calculateMinSampleSize(config.objectives);

    // 최적 실험군/대조군 비율 계산
    const optimalRatio = this.calculateOptimalRatio(minSampleSize, power);

    return { ...config, optimizedCells: optimalRatio };
  }
}
```

#### 통계 분석 엔진
```typescript
interface StatisticalAnalysis {
  pValue: number;
  confidenceInterval: [number, number];
  effectSize: number;
  statisticalPower: number;
  practicalSignificance: boolean;
}

class LiftStatisticsEngine {
  async performStatisticalTest(results: LiftStudyResults): Promise<StatisticalAnalysis> {
    // 1. 통계적 유의성 검정
    const pValue = this.calculatePValue(results);

    // 2. 신뢰구간 계산
    const confidenceInterval = this.calculateConfidenceInterval(results);

    // 3. 효과 크기 측정
    const effectSize = this.calculateEffectSize(results);

    // 4. 검정력 분석
    const statisticalPower = this.calculatePower(results);

    // 5. 실질적 의미 평가
    const practicalSignificance = this.assessPracticalSignificance(effectSize);

    return { pValue, confidenceInterval, effectSize, statisticalPower, practicalSignificance };
  }

  async generateRecommendations(analysis: StatisticalAnalysis): Promise<ActionRecommendations> {
    // 통계적 결과 기반 액션 플랜 생성
    if (analysis.pValue < 0.05 && analysis.practicalSignificance) {
      return this.generateScaleUpRecommendations(analysis);
    } else {
      return this.generateOptimizationRecommendations(analysis);
    }
  }
}
```

### MMM 전용 데이터 처리 시스템

#### MMM 데이터 수집기
```typescript
interface MMMDataCollector {
  businessId: string;
  timeRange: DateRange;
  exportFormat: 'json' | 'csv';
  timeIncrement: number; // 1일 단위 권장
}

class MMMCollectionEngine {
  async collectBusinessManagerMMM(config: MMMDataCollector): Promise<MMMResult> {
    // 1단계: 계정 목록 수집
    const accounts = await this.getAllAccounts(config.businessId);

    // 2단계: 각 계정별 MMM 데이터 수집
    const mmmResults = await this.batchCollectMMM(accounts, config);

    // 3단계: 데이터 집계 및 정규화
    return this.aggregateAndNormalize(mmmResults);
  }

  private validateMMMFilter(filter: any): boolean {
    // MMM 전용 필터링 규칙 검증
    const validator = new MMMFilterValidator();
    return validator.validateAllFilters(filter);
  }
}
```

#### MMM 데이터 분석 엔진
```typescript
interface MMMAnalysisConfig {
  baseline: 'historical' | 'seasonal' | 'trend';
  incrementality: boolean;
  crossChannelSynergy: boolean;
  saturationModeling: boolean;
}

class MMMAnalyzer {
  async analyzeMarketingMix(data: MMMData[], config: MMMAnalysisConfig): Promise<MMMInsights> {
    // 기여도 분석 (Attribution Analysis)
    const attribution = await this.calculateAttribution(data);

    // 증분 효과 계산 (Incrementality)
    const incrementality = config.incrementality
      ? await this.calculateIncrementality(data)
      : null;

    // 채널 간 시너지 분석
    const synergy = config.crossChannelSynergy
      ? await this.analyzeCrossChannelSynergy(data)
      : null;

    // 포화도 모델링
    const saturation = config.saturationModeling
      ? await this.modelSaturationCurves(data)
      : null;

    return { attribution, incrementality, synergy, saturation };
  }
}
```

### 광고 규칙 엔진 시스템 (Meta API 완전 통합)

#### 규칙 실행 엔진
```typescript
interface MetaAdRuleConfig {
  name: string;
  schedule_spec?: {
    schedule_type: 'DAILY' | 'HOURLY' | 'SEMI_HOURLY' | 'CUSTOM';
    schedule?: CustomSchedule[];
  };
  evaluation_spec: {
    evaluation_type: 'SCHEDULE' | 'TRIGGER';
    trigger?: TriggerSpec;
    filters: FilterSpec[];
  };
  execution_spec: {
    execution_type: 'NOTIFICATION' | 'PAUSE' | 'UNPAUSE' | 'CHANGE_BUDGET' |
                   'CHANGE_CAMPAIGN_BUDGET' | 'CHANGE_BID' | 'ROTATE' |
                   'REBALANCE_BUDGET' | 'PING_ENDPOINT';
    execution_options?: ExecutionOption[];
  };
}

interface TriggerSpec {
  type: 'METADATA_CREATION' | 'METADATA_UPDATE' | 'STATS_CHANGE' |
        'STATS_MILESTONE' | 'DELIVERY_INSIGHTS_CHANGE';
  field?: string;
  value?: any;
  operator?: 'EQUAL' | 'GREATER_THAN' | 'LESS_THAN' | 'IN_RANGE' | 'NOT_IN_RANGE';
}

interface ExecutionOption {
  field: 'user_ids' | 'change_spec' | 'rebalance_spec' | 'execution_count_limit' | 'action_frequency';
  value: any;
  operator: 'EQUAL';
}

class MetaAdRuleOrchestrator {
  private scheduleManager: MetaScheduleManager;
  private triggerManager: MetaTriggerManager;
  private webhookManager: WebhookManager;
  private executionQueue: Queue<RuleExecution>;

  async initializeRuleEngine(): Promise<void> {
    // 1. Meta Ad Rules Library API 연동 초기화
    await this.initializeMetaAPI();

    // 2. 활성 규칙 동기화
    const activeRules = await this.syncActiveRulesFromMeta();

    // 3. 스케줄 기반 규칙 등록
    await this.scheduleManager.registerScheduledRules(
      activeRules.filter(rule => rule.evaluation_spec.evaluation_type === 'SCHEDULE')
    );

    // 4. 트리거 기반 규칙 등록 및 Webhook 설정
    await this.triggerManager.registerTriggerRules(
      activeRules.filter(rule => rule.evaluation_spec.evaluation_type === 'TRIGGER')
    );

    // 5. Webhook 엔드포인트 설정 (PING_ENDPOINT용)
    await this.webhookManager.setupWebhookSubscription();

    // 6. 실행 큐 및 워커 시작
    await this.startExecutionWorkers();
  }

  async createMetaAdRule(ruleConfig: MetaAdRuleConfig): Promise<string> {
    // Meta Ad Rules Library API를 통한 규칙 생성
    const response = await fetch(`https://graph.facebook.com/${this.apiVersion}/${this.adAccountId}/adrules_library`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${this.accessToken}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        name: ruleConfig.name,
        schedule_spec: ruleConfig.schedule_spec,
        evaluation_spec: ruleConfig.evaluation_spec,
        execution_spec: ruleConfig.execution_spec
      })
    });

    const result = await response.json();

    if (result.error) {
      throw new Error(`Meta API Error: ${result.error.message}`);
    }

    // 로컬 규칙 관리 시스템에 등록
    await this.registerLocalRule(result.id, ruleConfig);

    return result.id;
  }

  async executeMetaActions(executionSpec: ExecutionSpec, targetEntities: string[]): Promise<ActionResult[]> {
    const results: ActionResult[] = [];

    switch (executionSpec.execution_type) {
      case 'NOTIFICATION':
        results.push(await this.sendNotification(executionSpec.execution_options, targetEntities));
        break;

      case 'PAUSE':
        results.push(await this.pauseEntities(targetEntities));
        break;

      case 'UNPAUSE':
        results.push(await this.unpauseEntities(targetEntities));
        break;

      case 'CHANGE_BUDGET':
        results.push(await this.changeBudget(targetEntities, executionSpec.execution_options));
        break;

      case 'CHANGE_CAMPAIGN_BUDGET':
        results.push(await this.changeCampaignBudget(targetEntities, executionSpec.execution_options));
        break;

      case 'CHANGE_BID':
        results.push(await this.changeBid(targetEntities, executionSpec.execution_options));
        break;

      case 'ROTATE':
        results.push(await this.rotateAds(targetEntities));
        break;

      case 'REBALANCE_BUDGET':
        results.push(await this.rebalanceBudget(targetEntities, executionSpec.execution_options));
        break;

      case 'PING_ENDPOINT':
        results.push(await this.pingWebhookEndpoint(targetEntities));
        break;
    }

    return results;
  }

  private async changeBudget(adsetIds: string[], executionOptions: ExecutionOption[]): Promise<ActionResult> {
    const changeSpec = this.extractChangeSpec(executionOptions);
    const results = [];

    for (const adsetId of adsetIds) {
      // change_spec에 따른 예산 계산
      let newBudget = await this.calculateNewBudget(adsetId, changeSpec);

      // limit 적용
      if (changeSpec.limit) {
        newBudget = this.applyBudgetLimits(newBudget, changeSpec.limit);
      }

      // target_field 기반 동적 조정
      if (changeSpec.target_field) {
        newBudget = await this.calculateTargetFieldBasedBudget(adsetId, changeSpec);
      }

      // Meta API를 통한 예산 업데이트
      const response = await this.updateAdsetBudget(adsetId, newBudget);
      results.push({ adsetId, newBudget, success: response.success });
    }

    return { action: 'CHANGE_BUDGET', results };
  }

  private async calculateTargetFieldBasedBudget(adsetId: string, changeSpec: ChangeSpec): Promise<number> {
    // target_field의 현재 값 조회
    const currentMetrics = await this.getAdsetInsights(adsetId, [changeSpec.target_field]);
    const currentValue = currentMetrics[changeSpec.target_field];

    // 목표값(amount)과 현재값의 차이 계산
    const targetValue = changeSpec.amount;
    const proportionalDifference = (targetValue - currentValue) / currentValue;

    // 현재 예산 조회
    const currentBudget = await this.getCurrentBudget(adsetId);

    // 비례적 예산 조정 계산
    const adjustmentFactor = 1 + proportionalDifference;
    let newBudget = currentBudget * adjustmentFactor;

    // limit 범위 적용
    if (changeSpec.limit && Array.isArray(changeSpec.limit)) {
      const [minLimit, maxLimit] = changeSpec.limit;
      newBudget = Math.max(minLimit, Math.min(maxLimit, newBudget));
    }

    return newBudget;
  }
}
```

#### 스케줄 기반 실행 관리 (Meta Schedule Spec 완전 지원)
```typescript
interface MetaScheduleSpec {
  schedule_type: 'DAILY' | 'HOURLY' | 'SEMI_HOURLY' | 'CUSTOM';
  schedule?: CustomScheduleEntry[];
}

interface CustomScheduleEntry {
  start_minute?: number;    // 자정부터 분 단위 (30분 배수)
  end_minute?: number;      // 시간 범위 지정
  days?: number[];          // 0=일요일, 1=월요일, ..., 6=토요일
}

class MetaScheduleManager {
  private scheduledJobs: Map<string, ScheduleHandler> = new Map();
  private adAccountTimeZone: string;

  async registerScheduledRules(rules: MetaAdRuleConfig[]): Promise<void> {
    // 광고 계정 시간대 조회
    this.adAccountTimeZone = await this.getAdAccountTimeZone();

    for (const rule of rules) {
      if (rule.evaluation_spec.evaluation_type === 'SCHEDULE' && rule.schedule_spec) {
        await this.createScheduledJob(rule);
      }
    }
  }

  private async createScheduledJob(rule: MetaAdRuleConfig): Promise<void> {
    const scheduleSpec = rule.schedule_spec!;

    switch (scheduleSpec.schedule_type) {
      case 'DAILY':
        await this.createDailySchedule(rule);
        break;
      case 'HOURLY':
        await this.createHourlySchedule(rule);
        break;
      case 'SEMI_HOURLY':
        await this.createSemiHourlySchedule(rule);
        break;
      case 'CUSTOM':
        await this.createCustomSchedule(rule, scheduleSpec.schedule!);
        break;
    }
  }

  private async createDailySchedule(rule: MetaAdRuleConfig): Promise<void> {
    // 광고 계정 시간대 자정 실행
    const cronExpression = `0 0 * * *`;  // 매일 00:00

    const job = new CronJob(cronExpression, async () => {
      await this.executeScheduledRule(rule);
    }, null, true, this.adAccountTimeZone);

    this.scheduledJobs.set(rule.name, {
      job,
      rule,
      nextExecution: job.nextDate().toDate()
    });
  }

  private async createCustomSchedule(rule: MetaAdRuleConfig, customSchedule: CustomScheduleEntry[]): Promise<void> {
    for (const scheduleEntry of customSchedule) {
      const cronExpressions = this.convertCustomScheduleToCron(scheduleEntry);

      for (const cronExpression of cronExpressions) {
        const job = new CronJob(cronExpression, async () => {
          await this.executeScheduledRule(rule);
        }, null, true, this.adAccountTimeZone);

        this.scheduledJobs.set(`${rule.name}_${JSON.stringify(scheduleEntry)}`, {
          job,
          rule,
          scheduleEntry,
          nextExecution: job.nextDate().toDate()
        });
      }
    }
  }

  private convertCustomScheduleToCron(entry: CustomScheduleEntry): string[] {
    const cronExpressions: string[] = [];

    if (entry.start_minute !== undefined) {
      const hour = Math.floor(entry.start_minute / 60);
      const minute = entry.start_minute % 60;

      if (entry.end_minute !== undefined) {
        // 시간 범위 지정된 경우 - 30분 간격으로 실행
        const endHour = Math.floor(entry.end_minute / 60);
        const endMinute = entry.end_minute % 60;

        for (let h = hour; h <= endHour; h++) {
          for (let m = (h === hour ? minute : 0); m < 60 && (h < endHour || m <= endMinute); m += 30) {
            const dayPattern = entry.days ? entry.days.join(',') : '*';
            cronExpressions.push(`${m} ${h} * * ${dayPattern}`);
          }
        }
      } else {
        // 정확한 시간 지정된 경우
        const dayPattern = entry.days ? entry.days.join(',') : '*';
        cronExpressions.push(`${minute} ${hour} * * ${dayPattern}`);
      }
    } else if (entry.days) {
      // days만 지정된 경우 - 해당 요일에 SEMI_HOURLY 실행
      const dayPattern = entry.days.join(',');
      cronExpressions.push(`0,30 * * * ${dayPattern}`);
    }

    return cronExpressions;
  }

  private async executeScheduledRule(rule: MetaAdRuleConfig): Promise<void> {
    try {
      // 1. 일일 요약 이메일 생성 (user_ids 설정된 경우)
      const shouldSendSummary = this.shouldSendDailySummary(rule);

      // 2. 규칙 실행
      const executionResult = await this.ruleOrchestrator.executeRule(rule);

      // 3. 실행 결과 로깅
      await this.logScheduledExecution(rule, executionResult);

      // 4. 일일 요약 이메일 전송 (오전 12:30)
      if (shouldSendSummary && this.isTimeForDailySummary()) {
        await this.sendDailySummaryEmail(rule);
      }

    } catch (error) {
      await this.handleScheduleError(rule, error);
    }
  }

  private shouldSendDailySummary(rule: MetaAdRuleConfig): boolean {
    return rule.execution_spec.execution_options?.some(
      option => option.field === 'user_ids'
    ) || false;
  }

  private isTimeForDailySummary(): boolean {
    const now = new Date();
    return now.getHours() === 0 && now.getMinutes() === 30; // 오전 12:30
  }
}
```

#### 트리거 기반 실행 관리 (5가지 트리거 유형 완전 지원)
```typescript
interface MetaTriggerManager {
  metadataMonitors: Map<string, MetadataMonitor>;
  statsMonitors: Map<string, StatsMonitor>;
  webhookHandlers: Map<string, WebhookHandler>;
  deliveryInsightMonitors: Map<string, DeliveryInsightMonitor>;
}

class MetaTriggerManager {
  private webSocketConnections: Map<string, WebSocket> = new Map();
  private pollIntervals: Map<string, NodeJS.Timeout> = new Map();

  async registerTriggerRules(rules: MetaAdRuleConfig[]): Promise<void> {
    for (const rule of rules) {
      if (rule.evaluation_spec.evaluation_type === 'TRIGGER' && rule.evaluation_spec.trigger) {
        await this.createTriggerHandler(rule);
      }
    }
  }

  private async createTriggerHandler(rule: MetaAdRuleConfig): Promise<void> {
    const trigger = rule.evaluation_spec.trigger!;

    switch (trigger.type) {
      case 'METADATA_CREATION':
        await this.createMetadataCreationMonitor(rule);
        break;
      case 'METADATA_UPDATE':
        await this.createMetadataUpdateMonitor(rule, trigger);
        break;
      case 'STATS_CHANGE':
        await this.createStatsChangeMonitor(rule, trigger);
        break;
      case 'STATS_MILESTONE':
        await this.createStatsMilestoneMonitor(rule, trigger);
        break;
      case 'DELIVERY_INSIGHTS_CHANGE':
        await this.createDeliveryInsightsMonitor(rule, trigger);
        break;
    }
  }

  private async createMetadataCreationMonitor(rule: MetaAdRuleConfig): Promise<void> {
    // Meta Webhook을 통한 광고 객체 생성 모니터링
    const webhookHandler = new MetadataCreationHandler({
      ruleId: rule.name,
      filters: rule.evaluation_spec.filters,
      onObjectCreated: async (createdObject) => {
        // 필터 조건 검증
        const passesFilter = await this.evaluateFilters(createdObject, rule.evaluation_spec.filters);

        if (passesFilter) {
          await this.executeTriggerRule(rule, {
            triggerType: 'METADATA_CREATION',
            objectId: createdObject.id,
            objectType: createdObject.entity_type,
            createdAt: new Date()
          });
        }
      }
    });

    this.webhookHandlers.set(`creation_${rule.name}`, webhookHandler);
  }

  private async createMetadataUpdateMonitor(rule: MetaAdRuleConfig, trigger: TriggerSpec): Promise<void> {
    // 실시간 메타데이터 변경 모니터링 (WebSocket + Polling)
    const monitor = new MetadataUpdateMonitor({
      ruleId: rule.name,
      monitoredField: trigger.field!,
      targetValue: trigger.value,
      operator: trigger.operator,
      filters: rule.evaluation_spec.filters,
      checkInterval: 30000, // 30초 간격 (메타데이터는 몇 초 대기시간)
      onMetadataChanged: async (changeData) => {
        await this.executeTriggerRule(rule, {
          triggerType: 'METADATA_UPDATE',
          field: trigger.field!,
          oldValue: changeData.oldValue,
          newValue: changeData.newValue,
          objectId: changeData.objectId,
          changedAt: new Date()
        });
      }
    });

    this.metadataMonitors.set(`metadata_${rule.name}`, monitor);
    await monitor.start();
  }

  private async createStatsChangeMonitor(rule: MetaAdRuleConfig, trigger: TriggerSpec): Promise<void> {
    // 인사이트 데이터 false→true 변화 감지 (~7.5분 대기시간)
    const monitor = new StatsChangeMonitor({
      ruleId: rule.name,
      triggerField: trigger.field!,
      triggerValue: trigger.value,
      triggerOperator: trigger.operator!,
      filters: rule.evaluation_spec.filters,
      checkInterval: 450000, // 7.5분 간격
      previousStates: new Map(), // 이전 상태 추적 (false→true 감지용)
      onStatsChanged: async (changeData) => {
        // false에서 true로 변경된 경우에만 트리거
        if (!changeData.previousCondition && changeData.currentCondition) {
          await this.executeTriggerRule(rule, {
            triggerType: 'STATS_CHANGE',
            field: trigger.field!,
            currentValue: changeData.currentValue,
            previousValue: changeData.previousValue,
            objectId: changeData.objectId,
            changedAt: new Date()
          });
        }
      }
    });

    this.statsMonitors.set(`stats_change_${rule.name}`, monitor);
    await monitor.start();
  }

  private async createStatsMilestoneMonitor(rule: MetaAdRuleConfig, trigger: TriggerSpec): Promise<void> {
    // 특정 값의 배수 도달 감지
    const supportedFields = this.getSupportedMilestoneFields();

    if (!supportedFields.includes(trigger.field!)) {
      throw new Error(`Unsupported milestone field: ${trigger.field}`);
    }

    const minValue = this.getMinimumValueForField(trigger.field!);
    if (trigger.value < minValue) {
      throw new Error(`Value ${trigger.value} is below minimum ${minValue} for field ${trigger.field}`);
    }

    const monitor = new StatsMilestoneMonitor({
      ruleId: rule.name,
      milestoneField: trigger.field!,
      milestoneValue: trigger.value,
      filters: rule.evaluation_spec.filters,
      checkInterval: 300000, // 5분 간격
      lastMilestones: new Map(), // 마지막 달성한 마일스톤 추적
      onMilestoneReached: async (milestoneData) => {
        await this.executeTriggerRule(rule, {
          triggerType: 'STATS_MILESTONE',
          field: trigger.field!,
          milestoneValue: milestoneData.milestoneReached,
          currentValue: milestoneData.currentValue,
          objectId: milestoneData.objectId,
          reachedAt: new Date()
        });
      }
    });

    this.statsMonitors.set(`milestone_${rule.name}`, monitor);
    await monitor.start();
  }

  private async createDeliveryInsightsMonitor(rule: MetaAdRuleConfig, trigger: TriggerSpec): Promise<void> {
    // 게재 인사이트 변경 모니터링 (베타 기능)
    const monitor = new DeliveryInsightsMonitor({
      ruleId: rule.name,
      trigger: trigger,
      filters: rule.evaluation_spec.filters,
      checkInterval: 600000, // 10분 간격 (베타 기능으로 더 보수적)
      onDeliveryInsightChanged: async (changeData) => {
        await this.executeTriggerRule(rule, {
          triggerType: 'DELIVERY_INSIGHTS_CHANGE',
          field: trigger.field!,
          changeData: changeData,
          objectId: changeData.objectId,
          changedAt: new Date()
        });
      }
    });

    this.deliveryInsightMonitors.set(`delivery_${rule.name}`, monitor);
    await monitor.start();
  }

  private getSupportedMilestoneFields(): string[] {
    return [
      'impressions', 'unique_impressions', 'reach', 'clicks', 'unique_clicks',
      'spent', 'results', 'app_custom_event', 'leadgen', 'like', 'link_click',
      'mobile_app_install', 'offsite_conversion', 'post_engagement', 'video_view'
      // ... 전체 지원 필드 목록
    ];
  }

  private getMinimumValueForField(field: string): number {
    const minimumValues = {
      'impressions': 1000,
      'unique_impressions': 1000,
      'reach': 1000,
      'clicks': 10,
      'unique_clicks': 10,
      'spent': 1000, // 센트 단위
      'results': 5,
      'mobile_app_install': 1,
      'offsite_conversion': 1
      // ... 전체 최소값 매핑
    };

    return minimumValues[field] || 1;
  }

  private async executeTriggerRule(rule: MetaAdRuleConfig, triggerContext: TriggerContext): Promise<void> {
    try {
      // 1. 추가 필터 조건 검증
      const passesAllFilters = await this.evaluateAllFilters(triggerContext.objectId, rule.evaluation_spec.filters);

      if (!passesAllFilters) {
        return; // 필터 조건 미충족
      }

      // 2. 실행 액션 수행
      const actionResults = await this.ruleOrchestrator.executeMetaActions(
        rule.execution_spec,
        [triggerContext.objectId]
      );

      // 3. Webhook 알림 전송 (PING_ENDPOINT인 경우)
      if (rule.execution_spec.execution_type === 'PING_ENDPOINT') {
        await this.sendWebhookNotification(rule, triggerContext, actionResults);
      }

      // 4. 실행 결과 로깅
      await this.logTriggerExecution(rule, triggerContext, actionResults);

    } catch (error) {
      await this.handleTriggerError(rule, triggerContext, error);
    }
  }

  private async sendWebhookNotification(rule: MetaAdRuleConfig, context: TriggerContext, results: ActionResult[]): Promise<void> {
    const webhookPayload = {
      object: 'application',
      entry: [{
        id: this.applicationId,
        time: Math.floor(Date.now() / 1000),
        changes: [{
          field: 'ads_rules_engine',
          value: {
            'rule_id': rule.name,
            'object_id': context.objectId,
            'object_type': context.objectType || 'UNKNOWN',
            'trigger_type': context.triggerType,
            'trigger_field': context.field,
            'current_value': JSON.stringify(context.currentValue)
          }
        }]
      }]
    };

    // 등록된 Webhook URL로 POST 요청
    await this.webhookClient.sendNotification(webhookPayload);
  }
}
```

#### Webhook 통합 시스템 (PING_ENDPOINT 지원)
```typescript
interface WebhookManager {
  appId: string;
  appAccessToken: string;
  callbackUrl: string;
  verifyToken: string;
  subscriptionActive: boolean;
}

class MetaWebhookManager {
  async setupWebhookSubscription(): Promise<void> {
    // 1. Facebook 앱에 ads_rules_engine Webhook 구독 설정
    const subscriptionResponse = await fetch(`https://graph.facebook.com/${this.apiVersion}/${this.appId}/subscriptions`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${this.appAccessToken}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        object: 'application',
        callback_url: this.callbackUrl,
        fields: 'ads_rules_engine',
        verify_token: this.verifyToken
      })
    });

    if (!subscriptionResponse.ok) {
      throw new Error('Failed to setup webhook subscription');
    }

    // 2. Webhook 엔드포인트 검증 및 등록
    await this.setupWebhookEndpoint();
  }

  async setupWebhookEndpoint(): Promise<void> {
    // Express.js 기반 Webhook 엔드포인트 설정
    this.app.get('/webhook', (req, res) => {
      // 인증 챌린지 처리
      const mode = req.query['hub.mode'];
      const token = req.query['hub.verify_token'];
      const challenge = req.query['hub.challenge'];

      if (mode && token) {
        if (mode === 'subscribe' && token === this.verifyToken) {
          console.log('Webhook verified');
          res.status(200).send(challenge);
        } else {
          res.status(403).send('Forbidden');
        }
      }
    });

    this.app.post('/webhook', (req, res) => {
      // 규칙 엔진 알림 처리
      const body = req.body;

      if (body.object === 'application') {
        body.entry.forEach((entry) => {
          entry.changes.forEach((change) => {
            if (change.field === 'ads_rules_engine') {
              this.processRuleEngineWebhook(change.value);
            }
          });
        });
      }

      res.status(200).send('EVENT_RECEIVED');
    });
  }

  async processRuleEngineWebhook(webhookData: any): Promise<void> {
    // Webhook 데이터 구조:
    // {
    //   'rule_id': 1234,
    //   'object_id': 5678,
    //   'object_type': 'ADSET',
    //   'trigger_type': 'STATS_CHANGE',
    //   'trigger_field': 'COST_PER_LINK_CLICK',
    //   'current_value': '15.8'
    // }

    const ruleId = webhookData.rule_id;
    const objectId = webhookData.object_id;
    const triggerType = webhookData.trigger_type;
    const currentValue = this.parseWebhookValue(webhookData.current_value);

    // 1. 로컬 규칙 실행 로그 업데이트
    await this.updateRuleExecutionLog(ruleId, {
      objectId,
      triggerType,
      currentValue,
      triggeredAt: new Date()
    });

    // 2. 후속 액션 처리 (필요한 경우)
    await this.handleWebhookTriggeredAction(ruleId, objectId, triggerType);

    // 3. 실시간 대시보드 업데이트
    await this.notifyRealTimeDashboard(ruleId, webhookData);
  }

  private parseWebhookValue(valueString: string): any {
    // current_value는 JSON 인코딩 문자열
    try {
      return JSON.parse(valueString);
    } catch {
      return valueString; // 단순 문자열인 경우
    }
  }
}
```

#### 규칙 학습 및 최적화 시스템
```typescript
interface MetaRuleLearningEngine {
  ruleId: string;
  executionHistory: RuleExecutionHistory[];
  performanceMetrics: PerformanceMetrics;
  optimizationRecommendations: OptimizationRecommendation[];
}

class MetaAdRuleLearningSystem {
  async optimizeRuleParameters(ruleId: string): Promise<OptimizationResult> {
    // 1. Meta API를 통한 규칙 실행 이력 수집
    const executionHistory = await this.getMetaRuleExecutionHistory(ruleId, 90);

    // 2. 성과 분석 (ROI, 실행 성공률, 목표 달성률)
    const performanceAnalysis = await this.analyzeRulePerformance(executionHistory);

    // 3. change_spec 최적화
    const optimizedChangeSpecs = await this.optimizeChangeSpecs(performanceAnalysis);

    // 4. 실행 빈도 최적화 (execution_count_limit, action_frequency)
    const optimizedFrequency = await this.optimizeExecutionFrequency(performanceAnalysis);

    // 5. 필터 조건 최적화
    const optimizedFilters = await this.optimizeFilterConditions(performanceAnalysis);

    return {
      currentParameters: performanceAnalysis.currentParams,
      optimizedChangeSpecs: optimizedChangeSpecs,
      optimizedFrequency: optimizedFrequency,
      optimizedFilters: optimizedFilters,
      expectedImprovement: this.calculateExpectedImprovement(performanceAnalysis)
    };
  }

  async optimizeChangeSpecs(analysis: PerformanceAnalysis): Promise<OptimizedChangeSpec[]> {
    // target_field 기반 동적 조정 최적화
    const recommendations = [];

    for (const changeSpec of analysis.changeSpecs) {
      if (changeSpec.target_field) {
        // 목표값(amount) 최적화
        const optimalTargetValue = await this.calculateOptimalTargetValue(
          changeSpec.target_field,
          analysis.historicalPerformance
        );

        // limit 범위 최적화
        const optimalLimits = await this.calculateOptimalLimits(
          changeSpec.target_field,
          analysis.riskTolerance
        );

        recommendations.push({
          field: changeSpec.target_field,
          currentAmount: changeSpec.amount,
          optimizedAmount: optimalTargetValue,
          currentLimits: changeSpec.limit,
          optimizedLimits: optimalLimits,
          expectedImprovement: this.calculateFieldImprovement(changeSpec, optimalTargetValue)
        });
      }
    }

    return recommendations;
  }

  async optimizeExecutionFrequency(analysis: PerformanceAnalysis): Promise<FrequencyOptimization> {
    // execution_count_limit 최적화
    const optimalCountLimit = this.calculateOptimalExecutionCount(
      analysis.successRate,
      analysis.diminishingReturns
    );

    // action_frequency 최적화 (분 단위)
    const optimalFrequency = this.calculateOptimalActionFrequency(
      analysis.marketDynamics,
      analysis.performanceVolatility
    );

    return {
      currentCountLimit: analysis.currentCountLimit,
      optimizedCountLimit: optimalCountLimit,
      currentFrequency: analysis.currentFrequency,
      optimizedFrequency: optimalFrequency,
      reasoning: {
        countLimitReason: this.explainCountLimitOptimization(optimalCountLimit),
        frequencyReason: this.explainFrequencyOptimization(optimalFrequency)
      }
    };
  }

  private async getMetaRuleExecutionHistory(ruleId: string, days: number): Promise<RuleExecutionHistory[]> {
    // Meta API에서 규칙 실행 이력 조회 (실제 API 엔드포인트는 문서에서 확인)
    const response = await fetch(`https://graph.facebook.com/${this.apiVersion}/${this.adAccountId}/adrules_library/${ruleId}/execution_history`, {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${this.accessToken}`
      },
      params: {
        since: new Date(Date.now() - days * 24 * 60 * 60 * 1000).toISOString(),
        limit: 1000
      }
    });

    return response.json();
  }
}
```

#### 고급 스케줄링 시스템 (Enhanced MetaScheduleManager)
```typescript
interface ComplexCustomSchedule extends CustomScheduleEntry {
  scheduleId?: string;
  priority?: number;
  timeZoneOverride?: string;
  condition?: 'AND' | 'OR'; // 복수 스케줄 조합 방식
}

class EnhancedMetaScheduleManager extends MetaScheduleManager {
  private complexScheduleHandlers: Map<string, ComplexScheduleHandler> = new Map();

  async createComplexCustomSchedule(rule: MetaAdRuleConfig, schedules: ComplexCustomSchedule[]): Promise<void> {
    // 복합 스케줄 처리: 주중과 주말 다른 실행 패턴
    const scheduleGroups = this.groupSchedulesByPattern(schedules);

    for (const [groupId, group] of scheduleGroups) {
      const handler = this.createComplexScheduleHandler(rule, group);
      this.complexScheduleHandlers.set(`${rule.name}_${groupId}`, handler);
    }
  }

  private createComplexScheduleHandler(rule: MetaAdRuleConfig, schedules: ComplexCustomSchedule[]): ComplexScheduleHandler {
    // 예시: 주중 매일 + 주말 특정 시간대
    return {
      weekdaySchedules: schedules.filter(s => s.days && s.days.some(d => d >= 1 && d <= 5)),
      weekendSchedules: schedules.filter(s => s.days && s.days.some(d => d === 0 || d === 6)),
      timeRangeSchedules: schedules.filter(s => s.start_minute && s.end_minute),
      exactTimeSchedules: schedules.filter(s => s.start_minute && !s.end_minute)
    };
  }

  async createTimeRangeExecution(rule: MetaAdRuleConfig, schedule: ComplexCustomSchedule): Promise<void> {
    // 시간 범위 기반 실행 (예: 오후 12시~1시, 30분 간격)
    if (!schedule.start_minute || !schedule.end_minute) return;

    const startHour = Math.floor(schedule.start_minute / 60);
    const startMin = schedule.start_minute % 60;
    const endHour = Math.floor(schedule.end_minute / 60);
    const endMin = schedule.end_minute % 60;

    // 30분 간격으로 시간 범위 내 모든 실행 시점 생성
    const executionTimes = this.generateTimeRangeExecutions(startHour, startMin, endHour, endMin);

    for (const execTime of executionTimes) {
      const cronExpression = this.buildCronForTimeRange(execTime, schedule.days);
      await this.scheduleTimeRangeJob(rule, cronExpression, schedule);
    }
  }

  private generateTimeRangeExecutions(startH: number, startM: number, endH: number, endM: number): ExecutionTime[] {
    const times: ExecutionTime[] = [];

    for (let h = startH; h <= endH; h++) {
      const minStart = (h === startH) ? startM : 0;
      const minEnd = (h === endH) ? endM : 59;

      // 30분 간격으로 실행 시점 생성
      for (let m = minStart; m <= minEnd; m += 30) {
        if (m <= minEnd) {
          times.push({ hour: h, minute: m });
        }
      }
    }

    return times;
  }

  async createWeekdayWeekendDifferentialSchedule(rule: MetaAdRuleConfig): Promise<void> {
    // 실무 예시: 주중 매일 vs 주말 특정 시간대
    const weekdaySchedule: ComplexCustomSchedule = {
      days: [1, 2, 3, 4, 5], // 월-금
      scheduleId: 'weekday_daily',
      priority: 1
    };

    const weekendSchedule: ComplexCustomSchedule = {
      start_minute: 720, // 오후 12시
      end_minute: 780,   // 오후 1시
      days: [0, 6],      // 일, 토
      scheduleId: 'weekend_lunch',
      priority: 2
    };

    await this.createComplexCustomSchedule(rule, [weekdaySchedule, weekendSchedule]);
  }
}

// 실무 적용 예시들
interface ScheduleExample {
  name: string;
  description: string;
  schedule_spec: any;
}

const advancedScheduleExamples: ScheduleExample[] = [
  {
    name: "매일 오전 10시 정확 실행",
    description: "days 생략시 매일 자동 적용",
    schedule_spec: {
      "schedule_type": "CUSTOM",
      "schedule": [{ "start_minute": 600 }]
    }
  },
  {
    name: "주말에만 30분마다 실행",
    description: "start_minute 생략시 SEMI_HOURLY 적용",
    schedule_spec: {
      "schedule_type": "CUSTOM",
      "schedule": [{ "days": [0, 6] }]
    }
  },
  {
    name: "수요일 오전 2시에만 실행",
    description: "특정 요일 특정 시간 실행",
    schedule_spec: {
      "schedule_type": "CUSTOM",
      "schedule": [{ "start_minute": 120, "days": [3] }]
    }
  },
  {
    name: "주중 매일 + 주말 점심시간",
    description: "복합 스케줄: OR 조건으로 독립 실행",
    schedule_spec: {
      "schedule_type": "CUSTOM",
      "schedule": [
        { "days": [1, 2, 3, 4, 5] },
        { "start_minute": 720, "end_minute": 780, "days": [0, 6] }
      ]
    }
  }
];
```

#### 고급 필터 엔진 (Advanced Meta Filter Engine)
```typescript
interface PrefixedInsightField {
  objectLevelPrefix?: 'ad' | 'adset' | 'campaign';
  attributionWindowPrefix?: string;
  timePresetPrefix?: string;
  fieldName: string;
}

interface AggregateField {
  function: 'aggregate';
  field: string;
  aggregationIds: string[];
}

interface FormulaField {
  expression: string;
  fields: string[];
  constants: number[];
  operators: ('+' | '-' | '*' | '/')[];
}

class MetaAdvancedFilterEngine {
  private supportedObjectPrefixes = ['ad', 'adset', 'campaign'];
  private supportedAttributionWindows = [
    'account_default', 'default', 'inline', '1d_view', '7d_view', '28d_view',
    '1d_click', '7d_click', '28d_click', '1d_view_1d_click', '7d_view_1d_click',
    '28d_view_1d_click', '1d_view_7d_click', '7d_view_7d_click', '28d_view_7d_click',
    '7d_view_28d_click', '28d_view_28d_click'
  ];
  private supportedTimePresets = [
    'lifetime', 'today', 'last_2_days', 'last_3_days', 'last_7_days',
    'last_14_days', 'last_28_days', 'last_30_days', 'this_month',
    'this_week_mon_today', 'this_week_sun_today', 'yesterday',
    'last_2d', 'last_3d', 'last_7d', 'last_14d', 'last_28d', 'last_30d',
    'last_nd_14_8', 'last_nd_30_8', 'last_nd_60_8', 'last_nd_120_8',
    'last_nd_180_8', 'last_nd_lifetime_8', 'last_nd_60_29', 'last_nd_120_20',
    'last_nd_180_29', 'last_nd_lifetime_29'
  ];

  parsePrefixedField(fieldString: string): PrefixedInsightField | null {
    // 형식: {object_level_prefix?} {attribution_window_prefix?} {time_preset_prefix?} {field_name}
    const parts = fieldString.split('.');
    let objectLevelPrefix: string | undefined;
    let remainingField = fieldString;

    // 1. 객체 수준 프리픽스 확인
    if (parts.length > 1 && this.supportedObjectPrefixes.includes(parts[0])) {
      objectLevelPrefix = parts[0] as 'ad' | 'adset' | 'campaign';
      remainingField = parts.slice(1).join('.');
    }

    // 2. 기여 기간 및 시간 기본 설정 프리픽스 파싱
    const { attributionWindowPrefix, timePresetPrefix, fieldName } =
      this.parseAttributionAndTimePresets(remainingField);

    return {
      objectLevelPrefix: objectLevelPrefix as any,
      attributionWindowPrefix,
      timePresetPrefix,
      fieldName
    };
  }

  private parseAttributionAndTimePresets(field: string): {
    attributionWindowPrefix?: string;
    timePresetPrefix?: string;
    fieldName: string;
  } {
    let attributionWindowPrefix: string | undefined;
    let timePresetPrefix: string | undefined;
    let fieldName = field;

    // 기여 기간 프리픽스 확인
    for (const prefix of this.supportedAttributionWindows) {
      if (field.startsWith(prefix + ':')) {
        attributionWindowPrefix = prefix;
        fieldName = field.substring(prefix.length + 1);
        break;
      }
    }

    // 시간 기본 설정 프리픽스 확인
    for (const prefix of this.supportedTimePresets) {
      if (fieldName.startsWith(prefix + '_')) {
        timePresetPrefix = prefix;
        fieldName = fieldName.substring(prefix.length + 1);
        break;
      }
    }

    return { attributionWindowPrefix, timePresetPrefix, fieldName };
  }

  parseAggregateField(fieldString: string): AggregateField | null {
    // 형식: aggregate({field})
    const aggregateMatch = fieldString.match(/^aggregate\((.+)\)$/);
    if (!aggregateMatch) return null;

    const innerField = aggregateMatch[1];
    const parsedField = this.parsePrefixedField(innerField);

    return {
      function: 'aggregate',
      field: parsedField ? this.reconstructFieldString(parsedField) : innerField,
      aggregationIds: [] // 별도로 aggregation_id 필터에서 설정
    };
  }

  parseFormulaField(fieldString: string): FormulaField | null {
    // 형식: {field_or_constant_1} {+|-|*|/} {field_or_constant_2} ...
    const tokens = fieldString.split(/\s+/);
    if (tokens.length < 3 || tokens.length % 2 === 0) return null;

    const fields: string[] = [];
    const constants: number[] = [];
    const operators: ('+' | '-' | '*' | '/')[] = [];

    for (let i = 0; i < tokens.length; i++) {
      if (i % 2 === 0) {
        // 필드 또는 상수
        const token = tokens[i];
        const numValue = parseFloat(token);

        if (isNaN(numValue)) {
          fields.push(token);
        } else {
          constants.push(numValue);
        }
      } else {
        // 연산자
        const operator = tokens[i] as '+' | '-' | '*' | '/';
        if (['+', '-', '*', '/'].includes(operator)) {
          operators.push(operator);
        } else {
          return null; // 잘못된 연산자
        }
      }
    }

    // 상수가 아닌 필드는 최대 6개까지
    if (fields.length > 6) return null;

    return {
      expression: fieldString,
      fields,
      constants,
      operators
    };
  }

  private reconstructFieldString(parsed: PrefixedInsightField): string {
    let result = '';

    if (parsed.objectLevelPrefix) {
      result += parsed.objectLevelPrefix + '.';
    }

    if (parsed.attributionWindowPrefix) {
      result += parsed.attributionWindowPrefix + ':';
    }

    if (parsed.timePresetPrefix) {
      result += parsed.timePresetPrefix + '_';
    }

    result += parsed.fieldName;
    return result;
  }

  validateAdvancedFilter(filter: any): { isValid: boolean; type: 'prefixed' | 'aggregate' | 'formula' | 'standard'; error?: string } {
    const field = filter.field;

    // 집계 필드 확인
    if (field.startsWith('aggregate(')) {
      const aggregateField = this.parseAggregateField(field);
      if (!aggregateField) {
        return { isValid: false, type: 'aggregate', error: 'Invalid aggregate field format' };
      }
      return { isValid: true, type: 'aggregate' };
    }

    // 공식 필드 확인 (공백 포함 여부로 판단)
    if (field.includes(' ') && /[+\-*/]/.test(field)) {
      const formulaField = this.parseFormulaField(field);
      if (!formulaField) {
        return { isValid: false, type: 'formula', error: 'Invalid formula field format' };
      }
      return { isValid: true, type: 'formula' };
    }

    // 프리픽스 필드 확인
    const prefixedField = this.parsePrefixedField(field);
    if (prefixedField && (prefixedField.objectLevelPrefix || prefixedField.attributionWindowPrefix || prefixedField.timePresetPrefix)) {
      return { isValid: true, type: 'prefixed' };
    }

    // 표준 필드
    return { isValid: true, type: 'standard' };
  }

  // 실무 고급 필터 예시
  generateAdvancedFilterExamples(): any[] {
    return [
      {
        field: "adset.yesterday_spent",
        operator: "GREATER_THAN",
        value: 1000,
        description: "어제 광고 세트 수준에서 지출한 총금액"
      },
      {
        field: "campaign.28d_view_1d_click:lifetime_results",
        operator: "GREATER_THAN",
        value: 50,
        description: "전체 기간에 걸쳐 광고 캠페인 수준의 총 결과 (기여: 조회 28일, 클릭 1일)"
      },
      {
        field: "aggregate(reach)",
        operator: "GREATER_THAN",
        value: 10000,
        description: "여러 광고 객체의 집계된 도달 범위"
      },
      {
        field: "today_spent / adset.daily_budget",
        operator: "GREATER_THAN",
        value: 0.8,
        description: "일일 지출 비율 (공식 필드)"
      },
      {
        field: "0.8 * cpc + 0.2 * cpm",
        operator: "LESS_THAN",
        value: 5.0,
        description: "가중 평균 비용 지표 (공식 필드)"
      }
    ];
  }
}
```

#### 예산 조정 자동화 시스템 (Budget Rebalancing System)
```typescript
interface RebalanceSpec {
  type: 'EVEN' | 'PROPORTIONAL' | 'NO_PAUSE_PROPORTIONAL' | 'MATCHED_ONLY_PROPORTIONAL' | 'INVERSE_PROPORTIONAL';
  target_field?: string;
  target_count?: number;
  is_cross_campaign?: boolean;
  is_inverse?: boolean;
}

interface BudgetRebalanceResult {
  donors: RebalanceDonor[];
  recipients: RebalanceRecipient[];
  totalTransferred: number;
  rebalanceType: string;
  executionSummary: string;
}

interface RebalanceDonor {
  objectId: string;
  objectType: 'ADSET' | 'CAMPAIGN';
  currentBudget: number;
  donatedAmount: number;
  wasPaused: boolean;
  performanceScore: number;
}

interface RebalanceRecipient {
  objectId: string;
  objectType: 'ADSET' | 'CAMPAIGN';
  currentBudget: number;
  receivedAmount: number;
  newBudget: number;
  performanceScore: number;
  allocationPercentage: number;
}

class MetaBudgetRebalancer {
  async executeRebalance(rule: MetaAdRuleConfig, rebalanceSpec: RebalanceSpec): Promise<BudgetRebalanceResult> {
    // 1. 평가 통과 객체들 (기부자들) 식별
    const donors = await this.identifyDonors(rule);

    // 2. 수혜자들 결정 (rebalance_spec.type에 따라)
    const recipients = await this.identifyRecipients(rule, rebalanceSpec, donors);

    // 3. 예산 분배 계산
    const rebalanceCalculation = await this.calculateRebalanceAmounts(
      donors, recipients, rebalanceSpec
    );

    // 4. 실제 예산 조정 실행
    const executionResult = await this.executeRebalanceActions(rebalanceCalculation);

    return executionResult;
  }

  private async identifyDonors(rule: MetaAdRuleConfig): Promise<RebalanceDonor[]> {
    // 규칙의 evaluation_spec 필터를 통과하는 모든 객체들
    const matchingObjects = await this.evaluateRuleFilters(rule.evaluation_spec.filters);

    const donors: RebalanceDonor[] = [];
    for (const obj of matchingObjects) {
      const budget = await this.getCurrentBudget(obj.id, obj.entity_type);
      const performanceScore = await this.calculatePerformanceScore(obj.id, rule);

      donors.push({
        objectId: obj.id,
        objectType: obj.entity_type,
        currentBudget: budget,
        donatedAmount: 0, // 계산 후 설정
        wasPaused: false,
        performanceScore
      });
    }

    return donors;
  }

  private async identifyRecipients(rule: MetaAdRuleConfig, spec: RebalanceSpec, donors: RebalanceDonor[]): Promise<RebalanceRecipient[]> {
    switch (spec.type) {
      case 'EVEN':
      case 'PROPORTIONAL':
        // 평가 통과하지 않은 객체들이 수혜자
        return this.identifyNonMatchingRecipients(rule, spec);

      case 'NO_PAUSE_PROPORTIONAL':
        // 모든 객체를 함께 검토하여 성과 순위 매김
        return this.identifyAllObjectsAsRecipients(rule, spec, donors);

      case 'MATCHED_ONLY_PROPORTIONAL':
        // 기부자들 자신이 수혜자가 됨 (성과 기반 재분배)
        return this.convertDonorsToRecipients(donors, spec);

      default:
        throw new Error(`Unsupported rebalance type: ${spec.type}`);
    }
  }

  private async calculateRebalanceAmounts(
    donors: RebalanceDonor[],
    recipients: RebalanceRecipient[],
    spec: RebalanceSpec
  ): Promise<BudgetRebalanceCalculation> {

    // 1. 일일 예산과 총 예산 분리
    const { dailyBudgetDonors, lifetimeBudgetDonors } = this.separateBudgetTypes(donors);

    // 2. 각 유형별로 분배 계산
    const dailyRebalance = await this.calculateTypeSpecificRebalance(
      dailyBudgetDonors, recipients.filter(r => r.objectType === 'ADSET'), spec, 'DAILY'
    );

    const lifetimeRebalance = await this.calculateTypeSpecificRebalance(
      lifetimeBudgetDonors, recipients.filter(r => r.objectType === 'ADSET'), spec, 'LIFETIME'
    );

    return this.combineRebalanceCalculations(dailyRebalance, lifetimeRebalance);
  }

  private async calculateProportionalDistribution(
    totalBudgetPool: number,
    recipients: RebalanceRecipient[],
    spec: RebalanceSpec
  ): Promise<void> {
    if (!spec.target_field) {
      throw new Error('target_field is required for proportional distribution');
    }

    // 1. 각 수혜자의 target_field 값 조회
    for (const recipient of recipients) {
      const fieldValue = await this.getFieldValue(recipient.objectId, spec.target_field);
      recipient.performanceScore = spec.is_inverse ? (1 / fieldValue) : fieldValue;
    }

    // 2. target_count 적용 (상위 K명만 선택)
    let selectedRecipients = recipients;
    if (spec.target_count && spec.target_count < recipients.length) {
      selectedRecipients = recipients
        .sort((a, b) => b.performanceScore - a.performanceScore)
        .slice(0, spec.target_count);
    }

    // 3. 비례적 분배 계산
    const totalPerformanceScore = selectedRecipients.reduce((sum, r) => sum + r.performanceScore, 0);

    for (const recipient of selectedRecipients) {
      recipient.allocationPercentage = recipient.performanceScore / totalPerformanceScore;
      recipient.receivedAmount = totalBudgetPool * recipient.allocationPercentage;
      recipient.newBudget = recipient.currentBudget + recipient.receivedAmount;
    }
  }

  private async handleCrossCampaignRebalance(spec: RebalanceSpec, donors: RebalanceDonor[], recipients: RebalanceRecipient[]): Promise<void> {
    if (!spec.is_cross_campaign) {
      // 캠페인 내에서만 예산 이동
      const campaignGroups = this.groupByCampaign([...donors, ...recipients]);

      for (const [campaignId, objects] of campaignGroups) {
        const campaignDonors = objects.filter(o => donors.includes(o as any)) as RebalanceDonor[];
        const campaignRecipients = objects.filter(o => recipients.includes(o as any)) as RebalanceRecipient[];

        await this.rebalanceWithinCampaign(campaignDonors, campaignRecipients, spec);
      }
    } else {
      // 캠페인 간 예산 이동 허용
      await this.rebalanceAcrossCampaigns(donors, recipients, spec);
    }
  }

  // 실무 rebalance_spec 예시들
  generateRebalanceExamples(): any[] {
    return [
      {
        name: "균등 분배 (EVEN)",
        description: "성과 낮은 광고 세트 일시정지, 나머지에 균등 분배",
        rebalance_spec: {
          type: "EVEN"
        }
      },
      {
        name: "성과 비례 분배 (PROPORTIONAL)",
        description: "CPA 기준 상위 10개 광고 세트에 비례 분배",
        rebalance_spec: {
          type: "PROPORTIONAL",
          target_field: "cost_per_mobile_app_install",
          target_count: 10,
          is_inverse: true
        }
      },
      {
        name: "일시정지 없는 비례 분배 (NO_PAUSE_PROPORTIONAL)",
        description: "일시정지 없이 성과 기반 예산 재분배",
        rebalance_spec: {
          type: "NO_PAUSE_PROPORTIONAL",
          target_field: "video_view"
        }
      },
      {
        name: "매칭된 객체만 분배 (MATCHED_ONLY_PROPORTIONAL)",
        description: "필터 통과 객체들 간에만 성과 비례 재분배",
        rebalance_spec: {
          type: "MATCHED_ONLY_PROPORTIONAL",
          target_field: "video_view"
        }
      },
      {
        name: "캠페인 간 예산 이동",
        description: "캠페인 경계를 넘나드는 예산 재분배",
        rebalance_spec: {
          type: "PROPORTIONAL",
          target_field: "cost_per_mobile_app_install",
          target_count: 10,
          is_cross_campaign: true,
          is_inverse: true
        }
      }
    ];
  }
}
```

#### ROAS 최적화 전용 모듈 (ROAS Optimization Module)
```typescript
interface ROASRuleConfig {
  ruleId: string;
  targetROAS: number;
  attributionWindow: string;
  timePreset: string;
  minimumMaturityHours: number;
  toleranceRange: [number, number]; // [min, max] 허용 범위
  roasType: 'mobile_app_purchase_roas' | 'website_purchase_roas';
}

interface ROASOptimizationResult {
  currentROAS: number;
  targetROAS: number;
  adjustmentNeeded: boolean;
  recommendedBidChange: number;
  recommendedBudgetChange: number;
  maturityStatus: 'mature' | 'immature';
  confidenceLevel: number;
}

class MetaROASOptimizer {
  private supportedROASFields = ['mobile_app_purchase_roas', 'website_purchase_roas'];
  private supportedAttributionWindows = [
    '1D_CLICK', '7D_CLICK', '28D_CLICK',
    '1D_VIEW', '7D_VIEW', '28D_VIEW',
    '1D_VIEW_1D_CLICK', '7D_VIEW_1D_CLICK', '28D_VIEW_1D_CLICK',
    '1D_VIEW_7D_CLICK', '7D_VIEW_7D_CLICK', '28D_VIEW_7D_CLICK',
    '7D_VIEW_28D_CLICK', '28D_VIEW_28D_CLICK'
  ];

  async optimizeROASRule(config: ROASRuleConfig, adsetIds: string[]): Promise<ROASOptimizationResult[]> {
    const results: ROASOptimizationResult[] = [];

    for (const adsetId of adsetIds) {
      // 1. 데이터 성숙도 확인
      const maturityStatus = await this.checkDataMaturity(adsetId, config);

      if (maturityStatus === 'immature') {
        results.push(this.createImmatureResult(adsetId, config));
        continue;
      }

      // 2. 현재 ROAS 계산
      const currentROAS = await this.calculateCurrentROAS(adsetId, config);

      // 3. 목표 대비 분석
      const optimizationResult = await this.analyzeROASPerformance(
        adsetId, currentROAS, config
      );

      results.push(optimizationResult);
    }

    return results;
  }

  private async checkDataMaturity(adsetId: string, config: ROASRuleConfig): Promise<'mature' | 'immature'> {
    // 1. 생성 후 경과 시간 확인
    const adsetInfo = await this.getAdsetCreationInfo(adsetId);
    const hoursSinceCreation = (Date.now() - adsetInfo.created_time.getTime()) / (1000 * 60 * 60);

    if (hoursSinceCreation < config.minimumMaturityHours) {
      return 'immature';
    }

    // 2. 기여 기간에 따른 추가 성숙도 확인
    const attributionDays = this.extractAttributionDays(config.attributionWindow);
    const requiredMaturityHours = attributionDays * 24 + 24; // 기여 기간 + 1일 버퍼

    return hoursSinceCreation >= requiredMaturityHours ? 'mature' : 'immature';
  }

  private async calculateCurrentROAS(adsetId: string, config: ROASRuleConfig): Promise<number> {
    // 성숙한 데이터만 사용하여 ROAS 계산
    const insights = await this.getAdsetInsights(adsetId, {
      fields: [config.roasType, 'spent'],
      time_preset: config.timePreset,
      attribution_window: config.attributionWindow
    });

    const roasValue = insights[config.roasType];
    return roasValue || 0;
  }

  private async analyzeROASPerformance(
    adsetId: string,
    currentROAS: number,
    config: ROASRuleConfig
  ): Promise<ROASOptimizationResult> {

    const [minTolerance, maxTolerance] = config.toleranceRange;
    const isWithinTolerance = currentROAS >= minTolerance && currentROAS <= maxTolerance;

    let recommendedBidChange = 0;
    let recommendedBudgetChange = 0;

    if (!isWithinTolerance) {
      // target_field 기반 동적 조정 계산
      const targetROAS = config.targetROAS;
      const roasDifference = targetROAS - currentROAS;
      const adjustmentRatio = roasDifference / currentROAS;

      // ROAS가 목표보다 낮으면 입찰가 상향, 높으면 하향
      recommendedBidChange = this.calculateBidAdjustment(adjustmentRatio);
      recommendedBudgetChange = this.calculateBudgetAdjustment(adjustmentRatio);
    }

    return {
      currentROAS,
      targetROAS: config.targetROAS,
      adjustmentNeeded: !isWithinTolerance,
      recommendedBidChange,
      recommendedBudgetChange,
      maturityStatus: 'mature',
      confidenceLevel: this.calculateConfidenceLevel(currentROAS, config)
    };
  }

  private calculateBidAdjustment(adjustmentRatio: number): number {
    // ROAS 차이에 비례한 입찰가 조정
    // 예: ROAS가 20% 부족하면 입찰가 15% 증가
    const bidAdjustmentFactor = 0.75; // 조정 강도
    return adjustmentRatio * bidAdjustmentFactor;
  }

  private calculateBudgetAdjustment(adjustmentRatio: number): number {
    // ROAS 차이에 비례한 예산 조정
    // 예: ROAS가 좋으면 예산 증가, 나쁘면 예산 감소
    const budgetAdjustmentFactor = 0.5; // 예산 조정은 더 보수적
    return -adjustmentRatio * budgetAdjustmentFactor; // ROAS 높으면 예산 증가
  }

  private extractAttributionDays(attributionWindow: string): number {
    // 기여 기간에서 최대 일수 추출
    const clickMatch = attributionWindow.match(/(\d+)d_click/i);
    const viewMatch = attributionWindow.match(/(\d+)d_view/i);

    const clickDays = clickMatch ? parseInt(clickMatch[1]) : 0;
    const viewDays = viewMatch ? parseInt(viewMatch[1]) : 0;

    return Math.max(clickDays, viewDays);
  }

  // 실무 ROAS 규칙 예시들
  generateROASRuleExamples(): any[] {
    return [
      {
        name: "7일 클릭 웹사이트 ROAS 예산 증가 규칙",
        description: "ROAS > 0.50 시 예산 20% 증가",
        rule: {
          schedule_spec: { schedule_type: "DAILY" },
          evaluation_spec: {
            evaluation_type: "SCHEDULE",
            filters: [
              { field: "id", value: [123], operator: "IN" },
              { field: "time_preset", value: "LAST_ND_14_8", operator: "EQUAL" },
              { field: "attribution_window", value: "7D_CLICK", operator: "EQUAL" },
              { field: "hours_since_creation", value: 192, operator: "GREATER_THAN" },
              { field: "website_purchase_roas", value: 0.50, operator: "GREATER_THAN" }
            ]
          },
          execution_spec: {
            execution_type: "CHANGE_BUDGET",
            execution_options: [{
              field: "change_spec",
              value: { amount: 20, unit: "PERCENTAGE" },
              operator: "EQUAL"
            }]
          }
        }
      },
      {
        name: "1일 조회 1일 클릭 모바일 앱 ROAS 입찰가 조정",
        description: "목표 ROAS 0.80 달성을 위한 동적 입찰가 조정",
        rule: {
          schedule_spec: { schedule_type: "DAILY" },
          evaluation_spec: {
            evaluation_type: "SCHEDULE",
            filters: [
              { field: "id", value: [123], operator: "IN" },
              { field: "time_preset", value: "LAST_7D", operator: "EQUAL" },
              { field: "attribution_window", value: "1D_VIEW_1D_CLICK", operator: "EQUAL" },
              { field: "hours_since_creation", value: 48, operator: "GREATER_THAN" },
              { field: "mobile_app_purchase_roas", value: [0.76, 0.84], operator: "NOT_IN_RANGE" }
            ]
          },
          execution_spec: {
            execution_type: "CHANGE_BID",
            execution_options: [{
              field: "change_spec",
              value: { amount: 0.80, target_field: "mobile_app_purchase_roas" },
              operator: "EQUAL"
            }]
          }
        }
      },
      {
        name: "28일 기여 기간 ROAS 최적화",
        description: "장기 기여 기간 고려한 성숙한 데이터 기반 최적화",
        config: {
          targetROAS: 1.2,
          attributionWindow: "28D_VIEW_28D_CLICK",
          timePreset: "LAST_ND_60_29", // 최근 60일 ~ 28일 전
          minimumMaturityHours: 720, // 30일
          toleranceRange: [1.14, 1.26], // ±5% 허용 범위
          roasType: "website_purchase_roas"
        }
      }
    ];
  }
}
```

#### 완전한 API 래퍼 시스템 (Complete API Wrapper System)
```typescript
interface MetaRulesAPIResponse<T> {
  data: T;
  success: boolean;
  error?: string;
  executionTime: number;
  rateLimit?: {
    remaining: number;
    resetTime: Date;
  };
}

interface RuleExecutionHistory {
  execution_time: string;
  rule_id: string;
  object_id: string;
  action: string;
  status: 'SUCCESS' | 'FAILED' | 'NO_CHANGE';
  details: any;
  rule_state_at_execution: any;
}

interface RulePreviewResult {
  matching_objects: Array<{
    id: string;
    entity_type: string;
    current_values: Record<string, any>;
    would_execute: boolean;
  }>;
  total_objects_evaluated: number;
  execution_preview: string;
}

class MetaRulesAPIClient {
  private baseUrl: string;
  private accessToken: string;
  private apiVersion: string;
  private rateLimiter: RateLimiter;

  constructor(accessToken: string, apiVersion: string = 'v19.0') {
    this.accessToken = accessToken;
    this.apiVersion = apiVersion;
    this.baseUrl = `https://graph.facebook.com/${apiVersion}`;
    this.rateLimiter = new RateLimiter({ maxRequests: 200, timeWindow: 3600000 });
  }

  // CRUD 작업들
  async createRule(adAccountId: string, ruleConfig: MetaAdRuleConfig): Promise<MetaRulesAPIResponse<{ id: string }>> {
    const startTime = Date.now();

    try {
      await this.rateLimiter.checkLimit();

      const response = await fetch(`${this.baseUrl}/${adAccountId}/adrules_library`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.accessToken}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          name: ruleConfig.name,
          schedule_spec: ruleConfig.schedule_spec,
          evaluation_spec: ruleConfig.evaluation_spec,
          execution_spec: ruleConfig.execution_spec
        })
      });

      const result = await response.json();
      const executionTime = Date.now() - startTime;

      if (result.error) {
        return {
          data: null as any,
          success: false,
          error: result.error.message,
          executionTime
        };
      }

      return {
        data: { id: result.id },
        success: true,
        executionTime,
        rateLimit: this.extractRateLimitInfo(response.headers)
      };
    } catch (error) {
      return {
        data: null as any,
        success: false,
        error: error.message,
        executionTime: Date.now() - startTime
      };
    }
  }

  async getRules(adAccountId: string, fields?: string[]): Promise<MetaRulesAPIResponse<any[]>> {
    const startTime = Date.now();

    try {
      await this.rateLimiter.checkLimit();

      const queryParams = new URLSearchParams({
        access_token: this.accessToken
      });

      if (fields && fields.length > 0) {
        queryParams.append('fields', fields.join(','));
      }

      const response = await fetch(`${this.baseUrl}/${adAccountId}/adrules_library?${queryParams}`);
      const result = await response.json();
      const executionTime = Date.now() - startTime;

      return {
        data: result.data || [],
        success: !result.error,
        error: result.error?.message,
        executionTime,
        rateLimit: this.extractRateLimitInfo(response.headers)
      };
    } catch (error) {
      return {
        data: [],
        success: false,
        error: error.message,
        executionTime: Date.now() - startTime
      };
    }
  }

  async getRule(ruleId: string, fields?: string[]): Promise<MetaRulesAPIResponse<any>> {
    const startTime = Date.now();

    try {
      await this.rateLimiter.checkLimit();

      const queryParams = new URLSearchParams({
        access_token: this.accessToken
      });

      if (fields && fields.length > 0) {
        queryParams.append('fields', fields.join(','));
      }

      const response = await fetch(`${this.baseUrl}/${ruleId}?${queryParams}`);
      const result = await response.json();
      const executionTime = Date.now() - startTime;

      return {
        data: result,
        success: !result.error,
        error: result.error?.message,
        executionTime,
        rateLimit: this.extractRateLimitInfo(response.headers)
      };
    } catch (error) {
      return {
        data: null as any,
        success: false,
        error: error.message,
        executionTime: Date.now() - startTime
      };
    }
  }

  async updateRule(ruleId: string, updateData: Partial<MetaAdRuleConfig>): Promise<MetaRulesAPIResponse<{ success: boolean }>> {
    const startTime = Date.now();

    try {
      await this.rateLimiter.checkLimit();

      const response = await fetch(`${this.baseUrl}/${ruleId}`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.accessToken}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(updateData)
      });

      const result = await response.json();
      const executionTime = Date.now() - startTime;

      return {
        data: { success: result.success || false },
        success: !result.error,
        error: result.error?.message,
        executionTime,
        rateLimit: this.extractRateLimitInfo(response.headers)
      };
    } catch (error) {
      return {
        data: { success: false },
        success: false,
        error: error.message,
        executionTime: Date.now() - startTime
      };
    }
  }

  async deleteRule(ruleId: string): Promise<MetaRulesAPIResponse<{ success: boolean }>> {
    const startTime = Date.now();

    try {
      await this.rateLimiter.checkLimit();

      const response = await fetch(`${this.baseUrl}/${ruleId}`, {
        method: 'DELETE',
        headers: {
          'Authorization': `Bearer ${this.accessToken}`
        }
      });

      const result = await response.json();
      const executionTime = Date.now() - startTime;

      return {
        data: { success: result.success || false },
        success: !result.error,
        error: result.error?.message,
        executionTime,
        rateLimit: this.extractRateLimitInfo(response.headers)
      };
    } catch (error) {
      return {
        data: { success: false },
        success: false,
        error: error.message,
        executionTime: Date.now() - startTime
      };
    }
  }

  // 실행 이력 조회
  async getRuleExecutionHistory(
    ruleId: string,
    filters?: { object_id?: string; action?: string; hide_no_changes?: boolean }
  ): Promise<MetaRulesAPIResponse<RuleExecutionHistory[]>> {
    const startTime = Date.now();

    try {
      await this.rateLimiter.checkLimit();

      const queryParams = new URLSearchParams({
        access_token: this.accessToken
      });

      if (filters) {
        Object.entries(filters).forEach(([key, value]) => {
          if (value !== undefined) {
            queryParams.append(key, value.toString());
          }
        });
      }

      const response = await fetch(`${this.baseUrl}/${ruleId}/history?${queryParams}`);
      const result = await response.json();
      const executionTime = Date.now() - startTime;

      return {
        data: result.data || [],
        success: !result.error,
        error: result.error?.message,
        executionTime,
        rateLimit: this.extractRateLimitInfo(response.headers)
      };
    } catch (error) {
      return {
        data: [],
        success: false,
        error: error.message,
        executionTime: Date.now() - startTime
      };
    }
  }

  // 계정 전체 실행 이력
  async getAccountExecutionHistory(
    adAccountId: string,
    filters?: { object_id?: string; action?: string; hide_no_changes?: boolean }
  ): Promise<MetaRulesAPIResponse<RuleExecutionHistory[]>> {
    const startTime = Date.now();

    try {
      await this.rateLimiter.checkLimit();

      const queryParams = new URLSearchParams({
        access_token: this.accessToken
      });

      if (filters) {
        Object.entries(filters).forEach(([key, value]) => {
          if (value !== undefined) {
            queryParams.append(key, value.toString());
          }
        });
      }

      const response = await fetch(`${this.baseUrl}/${adAccountId}/adrules_history?${queryParams}`);
      const result = await response.json();
      const executionTime = Date.now() - startTime;

      return {
        data: result.data || [],
        success: !result.error,
        error: result.error?.message,
        executionTime,
        rateLimit: this.extractRateLimitInfo(response.headers)
      };
    } catch (error) {
      return {
        data: [],
        success: false,
        error: error.message,
        executionTime: Date.now() - startTime
      };
    }
  }

  // 규칙 미리보기
  async previewRule(ruleId: string): Promise<MetaRulesAPIResponse<RulePreviewResult>> {
    const startTime = Date.now();

    try {
      await this.rateLimiter.checkLimit();

      const response = await fetch(`${this.baseUrl}/${ruleId}/preview`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.accessToken}`
        }
      });

      const result = await response.json();
      const executionTime = Date.now() - startTime;

      return {
        data: result,
        success: !result.error,
        error: result.error?.message,
        executionTime,
        rateLimit: this.extractRateLimitInfo(response.headers)
      };
    } catch (error) {
      return {
        data: null as any,
        success: false,
        error: error.message,
        executionTime: Date.now() - startTime
      };
    }
  }

  // 수동 규칙 실행
  async executeRule(ruleId: string): Promise<MetaRulesAPIResponse<{ execution_id: string }>> {
    const startTime = Date.now();

    try {
      await this.rateLimiter.checkLimit();

      const response = await fetch(`${this.baseUrl}/${ruleId}/execute`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.accessToken}`
        }
      });

      const result = await response.json();
      const executionTime = Date.now() - startTime;

      return {
        data: { execution_id: result.execution_id || 'unknown' },
        success: !result.error,
        error: result.error?.message,
        executionTime,
        rateLimit: this.extractRateLimitInfo(response.headers)
      };
    } catch (error) {
      return {
        data: { execution_id: 'failed' },
        success: false,
        error: error.message,
        executionTime: Date.now() - startTime
      };
    }
  }

  // 개체에 적용되는 규칙 조회
  async getObjectRules(
    objectId: string,
    passEvaluation?: boolean | 'previewed'
  ): Promise<MetaRulesAPIResponse<any[]>> {
    const startTime = Date.now();

    try {
      await this.rateLimiter.checkLimit();

      const queryParams = new URLSearchParams({
        access_token: this.accessToken
      });

      if (passEvaluation !== undefined) {
        queryParams.append('pass_evaluation', passEvaluation.toString());
      }

      const response = await fetch(`${this.baseUrl}/${objectId}/adrules_governed?${queryParams}`);
      const result = await response.json();
      const executionTime = Date.now() - startTime;

      return {
        data: result.data || [],
        success: !result.error,
        error: result.error?.message,
        executionTime,
        rateLimit: this.extractRateLimitInfo(response.headers)
      };
    } catch (error) {
      return {
        data: [],
        success: false,
        error: error.message,
        executionTime: Date.now() - startTime
      };
    }
  }

  private extractRateLimitInfo(headers: Headers): { remaining: number; resetTime: Date } | undefined {
    const remaining = headers.get('x-business-use-case-usage');
    const resetTime = headers.get('x-business-use-case-reset-time');

    if (remaining && resetTime) {
      return {
        remaining: parseInt(remaining),
        resetTime: new Date(parseInt(resetTime) * 1000)
      };
    }

    return undefined;
  }
}

// 속도 제한 관리
class RateLimiter {
  private requests: number[] = [];
  private maxRequests: number;
  private timeWindow: number;

  constructor(config: { maxRequests: number; timeWindow: number }) {
    this.maxRequests = config.maxRequests;
    this.timeWindow = config.timeWindow;
  }

  async checkLimit(): Promise<void> {
    const now = Date.now();

    // 시간 윈도우 밖의 요청들 제거
    this.requests = this.requests.filter(time => now - time < this.timeWindow);

    if (this.requests.length >= this.maxRequests) {
      const oldestRequest = Math.min(...this.requests);
      const waitTime = this.timeWindow - (now - oldestRequest);

      if (waitTime > 0) {
        await new Promise(resolve => setTimeout(resolve, waitTime));
      }
    }

    this.requests.push(now);
  }
}
```

### 플러그인 아키텍처

#### 모듈 시스템 설계
```typescript
interface PluginInterface {
  name: string;
  version: string;
  dependencies: string[];

  initialize(): Promise<void>;
  destroy(): Promise<void>;

  // 이벤트 훅
  onCampaignCreate?(campaign: Campaign): Promise<void>;
  onPerformanceUpdate?(metrics: Metrics): Promise<void>;
}

class PluginManager {
  plugins: Map<string, PluginInterface> = new Map();

  async loadPlugin(plugin: PluginInterface): Promise<void> {
    // 의존성 확인
    // 플러그인 등록
    // 이벤트 훅 연결
  }
}
```

#### 핵심 플러그인 모듈
- **Analytics Plugin**: 고급 데이터 분석 기능
- **Automation Plugin**: 자동화 룰 및 워크플로우
- **Ad Rules Engine Plugin**: 중앙 집중식 광고 규칙 관리 및 자동화 실행
- **Reporting Plugin**: 커스텀 리포트 생성
- **Notification Plugin**: 다양한 채널 알림 연동
- **Integration Plugin**: 외부 도구 연동 (CRM, 이메일 등)
- **MMM Plugin**: 마케팅 믹스 모델링 전용 분석 도구
- **Lift Studies Plugin**: 무작위 대조 실험 관리 및 분석
- **Split Test Plugin**: A/B 테스트 자동화 및 최적화 도구
- **Volume Management Plugin**: 광고 볼륨 모니터링 및 자동 최적화 도구

### 쿼리 최적화 엔진

#### 최적화 전략
```typescript
class QueryOptimizer {
  optimizeInsightsQuery(query: InsightsQuery): OptimizedQuery[] {
    // 13개월 제한 회피: 쿼리 분할
    if (this.exceedsTimeLimit(query)) {
      return this.splitByTimeRange(query);
    }

    // 복잡한 breakdown 최적화: 단계별 요청
    if (this.isComplexBreakdown(query)) {
      return this.optimizeBreakdowns(query);
    }

    // 배치 처리: 여러 요청 묶기
    return this.batchRequests([query]);
  }
}
```

### 보안 및 토큰 관리

#### 토큰 순환 시스템
```typescript
class TokenManager {
  async refreshAccessToken(): Promise<string> {
    // 만료 전 자동 갱신
    // 안전한 저장소에 보관
    // 로그 및 모니터링
  }

  async validateToken(token: string): Promise<boolean> {
    // 토큰 유효성 검증
    // 권한 범위 확인
  }
}
```

---

## 🎯 구현 우선순위

### Phase 1: 기반 인프라 (4주) - 2025년 Q4 시작
1. **Meta API 클라이언트** - OAuth 2.1 및 최신 인증 표준 적용
2. **Rate Limiter** - Redis 7.x 기반 적응형 요청 제한 시스템
3. **캐시 시스템** - Redis Stack + PostgreSQL 16 3단계 캐싱
4. **데이터베이스 설계** - PostgreSQL 16 + TimescaleDB 확장 (시계열 데이터)

### Phase 2: 핵심 기능 (6주) - 2026년 Q1
1. **Insights API 연동** - GraphQL + REST API 하이브리드 데이터 수집
2. **기본 대시보드** - Next.js 15 + React 19 실시간 모니터링
3. **캠페인 생성** - AI 지원 광고 생성 (OpenAI GPT-4o 통합)
4. **추적 시스템** - 서버사이드 추적 + GA4 연동
5. **광고 규칙 엔진 기본** - 스케줄 기반 자동화 및 기본 규칙 관리
6. **MMM 기본 연동** - Python 3.12 + Pandas 2.x 데이터 처리
7. **Lift Studies 기본 연동** - 통계 분석 엔진 (SciPy + NumPy)
8. **Split Test 기본 연동** - 베이지안 A/B 테스트 프레임워크
9. **광고 볼륨 모니터링** - WebSocket 실시간 알림 시스템

### Phase 3: 고급 기능 (8주) - 2026년 Q2
1. **광고 규칙 엔진 고급** - 트리거 기반 실시간 자동화 + 머신러닝 최적화
2. **AI 자동화 엔진** - LangChain + GPT-4o 룰 엔진
3. **고급 분석** - Apache Superset + DuckDB 고성능 분석
4. **플러그인 시스템** - 마이크로프론트엔드 + Module Federation
5. **전환 퍼널 분석** - 실시간 이벤트 스트리밍 (Apache Kafka)
6. **MMM 고급 분석** - MLflow + PyTorch 머신러닝 파이프라인
7. **Lift Studies 고급 기능** - 베이지안 통계 + 인과추론 (DoWhy)
8. **Split Test 고급 기능** - 멀티 armed bandit + 베이지안 최적화
9. **볼륨 관리 자동화** - 예측 모델링 + 자동 스케일링

### Phase 4: 최적화 및 확장 (4주) - 2026년 Q3
1. **성능 최적화** - Rust 기반 핫패스 최적화 + Edge Computing (Cloudflare Workers)
2. **멀티모달 AI 예측** - GPT-4o Vision + Claude 3.5 Sonnet 광고 크리에이티브 생성
3. **외부 연동** - Zapier/Make.com API + 2000+ 서비스 통합
4. **모바일 앱** - React Native 0.75 + Expo Router v4
5. **MMM 예산 최적화 AI** - 강화학습 (Ray RLlib) 기반 동적 배분
6. **통합 분석 대시보드** - 실시간 인사이트 + AI 추천 시스템
7. **엔터프라이즈 기능** - SSO, RBAC, 감사 로그, 규정 준수
8. **AI 에이전트 시스템** - 자율 광고 관리 + 다중 에이전트 협업

---

## 🚀 확장 계획

### 단기 확장 (6개월) - 2026년 Q4
- **다중 계정 관리**: 통합 대시보드 + 조직 계층 관리
- **팀 협업 기능**: 실시간 협업 (WebRTC) + 역할 기반 접근 제어
- **AI 리포팅**: GPT-4o 기반 자동 인사이트 생성 + 예측 분석
- **GraphQL API 제공**: 개발자 친화적 API + OpenAPI 3.1 문서화

### 중기 확장 (1년)
- **생성형 AI 통합**: GPT-4o, Claude 3.5 기반 광고 카피 자동 생성 및 최적화
- **크로스 플랫폼**: Google Ads, 네이버, TikTok Ads 등 연동
- **화이트라벨**: B2B SaaS 플랫폼으로 확장
- **모바일 네이티브**: iOS/Android 앱 개발 (React Native 또는 Flutter)

### 장기 비전 (2-3년)
- **글로벌 확장**: 다국가/다언어 지원 (AI 번역 통합)
- **엔터프라이즈**: 대기업 맞춤 솔루션
- **AI 생태계**: 서드파티 AI 모델 플러그인 마켓플레이스
- **차세대 AI 어시스턴트**: 멀티모달 AI 기반 광고 관리 (텍스트, 이미지, 영상 통합)

---

## 📊 성공 지표 (KPI)

### 기술적 지표
- **가용성**: 99.9% 업타임
- **응답시간**: API 응답 평균 200ms 이하
- **처리량**: 초당 1000+ API 호출 처리
- **정확성**: 데이터 정확도 99.95% 이상

### 비즈니스 지표
- **사용자 증가**: 월간 활성 사용자 20% 성장
- **기능 활용**: 자동화 기능 사용률 60% 이상
- **고객 만족**: NPS 스코어 70+ 달성
- **수익성**: 연간 반복 수익(ARR) 목표 달성

### 효율성 지표
- **광고 성과 개선**: ROAS 평균 20% 향상
- **시간 절약**: 광고 관리 시간 50% 단축
- **에러 감소**: 수동 실수로 인한 오류 80% 감소
- **인사이트 활용**: 데이터 기반 의사결정 증가

---

## 🛡️ 리스크 관리

### 기술적 리스크
- **API 변경**: Meta API 정책 변경 대응 계획
- **Rate Limiting**: 사용량 급증 시 대응 전략
- **데이터 정확성**: 실시간 검증 및 모니터링
- **보안**: 토큰 관리 및 데이터 보호

### 비즈니스 리스크
- **경쟁**: 차별화된 기능 및 UX 제공
- **규제**: 개인정보보호 및 광고 정책 준수
- **확장성**: 사용자 증가에 따른 인프라 확장
- **수익성**: 지속 가능한 비즈니스 모델

---

---

## 📈 MMM 데이터 컬럼 매핑

### 기본 데이터 구조
MMM API에서 반환되는 기본 컬럼 구조:

| 인덱스 | 컬럼명 | 설명 |
|--------|--------|------|
| 0 | account_id | 광고 계정 ID |
| 1 | campaign_id | 캠페인 ID |
| 2 | adset_id | 광고 세트 ID |
| 3 | date_start | 시작 날짜 |
| 4 | date_stop | 종료 날짜 |
| 5 | impressions | 노출 수 |
| 6 | spend | 지출 금액 (추산치) |
| 7 | country | 국가 |
| 8 | region | 지역 |
| 9 | dma | DMA (지정 시장 지역) |
| 10 | device_platform | 디바이스 플랫폼 |
| 11 | platform_position | 플랫폼 위치 |
| 12 | publisher_platform | 퍼블리셔 플랫폼 |
| 13 | creative_media_type | 크리에이티브 미디어 타입 |

### 데이터 활용 계획
- **지역별 분석**: country, region, dma를 활용한 지역별 성과 분석
- **디바이스 분석**: device_platform 기반 디바이스별 최적화
- **플랫폼 분석**: publisher_platform, platform_position 기반 노출 위치 최적화
- **크리에이티브 분석**: creative_media_type 기반 크리에이티브 성과 분석

---

## 🧪 분할 테스트 설계 가이드

### 테스트 변수별 설계 예시

**타겟팅 전략 테스트**
```json
{
  "name": "Audience Targeting Split Test",
  "type": "SPLIT_TEST",
  "cells": [
    {
      "name": "Lookalike Audience",
      "treatment_percentage": 50,
      "adsets": ["ADSET_ID_1"]
    },
    {
      "name": "Interest Targeting",
      "treatment_percentage": 50,
      "adsets": ["ADSET_ID_2"]
    }
  ]
}
```

**크리에이티브 효과 테스트**
```json
{
  "name": "Creative Format Split Test",
  "type": "SPLIT_TEST",
  "cells": [
    {
      "name": "Video Creative",
      "treatment_percentage": 33,
      "adsets": ["ADSET_ID_1"]
    },
    {
      "name": "Carousel Creative",
      "treatment_percentage": 33,
      "adsets": ["ADSET_ID_2"]
    },
    {
      "name": "Single Image Creative",
      "treatment_percentage": 34,
      "adsets": ["ADSET_ID_3"]
    }
  ]
}
```

**예산 전략 테스트**
```json
{
  "name": "Budget Strategy Split Test",
  "type": "SPLIT_TEST",
  "cells": [
    {
      "name": "High Budget Campaign",
      "treatment_percentage": 50,
      "campaigns": ["CAMPAIGN_ID_1"]
    },
    {
      "name": "Low Budget Campaign",
      "treatment_percentage": 50,
      "campaigns": ["CAMPAIGN_ID_2"]
    }
  ]
}
```

### 분석 결과 해석 가이드

**통계적 유의성 기준**
- **p-value < 0.05**: 통계적으로 유의한 차이 존재
- **신뢰구간**: 95% 신뢰구간이 0을 포함하지 않으면 유의한 효과
- **효과 크기**: 실질적으로 의미 있는 차이인지 평가 (예: CPA 10% 이상 개선)

**의사결정 매트릭스**

| 통계적 유의성 | 효과 크기 | 권장 액션 |
|-------------|---------|----------|
| 유의함 (p<0.05) | 큼 (>20% 개선) | 승자 셀로 즉시 확장 |
| 유의함 (p<0.05) | 중간 (10-20% 개선) | 추가 테스트 후 확장 |
| 유의함 (p<0.05) | 작음 (<10% 개선) | 비용 대비 효과 검토 |
| 유의하지 않음 (p≥0.05) | - | 추가 데이터 수집 또는 새로운 테스트 |

## 🧪 Lift Studies 실험 설계 가이드

### 목표별 실험 설계 예시

**전환 최적화 실험**
```json
{
  "name": "Conversion Optimization Study",
  "type": "LIFT",
  "cells": [
    {
      "name": "High Budget Test",
      "treatmentPercentage": 40,
      "controlPercentage": 20
    },
    {
      "name": "Low Budget Test",
      "treatmentPercentage": 30,
      "controlPercentage": 10
    }
  ],
  "objectives": [
    {
      "name": "Purchase Conversions",
      "type": "CONVERSIONS",
      "is_primary": true,
      "adspixels": [
        {
          "id": "PIXEL_ID",
          "event_names": ["fb_pixel_purchase"]
        }
      ]
    }
  ]
}
```

### 분석 데이터 활용

**지원되는 분석 차원** (2021년 7월 13일 이후 제한)
- **cell_id**: 실험군별 결과 분석 (필수)
- **age**: 연령대별 분석 (제한적)
- **gender**: 성별 분석 (제한적)
- **country**: 국가별 분석 (제한적)

### 핵심 성과 지표

**주요 측정 지표**
- `conversions_incremental`: 순수 증분 전환수
- `conversions_confidence`: 통계적 신뢰도 (0-1)
- `conversions_CPiC`: 증분 전환당 비용
- `conversions_incremental_share`: 증분 효과 비율

**통계적 검증**
- p-value < 0.05: 통계적 유의성 확보
- 신뢰구간: 95% 신뢰구간 내 효과 크기
- 검정력 분석: 효과 탐지 능력 평가

---

---

## 🔗 통합 활용 시나리오

### Volume Management + Split Test + MMM + Lift Studies 연계 전략

#### 0단계: Volume Management로 최적 환경 구축
- 광고 볼륨 현황 분석 및 제한 임계값 확인
- 비효율적 광고 정리를 통한 테스트 환경 최적화
- 볼륨 여유 확보로 테스트 확장성 보장

#### 1단계: Split Test로 후보 전략 식별
- 볼륨 제약 내에서 다양한 광고 전략 분할 테스트
- 통계적 유의성 기반 최적 전략 선별
- 승자 셀의 성과 지표 및 패턴 분석

#### 2단계: MMM으로 전체적 효과 측정
- Split Test 승자 전략을 MMM 데이터에 반영
- 다른 마케팅 채널과의 시너지 효과 분석
- 장기적 기여도 및 포화도 곡선 모델링

#### 3단계: Lift Studies로 인과관계 검증
- MMM에서 식별된 효과를 무작위 대조 실험으로 검증
- 증분 효과(Incremental Effect) 정확한 측정
- 실제 비즈니스 임팩트의 과학적 입증

#### 4단계: Volume Optimization으로 확장 실행
- 검증된 전략의 대규모 확장 시 볼륨 영향 예측
- 자동 볼륨 관리를 통한 안전한 확장 실행
- 성과 유지하면서 최대 볼륨 효율성 달성

#### 통합 분석 워크플로우
```typescript
interface IntegratedAnalysisWorkflow {
  volumeStatus: VolumeStatus;
  splitTestResults: SplitTestResults[];
  mmmAnalysis: MMMInsights;
  liftStudyResults: LiftInsights;

  integratedRecommendations: {
    volumeOptimization: VolumeOptimization;
    budgetOptimization: BudgetAllocation;
    strategyRefinement: StrategyUpdate;
    scalingPlan: ScalingStrategy;
    riskAssessment: RiskAnalysis;
  };
}

class IntegratedAnalysisEngine {
  async performComprehensiveAnalysis(
    volumeData: VolumeStatus,
    splitTests: SplitTestResults[],
    mmmData: MMMData[],
    liftStudies: LiftStudyResults[]
  ): Promise<IntegratedInsights> {
    // 0. 볼륨 최적화 기반 환경 분석
    const volumeOptimization = this.analyzeVolumeOptimization(volumeData);

    // 1. 각 방법론의 결과 정규화
    const normalizedResults = this.normalizeResults(splitTests, mmmData, liftStudies, volumeData);

    // 2. 교차 검증 및 일관성 확인
    const consistencyCheck = this.validateConsistency(normalizedResults);

    // 3. 통합 인사이트 생성 (볼륨 제약 고려)
    const insights = this.generateIntegratedInsights(normalizedResults, volumeOptimization);

    // 4. 볼륨 효율성을 고려한 액션 플랜 수립
    const actionPlan = this.createVolumeAwareActionPlan(insights, consistencyCheck, volumeOptimization);

    return { insights, actionPlan, consistencyCheck, volumeOptimization };
  }
}
```

### 실무 적용 예시

**시나리오: 전자상거래 광고 최적화 (볼륨 제약 포함)**

0. **Volume Analysis**: 광고 볼륨 현황 분석
   - 현재 볼륨: 페이지 제한의 85% 사용 중 (위험 수준)
   - 비효율 광고: 30개 zero_impression 광고 식별
   - 최적화 잠재력: 볼륨 20% 절약 가능

1. **Split Test**: 제품 카탈로그 vs 단일 제품 광고 비교 (볼륨 제약 고려)
   - 결과: 카탈로그 광고가 CPA 15% 낮음 (p<0.01)
   - 볼륨 효율성: 카탈로그 광고가 50% 적은 광고 수로 동일 성과

2. **MMM 분석**: 카탈로그 광고의 채널별 기여도 분석
   - 결과: Instagram에서 30% 더 높은 기여도, Facebook에서는 동등
   - 볼륨 영향: 채널별 광고 수 최적화 필요

3. **Lift Study**: 카탈로그 광고의 실제 증분 효과 검증
   - 결과: 실제 증분 전환 12%, CPiC $25 (기존 CPA $30 대비 개선)
   - 볼륨 검증: 대규모 확장 시에도 효과 유지 확인

4. **Volume Optimization**: 확장 전 볼륨 최적화
   - 비효율 광고 30개 정리로 20% 볼륨 확보
   - 카탈로그 광고 확장을 위한 여유 공간 확보

5. **통합 권장사항**:
   - 비효율 광고 정리 후 Instagram 예산 30% 증가
   - Facebook 볼륨은 효율적 광고로 재구성
   - 카탈로그 광고를 단계적으로 모든 제품군 확장
   - 볼륨 모니터링 시스템으로 지속적 최적화
   - 3개월 후 추가 Lift Study로 장기 효과 및 볼륨 효율성 검증

---

---

## 📋 광고 볼륨 관리 실무 가이드

### 볼륨 상태 모니터링 체크리스트

**일일 체크 항목**
- [ ] 현재 볼륨 사용률 확인 (80% 미만 유지 권장)
- [ ] 페이지별 볼륨 분포 분석
- [ ] 미래 제한 일정 확인
- [ ] 비효율 광고(zero_impression, learning_limited) 식별

**주간 체크 항목**
- [ ] 볼륨 트렌드 분석 및 예측
- [ ] 성과 기반 광고 우선순위 재조정
- [ ] 캠페인별 볼륨 효율성 평가
- [ ] 권장사항 시스템 결과 검토 및 적용

**월간 체크 항목**
- [ ] 전체 볼륨 전략 리뷰
- [ ] 페이지 간 볼륨 밸런싱 최적화
- [ ] 볼륨 관리 자동화 규칙 업데이트
- [ ] 미래 제한 대비 장기 계획 수립

### 볼륨 최적화 권장사항 활용

**Zero Impression 광고 처리**
1. 7일 이상 노출 없는 광고 식별
2. 과거 성과 데이터 분석
3. 비즈니스 중요도 평가
4. 안전한 광고부터 단계적 정리

**Learning Limited 광고 해결**
1. 학습 단계에 머물러 있는 광고 식별
2. 타겟팅 범위 확대 또는 예산 증가 검토
3. 유사한 광고 통합으로 학습 데이터 집중
4. 성과 기준 미달 시 일시정지 고려

**캠페인/광고 세트 통합 전략**
1. 유사한 타겟팅과 목표를 가진 광고 그룹화
2. 성과 데이터 기반 통합 우선순위 결정
3. 점진적 통합으로 성과 영향 최소화
4. 통합 후 성과 모니터링 강화

---

*문서 작성일: 2025년 10월 28일*
*버전: v1.6 - 광고 규칙 엔진 고급 기능 완전 통합*
*최종 업데이트: 2025년 10월 29일*
*작성자: AI Assistant*