# ë©”íƒ€ ê´‘ê³  í”Œë«í¼ ì¢…í•© ê¸°íšì„œ

## ğŸ“‹ í”„ë¡œì íŠ¸ ê°œìš”

### ëª©í‘œ
- Meta Marketing APIë¥¼ í™œìš©í•œ ê´‘ê³  ë°ì´í„° ë¶„ì„ ì›¹ì„œë¹„ìŠ¤
- ê´‘ê³  ìë™ í¬ìŠ¤íŒ… ë° ê´€ë¦¬ ì‹œìŠ¤í…œ
- ëª¨ë“ˆí™”/ì»´í¬ë„ŒíŠ¸ ê¸°ë°˜ì˜ í™•ì¥ ê°€ëŠ¥í•œ í”Œë«í¼

### í•µì‹¬ ê°€ì¹˜ ì œì•ˆ
- **ì‹¤ì‹œê°„ ì„±ê³¼ ë¶„ì„**: ê´‘ê³  ìº í˜ì¸ì˜ ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ ë° ì¸ì‚¬ì´íŠ¸ ì œê³µ
- **ìë™í™”**: ê´‘ê³  ìƒì„±, ìµœì í™”, ê´€ë¦¬ì˜ ìë™í™”ë¡œ íš¨ìœ¨ì„± ê·¹ëŒ€í™”
- **ëª¨ë“ˆì„±**: ê¸°ëŠ¥ì„ ì‰½ê²Œ ë¶™ì˜€ë‹¤ ë—„ ìˆ˜ ìˆëŠ” í”ŒëŸ¬ê·¸ì¸ ì•„í‚¤í…ì²˜
- **ì§€ëŠ¥í˜• ìµœì í™”**: AI ê¸°ë°˜ ì„±ê³¼ ì˜ˆì¸¡ ë° ìµœì í™” ì¶”ì²œ

### ì•„í‚¤í…ì²˜ ì² í•™
- **ì»´í¬ë„ŒíŠ¸ ê¸°ë°˜**: ë…ë¦½ì ì´ê³  ì¬ì‚¬ìš© ê°€ëŠ¥í•œ ëª¨ë“ˆ ì„¤ê³„
- **í™•ì¥ì„±**: ìˆ˜í‰ì  í™•ì¥ì´ ê°€ëŠ¥í•œ ë§ˆì´í¬ë¡œì„œë¹„ìŠ¤ ì§€í–¥
- **ì‹ ë¢°ì„±**: 99.9% ê°€ìš©ì„±ì„ ìœ„í•œ ì¥ì•  ë³µêµ¬ ì‹œìŠ¤í…œ
- **ì„±ëŠ¥**: ì‹¤ì‹œê°„ ì²˜ë¦¬ë¥¼ ìœ„í•œ ìµœì í™”ëœ ë°ì´í„° íŒŒì´í”„ë¼ì¸

---

## ğŸ” Meta API ë¶„ì„ ê²°ê³¼

### API ì œì•½ì‚¬í•­ ë° ëŒ€ì‘ ì „ëµ

#### Rate Limiting
- **app_id_util_pct**: ì•± ë ˆë²¨ ì‚¬ìš©ë¥  (0-100%)
- **acc_id_util_pct**: ê³„ì • ë ˆë²¨ ì‚¬ìš©ë¥  (0-100%)
- **ëŒ€ì‘**: ì ì‘í˜• Rate Limiting ì‹œìŠ¤í…œ êµ¬í˜„

#### ë°ì´í„° ì ‘ê·¼ ì œí•œ
- **13ê°œì›” ë£°**: reach/impression ë°ì´í„° 13ê°œì›” ì´ìƒ ì‹œ ì œí•œ
- **ì¿¼ë¦¬ ë³µì¡ë„**: ë³µì¡í•œ breakdown ì¡°í•© ì‹œ ì„±ëŠ¥ ì €í•˜
- **ëŒ€ì‘**: ì¿¼ë¦¬ ìµœì í™” ë° ë°°ì¹˜ ì²˜ë¦¬ ì‹œìŠ¤í…œ

#### ì—ëŸ¬ ì²˜ë¦¬ ì „ëµ
- **Error Code 100**: ì˜ëª»ëœ ë§¤ê°œë³€ìˆ˜ â†’ ê²€ì¦ ë¡œì§
- **Error Code 190**: ì•¡ì„¸ìŠ¤ í† í° ë¬¸ì œ â†’ í† í° ê°±ì‹ 
- **Error Code 613**: ìš”ì²­ í•œë„ ì´ˆê³¼ â†’ ëŒ€ê¸° ë° ì¬ì‹œë„
- **Error Code 80000**: ë‚´ë¶€ ì˜¤ë¥˜ â†’ ë°±ì˜¤í”„ ì¬ì‹œë„

### Meta Insights API í™œìš©

#### Breakdown ë°ì´í„° ë¶„ì„
- **ì¸êµ¬í†µê³„**: age, gender, country, region
- **ë””ë°”ì´ìŠ¤**: device_platform, platform_position, publisher_platform
- **ì‹œê°„**: hourly_stats_aggregated_by_advertiser_time_zone
- **í–‰ë™**: action_type, action_target_id, action_destination

#### ìµœì í™” ì „ëµ
- **í•„ë“œ ì„ íƒ**: í•„ìš”í•œ í•„ë“œë§Œ ìš”ì²­í•˜ì—¬ ì‘ë‹µ í¬ê¸° ìµœì†Œí™”
- **ë‚ ì§œ ë²”ìœ„**: ì ì ˆí•œ ê¸°ê°„ ì„¤ì •ìœ¼ë¡œ ì„±ëŠ¥ í–¥ìƒ
- **ë¹„ë™ê¸° ì‘ì—…**: ëŒ€ìš©ëŸ‰ ë°ì´í„°ëŠ” async jobìœ¼ë¡œ ì²˜ë¦¬
- **ìºì‹± ê³„ì¸µ**: ìì£¼ ì‚¬ìš©ë˜ëŠ” ë°ì´í„° ìºì‹±

### ì¶”ì  ë° ì „í™˜ ì‚¬ì–‘ ì‹œìŠ¤í…œ

#### í•µì‹¬ ê°œë…
- **ì¶”ì  ì‚¬ì–‘(tracking_specs)**: ê´‘ê³ ì—ì„œ ì‚¬ëŒë“¤ì˜ í–‰ë™ì„ ë¡œê¹…
- **ì „í™˜ ì‚¬ì–‘(conversion_specs)**: v2.4ë¶€í„° ì½ê¸° ì „ìš©, optimization_goal ì‚¬ìš©
- **ë©”íƒ€ ì‚¬ì–‘**: ë‹¨ì¼ ê°ì²´ì— ì—¬ëŸ¬ í–‰ë™ ìœ í˜•ì„ ì¶”ì 

### ë§ˆì¼€íŒ… ë¯¹ìŠ¤ ëª¨ë¸ë§(MMM) ë¶„ì„ ì‹œìŠ¤í…œ

#### í•µì‹¬ íŠ¹ì§•
- **ì „ìš© API**: `breakdowns=mmm` ë§¤ê°œë³€ìˆ˜ë¡œ íŠ¹í™”ëœ ë°ì´í„° ì¶”ì¶œ
- **ë…ë¦½ì„±**: ë‹¤ë¥¸ breakdownê³¼ ë³‘í–‰ ì‚¬ìš© ë¶ˆê°€, ë…ë¦½ì  ì²˜ë¦¬ í•„ìš”
- **ì œí•œëœ ë²”ìœ„**: ê´‘ê³  ì„¸íŠ¸ ìˆ˜ì¤€(`level=adset`)ì—ì„œë§Œ ì œê³µ
- **í•µì‹¬ ì§€í‘œ**: impressions, spend (ì¶”ì‚°ì¹˜) ì œê³µ

#### MMM ë°ì´í„° í™œìš© ì „ëµ

**ë¹„ì¦ˆë‹ˆìŠ¤ ê´€ë¦¬ì ìˆ˜ì¤€ í†µí•©**
```typescript
interface BusinessManagerMMMQuery {
  businessId: string;
  ownedAccounts: string[];
  clientAccounts: string[];
  aggregationStrategy: 'SUM' | 'WEIGHTED_AVERAGE' | 'SEPARATE';
}

class BusinessManagerMMMCollector {
  async collectAllAccountsMMM(businessId: string): Promise<MMMData[]> {
    // 1. owned_ad_accounts ìˆ˜ì§‘
    const ownedAccounts = await this.getOwnedAccounts(businessId);

    // 2. client_ad_accounts ìˆ˜ì§‘
    const clientAccounts = await this.getClientAccounts(businessId);

    // 3. ê° ê³„ì •ë³„ MMM ë°ì´í„° ìˆœì°¨ ìˆ˜ì§‘
    const allMMMData = await Promise.all([
      ...ownedAccounts.map(acc => this.collectAccountMMM(acc.id)),
      ...clientAccounts.map(acc => this.collectAccountMMM(acc.id))
    ]);

    return this.aggregateResults(allMMMData);
  }
}
```

**MMM ì „ìš© í•„í„°ë§ ì‹œìŠ¤í…œ**
```typescript
interface MMMFilterValidation {
  allowedFilters: {
    'campaign.id': ['IN', 'NOT_IN'];
    'campaign.name': ['CONTAIN', 'NOT_CONTAIN'];
    'adset.id': ['IN', 'NOT_IN'];
    'adset.name': ['CONTAIN', 'NOT_CONTAIN'];
    'country': ['IN'];
    'region': ['IN'];
    'dma': ['IN'];
    'device_platform': ['IN'];
    'publisher_platform': ['IN'];
    'platform_position': ['IN'];
  };
}

class MMMFilterValidator {
  validateFilter(field: string, operator: string): boolean {
    const allowedOps = this.allowedFilters[field];
    return allowedOps?.includes(operator) || false;
  }
}
```

#### ë§ˆì¼€íŒ… íš¨ê³¼ ì¸¡ì • í™•ì¥

**ì±„ë„ ê¸°ì—¬ë„ ë¶„ì„**
- MMM ë°ì´í„°ë¥¼ í†µí•œ ì •í™•í•œ ë§ˆì¼€íŒ… ì±„ë„ë³„ íš¨ê³¼ ì¸¡ì •
- í¬ë¡œìŠ¤ ì±„ë„ ìƒí˜¸ì‘ìš© ë¶„ì„ ë° ì‹œë„ˆì§€ íš¨ê³¼ ê³„ì‚°
- ì¦ë¶„ íš¨ê³¼(Incremental Effect) ì¸¡ì •ì„ í†µí•œ ìˆœìˆ˜ ê¸°ì—¬ë„ ì‚°ì¶œ

**ì˜ˆì‚° ìµœì í™” ëª¨ë¸ë§**
- MMM ë°ì´í„° ê¸°ë°˜ ìµœì  ì˜ˆì‚° ë°°ë¶„ ëª¨ë¸ êµ¬ì¶•
- í•œê³„ íš¨ìš© ë¶„ì„ì„ í†µí•œ ì±„ë„ë³„ ì¶”ê°€ íˆ¬ì ìˆ˜ìµë¥  ì˜ˆì¸¡
- ì‹œì¥ í¬í™”ë„ ê³ ë ¤í•œ ì¥ê¸°ì  íˆ¬ì ì „ëµ ìˆ˜ë¦½

### Lift Studies ê¸°ë°˜ ì‹¤í—˜ ê²€ì¦ ì‹œìŠ¤í…œ

#### í•µì‹¬ íŠ¹ì§•
- **ë¬´ì‘ìœ„ ëŒ€ì¡° ì‹¤í—˜**: ì‹¤í—˜êµ°ê³¼ ëŒ€ì¡°êµ° ì„ì˜ ë°°ì •ìœ¼ë¡œ ì¸ê³¼ê´€ê³„ ì…ì¦
- **ì‹¤ì‹œê°„ ì‹¤í—˜**: ì‹¤ì œ ìº í˜ì¸ê³¼ ë™ì‹œ ì§„í–‰ë˜ëŠ” ë¼ì´ë¸Œ ì‹¤í—˜
- **ì œí•œëœ ì ‘ê·¼**: Meta ë‹´ë‹¹ìë¥¼ í†µí•œ ì•¡ì„¸ìŠ¤ ê¶Œí•œ íšë“ í•„ìš”
- **í†µê³„ì  ì—„ë°€ì„±**: p-value, ì‹ ë¢°êµ¬ê°„ ë“± ê³¼í•™ì  ê²€ì¦ ë°©ë²• ì ìš©

### ë¶„í•  í…ŒìŠ¤íŠ¸(Split Test) ì‹œìŠ¤í…œ

#### í•µì‹¬ íŠ¹ì§•
- **A/B í…ŒìŠ¤íŠ¸ ìë™í™”**: íƒ€ê²Ÿ ë¶„í•  ìë™í™” ë° ê·¸ë£¹ ê°„ ì¤‘ë³µ ë°©ì§€
- **ë‹¤ë³€ìˆ˜ í…ŒìŠ¤íŠ¸**: íƒ€ê²ŸíŒ…, ê²Œì¬ ìµœì í™”, í¬ë¦¬ì—ì´í‹°ë¸Œ, ì˜ˆì‚° ë“± ë‹¤ì–‘í•œ ë³€ìˆ˜ í…ŒìŠ¤íŠ¸
- **í†µê³„ì  ë¬´ê²°ì„±**: í•œ ë²ˆì— í•˜ë‚˜ì˜ ë³€ìˆ˜ë§Œ í…ŒìŠ¤íŠ¸í•˜ì—¬ ê³¼í•™ì  ê²€ì¦ ë³´ì¥
- **ì‹¤ì‹œê°„ ì„±ê³¼ ë¹„êµ**: KPI ê¸°ë°˜ íš¨ìœ¨ì„± ì§€í‘œ ì‹¤ì‹œê°„ ì¸¡ì •

#### ë¶„í•  í…ŒìŠ¤íŠ¸ ì œí•œì‚¬í•­
- **ê´‘ê³ ì£¼ë‹¹ ìµœëŒ€ ë™ì‹œ ì—°êµ¬**: 100ê°œ
- **ì—°êµ¬ë‹¹ ìµœëŒ€ ì…€**: 150ê°œ
- **ì…€ë‹¹ ìµœëŒ€ ê´‘ê³  í•­ëª©**: 100ê°œ
- **ë³€ìˆ˜ ë¶„ë¦¬ ì›ì¹™**: í…ŒìŠ¤íŠ¸ì˜ ê³¼í•™ì  ë¬´ê²°ì„±ì„ ìœ„í•œ ë‹¨ì¼ ë³€ìˆ˜ í…ŒìŠ¤íŠ¸ ê¶Œì¥

### ê´‘ê³  ë³¼ë¥¨ ê´€ë¦¬ ì‹œìŠ¤í…œ

#### í•µì‹¬ íŠ¹ì§•
- **ì‹¤ì‹œê°„ ë³¼ë¥¨ ëª¨ë‹ˆí„°ë§**: ê²Œì¬ ì¤‘ì´ê±°ë‚˜ ê²€í†  ì¤‘ì¸ ê´‘ê³  ìˆ˜ ì‹¤ì‹œê°„ ì¶”ì 
- **í˜ì´ì§€ë³„ ì œí•œ ê´€ë¦¬**: 2021ë…„ ì´ˆ ë„ì…ëœ í˜ì´ì§€ë‹¹ ê´‘ê³  ì œí•œ ì •ì±… ì¤€ìˆ˜
- **ì§€ëŠ¥í˜• ìƒíƒœ íŒë³„**: effective_statusì™€ configured_status ê¸°ë°˜ ì •í™•í•œ ê´‘ê³  ìƒíƒœ ì¶”ì 
- **ë¯¸ë˜ ì œí•œ ì˜ˆì¸¡**: future_limit_activation_dateë¥¼ í†µí•œ ì„ ì œì  ì œí•œ ëŒ€ì‘

#### ë³¼ë¥¨ ì œí•œ ì²´ê³„
- **ê°œë³„ ê³„ì • ì œí•œ**: current_account_ads_running_or_in_review_count
- **í˜ì´ì§€ ìˆ˜ì¤€ ì œí•œ**: ads_running_or_in_review_count per actor_id
- **ë¹„ì¦ˆë‹ˆìŠ¤ ê´€ë¦¬ì ì œí•œ**: ad_limit_scope_business_manager_id ê¸°ë°˜
- **ë™ì  ì œí•œ ì ìš©**: ìŠ¤ì¼€ì¤„ ê¸°ë°˜ ì‹œê°„ë³„ ë³¼ë¥¨ ì¹´ìš´íŒ…

#### ìë™ ê¶Œì¥ì‚¬í•­ ì‹œìŠ¤í…œ
- **zero_impression**: ë…¸ì¶œ ì—†ëŠ” ê´‘ê³  ì‹ë³„ ë° ì •ë¦¬ ê¶Œì¥
- **learning_limited**: í•™ìŠµ ì œí•œ ê´‘ê³  ìµœì í™” ê¶Œì¥
- **top_campaigns_with_ads_under_cap**: ë³¼ë¥¨ ì—¬ìœ  ìˆëŠ” ìº í˜ì¸ í™œìš© ê¶Œì¥
- **top_adsets_with_ads_under_cap**: íš¨ìœ¨ì  ê´‘ê³  ì„¸íŠ¸ í™•ì¥ ê¶Œì¥

### ê´‘ê³  ê·œì¹™ ì—”ì§„ ì‹œìŠ¤í…œ

#### í•µì‹¬ íŠ¹ì§•
- **ì¤‘ì•™ ê·œì¹™ ê´€ë¦¬**: ê´‘ê³ ë¥¼ ì‰½ê³  íš¨ìœ¨ì ìœ¼ë¡œ ìë™ ê´€ë¦¬í•˜ëŠ” í†µí•© ì„œë¹„ìŠ¤
- **ì´ì¤‘ ì‹¤í–‰ ëª¨ë“œ**: Schedule Based (ì •ê¸° ì‹¤í–‰) + Trigger Based (ì‹¤ì‹œê°„ ë°˜ì‘)
- **ê³ ê¸‰ í•„í„°ë§**: ë©”íƒ€ë°ì´í„°, ì¸ì‚¬ì´íŠ¸, ê³ ê¸‰ ì¡°ê±´ì„ ì¡°í•©í•œ ì •êµí•œ íƒ€ê²ŸíŒ…
- **ìë™ ì•¡ì…˜ ì‹¤í–‰**: ì¡°ê±´ ì¶©ì¡± ì‹œ ì‚¬ì „ ì •ì˜ëœ ì•¡ì…˜ ìë™ ìˆ˜í–‰

#### ê·œì¹™ ì—”ì§„ êµ¬ì¡°
- **í‰ê°€ ì‚¬ì–‘(Evaluation Spec)**: ê·œì¹™ ì ìš© ëŒ€ìƒ ë° ì¡°ê±´ ì •ì˜
- **ì‹¤í–‰ ì‚¬ì–‘(Execution Spec)**: ì¡°ê±´ ì¶©ì¡± ì‹œ ìˆ˜í–‰í•  ì•¡ì…˜ ì •ì˜
- **ë‹¤ì¸µ í•„í„°ë§**: entity_type, ë©”íƒ€ë°ì´í„°, ì¸ì‚¬ì´íŠ¸ ë°ì´í„° ê¸°ë°˜ ì •êµí•œ ì¡°ê±´
- **ì‹¤ì‹œê°„ íŠ¸ë¦¬ê±°**: ê´‘ê³  ìƒíƒœ ë³€ê²½ ì¦‰ì‹œ ê·œì¹™ í‰ê°€ ë° ì‹¤í–‰

#### ê´‘ê³  ê·œì¹™ ì—”ì§„ í™œìš© ì „ëµ

**ê·œì¹™ ì„¤ê³„ ì‹œìŠ¤í…œ**
```typescript
interface AdRuleConfig {
  name: string;
  evaluation_spec: {
    evaluation_type: 'SCHEDULE' | 'TRIGGER';
    filters: RuleFilter[];
    trigger?: RuleTrigger;
  };
  execution_spec: {
    execution_type: 'PAUSE' | 'UNPAUSE' | 'BUDGET_UPDATE' | 'BID_UPDATE';
    execution_options: any;
  };
  status: 'ENABLED' | 'DISABLED';
}

interface RuleFilter {
  field: string;
  value: any;
  operator: 'GREATER_THAN' | 'LESS_THAN' | 'EQUAL' | 'IN_RANGE' | 'NOT_IN_RANGE' | 'IN' | 'NOT_IN';
}

class AdRuleEngine {
  async createPerformanceRule(config: PerformanceRuleConfig): Promise<string> {
    // 1. ì„±ê³¼ ê¸°ë°˜ ê·œì¹™ ìƒì„± (CPA, ROAS, CTR ë“±)
    const evaluationSpec = this.buildPerformanceEvaluation(config);

    // 2. ìë™ ì•¡ì…˜ ì •ì˜ (ì¼ì‹œì •ì§€, ì˜ˆì‚° ì¡°ì • ë“±)
    const executionSpec = this.buildAutoActionExecution(config);

    // 3. ê´‘ê³  ê·œì¹™ ìƒì„± ë° í™œì„±í™”
    return this.createRule({
      name: config.name,
      evaluation_spec: evaluationSpec,
      execution_spec: executionSpec,
      status: 'ENABLED'
    });
  }

  async createScheduleBasedRule(schedule: string, conditions: RuleFilter[], actions: ExecutionSpec): Promise<string> {
    // ì •ê¸°ì  ì‹¤í–‰ ê·œì¹™ (ì¼ì¼, ì£¼ê°„, ì›”ê°„)
    // ì˜ˆ: ë§¤ì¼ ì˜¤ì „ 9ì‹œ ì„±ê³¼ ê²€í†  í›„ ìë™ ìµœì í™”
  }

  async createTriggerBasedRule(trigger: RuleTrigger, conditions: RuleFilter[], actions: ExecutionSpec): Promise<string> {
    // ì‹¤ì‹œê°„ ë°˜ì‘ ê·œì¹™
    // ì˜ˆ: ê´‘ê³  ìƒíƒœ ë³€ê²½, ì„±ê³¼ ì§€í‘œ ì„ê³„ê°’ ì´ˆê³¼ ì‹œ ì¦‰ì‹œ ëŒ€ì‘
  }
}
```

**ì‹¤ìš©ì  ê·œì¹™ ì˜ˆì‹œ**
```typescript
// 1. ì„±ê³¼ ê¸°ë°˜ ìë™ ì¼ì‹œì •ì§€ ê·œì¹™
const performancePauseRule = {
  name: "High CPA Auto Pause",
  evaluation_spec: {
    evaluation_type: "SCHEDULE",
    filters: [
      { field: "entity_type", value: "AD", operator: "EQUAL" },
      { field: "time_preset", value: "LAST_7_DAYS", operator: "EQUAL" },
      { field: "cpa", value: 50.00, operator: "GREATER_THAN" },
      { field: "spent", value: 100.00, operator: "GREATER_THAN" }
    ]
  },
  execution_spec: {
    execution_type: "PAUSE"
  }
};

// 2. ì˜ˆì‚° ì†Œì§„ìœ¨ ê¸°ë°˜ ìë™ ì¡°ì • ê·œì¹™
const budgetOptimizationRule = {
  name: "Budget Rebalancing",
  evaluation_spec: {
    evaluation_type: "TRIGGER",
    filters: [
      { field: "entity_type", value: "ADSET", operator: "EQUAL" },
      { field: "estimated_budget_spending_percentage", value: [120, 200], operator: "IN_RANGE" }
    ],
    trigger: {
      type: "metadata_change",
      field: "estimated_budget_spending_percentage"
    }
  },
  execution_spec: {
    execution_type: "BUDGET_UPDATE",
    execution_options: { increase_percentage: 20 }
  }
};

// 3. ì‹¤ì‹œê°„ ì„±ê³¼ ëª¨ë‹ˆí„°ë§ ê·œì¹™
const realTimeOptimizationRule = {
  name: "Real-time Performance Monitor",
  evaluation_spec: {
    evaluation_type: "TRIGGER",
    filters: [
      { field: "entity_type", value: "AD", operator: "EQUAL" },
      { field: "time_preset", value: "TODAY", operator: "EQUAL" },
      { field: "ctr", value: 0.5, operator: "LESS_THAN" },
      { field: "spent", value: 20.00, operator: "GREATER_THAN" }
    ],
    trigger: {
      type: "insights_change",
      field: "ctr"
    }
  },
  execution_spec: {
    execution_type: "PAUSE"
  }
};
```

#### ê´‘ê³  ë³¼ë¥¨ í™œìš© ì „ëµ

**ë³¼ë¥¨ ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ**
```typescript
interface AdsVolumeConfig {
  account_id: string;
  page_id?: string;
  show_breakdown_by_actor: boolean;
  recommendation_type?: 'zero_impression' | 'learning_limited' | 'top_campaigns_with_ads_under_cap' | 'top_adsets_with_ads_under_cap';
}

interface AdsVolumeResponse {
  ads_running_or_in_review_count: number;
  current_account_ads_running_or_in_review_count: number;
  actor_id: string;
  actor_name?: string;
  limit_on_ads_running_or_in_review: number;
  future_limit_activation_date?: string;
  future_limit_on_ads_running_or_in_review?: number;
  recommendations: VolumeRecommendation[];
}

class AdsVolumeManager {
  async monitorAccountVolume(accountId: string): Promise<VolumeStatus> {
    // 1. í˜„ì¬ ë³¼ë¥¨ ìƒíƒœ í™•ì¸
    const volumeData = await this.getVolumeData(accountId);

    // 2. ì œí•œ ì„ê³„ê°’ ë¶„ì„
    const thresholdAnalysis = this.analyzeThresholds(volumeData);

    // 3. ì•Œë¦¼ ë° ê²½ê³  ìƒì„±
    const alerts = this.generateAlerts(thresholdAnalysis);

    return { volumeData, thresholdAnalysis, alerts };
  }

  async optimizeVolumeUsage(accountId: string): Promise<OptimizationResult> {
    // 1. ê¶Œì¥ì‚¬í•­ ìˆ˜ì§‘
    const recommendations = await this.getRecommendations(accountId);

    // 2. ìë™ ìµœì í™” ì‹¤í–‰
    const optimizationActions = await this.executeOptimizations(recommendations);

    return { recommendations, optimizationActions };
  }
}
```

**ë³¼ë¥¨ ìµœì í™” ì—”ì§„**
```typescript
interface VolumeOptimizationRule {
  trigger: 'threshold_warning' | 'threshold_critical' | 'future_limit_approaching';
  action: 'pause_low_performers' | 'consolidate_ads' | 'redistribute_budget';
  threshold: number;
  priority: 'high' | 'medium' | 'low';
}

class VolumeOptimizer {
  async applyVolumeOptimization(accountId: string, rules: VolumeOptimizationRule[]): Promise<OptimizationResult> {
    const volumeStatus = await this.getVolumeStatus(accountId);

    for (const rule of rules) {
      if (this.shouldTriggerRule(rule, volumeStatus)) {
        await this.executeOptimization(rule, volumeStatus);
      }
    }
  }

  async predictFutureLimits(accountId: string): Promise<LimitPrediction> {
    // ë¯¸ë˜ ì œí•œ ì˜ˆì¸¡ ë° ì„ ì œì  ëŒ€ì‘ ê³„íš
    const futureData = await this.getFutureLimitData(accountId);
    const prediction = this.calculateLimitPrediction(futureData);

    return { prediction, recommendedActions: this.generatePreemptiveActions(prediction) };
  }
}
```

#### ë¶„í•  í…ŒìŠ¤íŠ¸ í™œìš© ì „ëµ

**í…ŒìŠ¤íŠ¸ ì„¤ê³„ ì‹œìŠ¤í…œ**
```typescript
interface SplitTestConfig {
  name: string;
  description: string;
  start_time: number;
  end_time: number;
  type: 'SPLIT_TEST';
  cells: SplitTestCell[];
}

interface SplitTestCell {
  name: string;
  treatment_percentage: number;
  adsets?: string[];
  campaigns?: string[];
}

class SplitTestManager {
  async createSplitTest(businessId: string, config: SplitTestConfig): Promise<string> {
    // 1. í…ŒìŠ¤íŠ¸ ì„¤ê³„ ê²€ì¦
    this.validateTestDesign(config);

    // 2. í†µê³„ì  ê²€ì •ë ¥ ê³„ì‚°
    const powerAnalysis = await this.calculateStatisticalPower(config);

    // 3. ë¶„í•  í…ŒìŠ¤íŠ¸ ìƒì„±
    return this.createStudy(businessId, config);
  }

  validateTestDesign(config: SplitTestConfig): void {
    // ë‹¨ì¼ ë³€ìˆ˜ í…ŒìŠ¤íŠ¸ ì›ì¹™ ê²€ì¦
    // ë¹„êµ ê°€ëŠ¥í•œ í…ŒìŠ¤íŠ¸ í¬ê¸° í™•ì¸
    // ì‹ ë¢°ë„ ìˆ˜ì¤€ ì„¤ì • ê²€ì¦
  }
}
```

**í…ŒìŠ¤íŠ¸ ë¶„ì„ ì—”ì§„**
```typescript
interface SplitTestResults {
  cellId: string;
  cellName: string;
  treatmentPercentage: number;
  metrics: {
    impressions: number;
    clicks: number;
    conversions: number;
    spend: number;
    cpa: number;
    ctr: number;
    conversionRate: number;
  };
  statisticalSignificance: number;
  confidenceInterval: [number, number];
}

class SplitTestAnalyzer {
  async analyzeTestResults(studyId: string): Promise<SplitTestInsights> {
    // 1. í…ŒìŠ¤íŠ¸ ê²°ê³¼ ìˆ˜ì§‘
    const results = await this.fetchTestResults(studyId);

    // 2. í†µê³„ì  ìœ ì˜ì„± ê²€ì¦
    const significance = this.calculateStatisticalSignificance(results);

    // 3. ìŠ¹ì ì…€ ê²°ì •
    const winner = this.determineWinningCell(results, significance);

    // 4. ê¶Œì¥ì‚¬í•­ ìƒì„±
    const recommendations = this.generateActionRecommendations(winner, results);

    return { results, winner, recommendations, significance };
  }

  determineWinningCell(results: SplitTestResults[], significance: number): SplitTestResults | null {
    // p-value < 0.05 ê¸°ì¤€ í†µê³„ì  ìœ ì˜ì„± ê²€ì¦
    if (significance < 0.05) {
      // ëª©í‘œ ì§€í‘œ ê¸°ì¤€ ìµœê³  ì„±ê³¼ ì…€ ì„ íƒ (ì˜ˆ: ê°€ì¥ ë‚®ì€ CPA)
      return results.reduce((best, current) =>
        current.metrics.cpa < best.metrics.cpa ? current : best
      );
    }
    return null; // í†µê³„ì  ìœ ì˜ì„± ì—†ìŒ
  }
}
```

#### Lift Studies í™œìš© ì „ëµ

**ì‹¤í—˜ ì„¤ê³„ ì‹œìŠ¤í…œ**
```typescript
interface LiftStudyConfig {
  name: string;
  description: string;
  startTime: number;
  endTime: number;
  observationEndTime: number;
  type: 'LIFT';
  cells: StudyCell[];
  objectives: StudyObjective[];
  viewers: string[];
}

interface StudyCell {
  name: string;
  description: string;
  treatmentPercentage: number;  // ê´‘ê³ ë¥¼ ë³´ëŠ” ê·¸ë£¹ ë¹„ìœ¨
  controlPercentage: number;    // ê´‘ê³ ë¥¼ ë³´ì§€ ì•ŠëŠ” ê·¸ë£¹ ë¹„ìœ¨
  adAccounts?: string[];
  campaigns?: string[];
}

class LiftStudyManager {
  async createLiftStudy(businessId: string, config: LiftStudyConfig): Promise<string> {
    // 1. ì‹¤í—˜ ì„¤ê³„ ê²€ì¦
    this.validateStudyDesign(config);

    // 2. ìµœì  ì‹¤í—˜êµ°/ëŒ€ì¡°êµ° ë¹„ìœ¨ ê³„ì‚°
    const optimizedCells = await this.optimizeCellRatios(config.cells);

    // 3. Lift Study ìƒì„±
    return this.createStudy(businessId, { ...config, cells: optimizedCells });
  }
}
```

**ê²°ê³¼ ë¶„ì„ ì—”ì§„**
```typescript
interface LiftStudyResults {
  cellId: string;
  populationTest: number;
  populationControl: number;
  conversionsIncremental: number;
  conversionsConfidence: number;
  conversionsIncrementalLower: number;
  conversionsIncrementalUpper: number;
  conversionsCPiC: number;
  conversionsIncrementalShare: number;
}

class LiftResultsAnalyzer {
  async analyzeLiftResults(studyId: string): Promise<LiftInsights> {
    // 1. ê²°ê³¼ ë°ì´í„° ìˆ˜ì§‘
    const results = await this.fetchStudyResults(studyId);

    // 2. í†µê³„ì  ìœ ì˜ì„± ê²€ì¦
    const significance = this.validateStatisticalSignificance(results);

    // 3. ì‹¤ì§ˆì  ì˜ë¯¸ í‰ê°€
    const practicalSignificance = this.assessPracticalSignificance(results);

    // 4. ì˜ì‚¬ê²°ì • ê¶Œì¥ì‚¬í•­ ìƒì„±
    const recommendations = this.generateRecommendations(results, significance);

    return { results, significance, practicalSignificance, recommendations };
  }
}
```

#### ê³ ê¸‰ ì‹¤í—˜ ì„¤ê³„

**ë‹¤ì¤‘ ì‹¤í—˜êµ° ì „ëµ**
- ì—¬ëŸ¬ ê´‘ê³  ì „ëµ ë™ì‹œ ë¹„êµ (ì˜ˆ: íƒ€ê²ŸíŒ… A vs B vs ëŒ€ì¡°êµ°)
- ì˜ˆì‚° ë°°ë¶„ ìµœì í™” (80% vs 60% vs 40% vs ëŒ€ì¡°êµ°)
- í¬ë¦¬ì—ì´í‹°ë¸Œ íš¨ê³¼ ì¸¡ì • (ì˜ìƒ vs ì´ë¯¸ì§€ vs ëŒ€ì¡°êµ°)

**ì‹¤í—˜ ê¸°ê°„ ìµœì í™”**
- ìµœì†Œ ìœ íš¨ í‘œë³¸ í¬ê¸° ê³„ì‚°
- ì‹œì¦Œì„± ê³ ë ¤í•œ ì‹¤í—˜ ê¸°ê°„ ì„¤ì •
- ê´€ì°° ê¸°ê°„(observation period) ìµœì í™”

#### ì£¼ìš” ì¶”ì  íŒ¨í„´

**ì•± ê´€ë ¨ ì¶”ì **
```json
{
  "action.type": "mobile_app_install",
  "application": "APP_ID"
}
{
  "action.type": "app_custom_event",
  "application": "APP_ID"
}
```

**ì›¹ì‚¬ì´íŠ¸ ì „í™˜ ì¶”ì **
```json
{
  "action.type": "offsite_conversion",
  "fb_pixel": "PIXEL_ID"
}
{
  "action.type": "link_click",
  "object": "URL"
}
```

**ì†Œì…œ ì°¸ì—¬ ì¶”ì **
```json
{
  "action.type": "post_engagement",
  "post": "POST_ID",
  "page": "PAGE_ID"
}
```

#### ë‹¤ì¤‘ í”½ì…€ ì¶”ì  ì „ëµ
```json
[
  {"action.type": "offsite_conversion", "fb_pixel": 1},
  {"action.type": "offsite_conversion", "fb_pixel": 2},
  {"action.type": "offsite_conversion", "fb_pixel": 3}
]
```

---

## ğŸ—ï¸ í•µì‹¬ ê¸°ëŠ¥ ì„¤ê³„

### 1. ê´‘ê³  ë°ì´í„° ë¶„ì„ ëª¨ë“ˆ

#### ì‹¤ì‹œê°„ ì„±ê³¼ ëª¨ë‹ˆí„°ë§
- **ëŒ€ì‹œë³´ë“œ**: í•µì‹¬ KPI ì‹¤ì‹œê°„ í‘œì‹œ
- **ì•Œë¦¼ ì‹œìŠ¤í…œ**: ì„ê³„ê°’ ì´ˆê³¼ ì‹œ ìë™ ì•Œë¦¼
- **íŠ¸ë Œë“œ ë¶„ì„**: ì‹œê³„ì—´ ë°ì´í„° ê¸°ë°˜ íŒ¨í„´ ì¸ì‹

#### ì„¸ë¶„í™”ëœ ë¦¬í¬íŒ…
- **Breakdown ë¶„ì„**: ì¸êµ¬í†µê³„, ë””ë°”ì´ìŠ¤, ìœ„ì¹˜ë³„ ì„±ê³¼
- **ìº í˜ì¸ ë¹„êµ**: ì—¬ëŸ¬ ìº í˜ì¸ì˜ ì„±ê³¼ ë¹„êµ ë¶„ì„
- **ROI/ROAS ë¶„ì„**: íˆ¬ì ëŒ€ë¹„ ìˆ˜ìµë¥  ê³„ì‚°

#### ì˜ˆì¸¡ ë¶„ì„
- **ì„±ê³¼ ì˜ˆì¸¡**: ë¨¸ì‹ ëŸ¬ë‹ ê¸°ë°˜ ë¯¸ë˜ ì„±ê³¼ ì˜ˆì¸¡
- **ì˜ˆì‚° ìµœì í™”**: ì˜ˆì¸¡ ëª¨ë¸ ê¸°ë°˜ ì˜ˆì‚° ë°°ë¶„ ì¶”ì²œ
- **A/B í…ŒìŠ¤íŠ¸**: í†µê³„ì  ìœ ì˜ì„± ê¸°ë°˜ í…ŒìŠ¤íŠ¸ ê²°ê³¼ ë¶„ì„

### 2. ê´‘ê³  ìë™ í¬ìŠ¤íŒ… ëª¨ë“ˆ

#### ìº í˜ì¸ ìë™ ìƒì„±
- **í…œí”Œë¦¿ ì‹œìŠ¤í…œ**: ì¬ì‚¬ìš© ê°€ëŠ¥í•œ ìº í˜ì¸ í…œí”Œë¦¿
- **ë™ì  í¬ë¦¬ì—ì´í‹°ë¸Œ**: ë°ì´í„° ê¸°ë°˜ ìë™ í¬ë¦¬ì—ì´í‹°ë¸Œ ìƒì„±
- **íƒ€ê²ŸíŒ… ìµœì í™”**: ê³¼ê±° ë°ì´í„° ê¸°ë°˜ ì˜¤ë””ì–¸ìŠ¤ íƒ€ê²ŸíŒ…

#### ìŠ¤ì¼€ì¤„ë§ ì‹œìŠ¤í…œ
- **ì‹œê°„ ê¸°ë°˜**: íŠ¹ì • ì‹œê°„/ë‚ ì§œì— ìë™ ì‹¤í–‰
- **ì¡°ê±´ ê¸°ë°˜**: ì„±ê³¼ ì§€í‘œ ë‹¬ì„± ì‹œ ìë™ ì‹¤í–‰
- **ì´ë²¤íŠ¸ ê¸°ë°˜**: ì™¸ë¶€ ì´ë²¤íŠ¸ ë°œìƒ ì‹œ ìë™ ì‹¤í–‰

#### ìë™ ìµœì í™”
- **ì…ì°° ì¡°ì •**: ì„±ê³¼ ê¸°ë°˜ ìë™ ì…ì°°ê°€ ì¡°ì •
- **ì˜ˆì‚° ì¬ë°°ë¶„**: ì„±ê³¼ ì¢‹ì€ ê´‘ê³  ì„¸íŠ¸ë¡œ ì˜ˆì‚° ì´ë™
- **ì¼ì‹œì •ì§€/ì¬ê°œ**: ì„±ê³¼ ê¸°ì¤€ì— ë”°ë¥¸ ìë™ ì œì–´

### 4. ë§ˆì¼€íŒ… ë¯¹ìŠ¤ ëª¨ë¸ë§(MMM) ë¶„ì„ ëª¨ë“ˆ

#### MMM ë°ì´í„° ìˆ˜ì§‘ ì‹œìŠ¤í…œ
- **ë‹¤ì¤‘ ê³„ì • ê´€ë¦¬**: ë¹„ì¦ˆë‹ˆìŠ¤ ê´€ë¦¬ì ìˆ˜ì¤€ì˜ í†µí•© ë°ì´í„° ìˆ˜ì§‘
- **ë¹„ë™ê¸° ì²˜ë¦¬**: ëŒ€ìš©ëŸ‰ MMM ë°ì´í„°ì˜ íš¨ìœ¨ì  ì²˜ë¦¬
- **CSV ìµœì í™”**: export_format=csvë¥¼ í™œìš©í•œ ëŒ€ìš©ëŸ‰ ë°ì´í„° ë‹¤ìš´ë¡œë“œ
- **ë°ì´í„° ê²€ì¦**: MMM ì „ìš© í•„í„°ë§ ê·œì¹™ ê²€ì¦ ë° ì˜¤ë¥˜ ì²˜ë¦¬

#### ë§ˆì¼€íŒ… íš¨ê³¼ ì¸¡ì •
- **ì±„ë„ ê¸°ì—¬ë„ ë¶„ì„**: ê° ë§ˆì¼€íŒ… ì±„ë„ì˜ ìˆœìˆ˜ ê¸°ì—¬ë„ ì¸¡ì •
- **ì¦ë¶„ íš¨ê³¼ ê³„ì‚°**: ìœ ê¸°ì  ì„±ì¥ ëŒ€ë¹„ ê´‘ê³  íš¨ê³¼ ë¶„ë¦¬ ì¸¡ì •
- **ì‹œë„ˆì§€ ë¶„ì„**: ì±„ë„ ê°„ ìƒí˜¸ì‘ìš© ë° ë³µí•© íš¨ê³¼ ë¶„ì„
- **ROI/ROAS ì •ë°€ ê³„ì‚°**: MMM ë°ì´í„° ê¸°ë°˜ ì •í™•í•œ ìˆ˜ìµë¥  ì¸¡ì •

#### ì˜ˆì‚° ìµœì í™” AI
- **ìµœì  ë°°ë¶„ ëª¨ë¸**: MMM ë°ì´í„° ê¸°ë°˜ ì±„ë„ë³„ ì˜ˆì‚° ìµœì í™”
- **í•œê³„ íš¨ìš© ë¶„ì„**: ì¶”ê°€ íˆ¬ì ì‹œ ì˜ˆìƒ ìˆ˜ìµë¥  ê³„ì‚°
- **ì‹œì¥ í¬í™”ë„ ëª¨ë‹ˆí„°ë§**: ì±„ë„ë³„ ì„±ì¥ í•œê³„ì  ë° í¬í™”ë„ ë¶„ì„
- **ì¥ê¸° ì „ëµ ìˆ˜ë¦½**: ì‹œê°„ë³„ íŠ¸ë Œë“œ ê¸°ë°˜ ì¤‘ì¥ê¸° íˆ¬ì ê³„íš

### 5. ê´‘ê³  íš¨ê³¼ ê²€ì¦ ëª¨ë“ˆ (Lift Studies)

#### ë¬´ì‘ìœ„ ëŒ€ì¡° ì‹¤í—˜ ì‹œìŠ¤í…œ
- **ì‹¤í—˜ ì„¤ê³„ ìë™í™”**: ìµœì  ì‹¤í—˜êµ°/ëŒ€ì¡°êµ° ë¹„ìœ¨ ìë™ ê³„ì‚°
- **ë‹¤ì¤‘ ì‹¤í—˜êµ° ê´€ë¦¬**: ì—¬ëŸ¬ ê´‘ê³  ì „ëµ ë™ì‹œ ë¹„êµ í…ŒìŠ¤íŠ¸
- **ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§**: ì‹¤í—˜ ì§„í–‰ ìƒí™© ë° ì˜ˆë¹„ ê²°ê³¼ ì‹¤ì‹œê°„ ì¶”ì 
- **ìœ¤ë¦¬ì  ì‹¤í—˜**: ëŒ€ì¡°êµ° ë…¸ì¶œ ìµœì†Œí™”ë¥¼ í†µí•œ ê¸°íšŒë¹„ìš© ê°ì†Œ

### 6. ê´‘ê³  ë³¼ë¥¨ ê´€ë¦¬ ëª¨ë“ˆ (Ads Volume Management)

#### ì‹¤ì‹œê°„ ë³¼ë¥¨ ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ
- **ë‹¤ì¸µ ì œí•œ ì¶”ì **: ê³„ì •/í˜ì´ì§€/ë¹„ì¦ˆë‹ˆìŠ¤ ê´€ë¦¬ì ìˆ˜ì¤€ë³„ ë³¼ë¥¨ ëª¨ë‹ˆí„°ë§
- **ì„ê³„ê°’ ê¸°ë°˜ ì•Œë¦¼**: 80%, 90%, 95% ì„ê³„ê°’ ë„ë‹¬ ì‹œ ìë™ ì•Œë¦¼
- **ë¯¸ë˜ ì œí•œ ì˜ˆì¸¡**: future_limit_activation_date ê¸°ë°˜ ì„ ì œì  ëŒ€ì‘
- **ë°°ìš°ë³„ ì„¸ë¶„í™”**: í˜ì´ì§€ë³„/ê³„ì •ë³„ ìƒì„¸ ë³¼ë¥¨ ë¶„ì„

#### ì§€ëŠ¥í˜• ë³¼ë¥¨ ìµœì í™”
- **ì„±ê³¼ ê¸°ë°˜ ì •ë¦¬**: ë…¸ì¶œ ì—†ëŠ” ê´‘ê³ (zero_impression) ìë™ ì‹ë³„ ë° ì •ë¦¬
- **í•™ìŠµ ì œí•œ í•´ê²°**: learning_limited ê´‘ê³  ìë™ ìµœì í™” ê¶Œì¥
- **íš¨ìœ¨ì  ì¬ë°°ì¹˜**: ë³¼ë¥¨ ì—¬ìœ  ìˆëŠ” ìº í˜ì¸/ê´‘ê³  ì„¸íŠ¸ë¡œ ì˜ˆì‚° ì¬ë°°ë¶„
- **ìë™ í†µí•©**: ì¤‘ë³µ/ë¹„íš¨ìœ¨ ê´‘ê³  ìë™ í†µí•© ë° ìµœì í™”

#### ì„ ì œì  ì œí•œ ëŒ€ì‘
- **ë¯¸ë˜ ì œí•œ ëª¨ë‹ˆí„°ë§**: í–¥í›„ ì ìš©ë  ì œí•œ ì‚¬í•­ ì‚¬ì „ ì¶”ì 
- **ìë™ ìŠ¤ì¼€ì¤„ ì¡°ì •**: ì œí•œ ì ìš© ì „ ê´‘ê³  ìŠ¤ì¼€ì¤„ ìë™ ì¬ì¡°ì •
- **ìš°ì„ ìˆœìœ„ ê¸°ë°˜ ê´€ë¦¬**: ì„±ê³¼ ê¸°ì¤€ ê´‘ê³  ìš°ì„ ìˆœìœ„ ìë™ ì¡°ì •
- **ë‹¤ì¤‘ ê³„ì • ë°¸ëŸ°ì‹±**: ì—¬ëŸ¬ ê³„ì • ê°„ ë³¼ë¥¨ ê· í˜• ìë™ ê´€ë¦¬

### 7. ë¶„í•  í…ŒìŠ¤íŠ¸ ê´€ë¦¬ ëª¨ë“ˆ (Split Testing)

#### A/B í…ŒìŠ¤íŠ¸ ìë™í™” ì‹œìŠ¤í…œ
- **í…ŒìŠ¤íŠ¸ ì„¤ê³„ ìë™í™”**: ë³€ìˆ˜ ë¶„ë¦¬ ì›ì¹™ ê¸°ë°˜ ê³¼í•™ì  í…ŒìŠ¤íŠ¸ ì„¤ê³„
- **ë‹¤ë³€ìˆ˜ í…ŒìŠ¤íŠ¸ ê´€ë¦¬**: íƒ€ê²ŸíŒ…, í¬ë¦¬ì—ì´í‹°ë¸Œ, ì˜ˆì‚° ë“± ë‹¤ì–‘í•œ ë³€ìˆ˜ ê°œë³„ í…ŒìŠ¤íŠ¸
- **ì‹¤ì‹œê°„ ì„±ê³¼ ë¹„êµ**: KPI ê¸°ë°˜ íš¨ìœ¨ì„± ì§€í‘œ ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§
- **ìë™ ì˜ì‚¬ê²°ì •**: í†µê³„ì  ìœ ì˜ì„± ê¸°ë°˜ ìŠ¹ì ì…€ ìë™ ì‹ë³„

#### í†µê³„ì  ê²€ì¦ ì‹œìŠ¤í…œ
- **í†µê³„ì  ìœ ì˜ì„± ê²€ì¦**: p-value < 0.05 ê¸°ì¤€ ìë™ ê²€ì •
- **ì‹ ë¢°êµ¬ê°„ ê³„ì‚°**: 95% ì‹ ë¢°êµ¬ê°„ ìë™ ì‚°ì¶œ ë° í•´ì„
- **ê²€ì •ë ¥ ë¶„ì„**: ìµœì†Œ ìœ íš¨ í‘œë³¸ í¬ê¸° ê³„ì‚° ë° í…ŒìŠ¤íŠ¸ ê¸°ê°„ ìµœì í™”
- **íš¨ê³¼ í¬ê¸° ì¸¡ì •**: ì‹¤ì§ˆì  ì˜ë¯¸ê°€ ìˆëŠ” ì°¨ì´ì¸ì§€ íŒë‹¨

#### ìë™ ìµœì í™” ì‹œìŠ¤í…œ
- **ìŠ¹ì ì…€ í™•ëŒ€**: í†µê³„ì  ìœ ì˜ì„± í™•ë³´ ì‹œ ìë™ ì˜ˆì‚° ì¬ë°°ë¶„
- **íŒ¨ì ì…€ ì •ì§€**: ì„±ê³¼ ê¸°ì¤€ ë¯¸ë‹¬ ì‹œ ìë™ ê´‘ê³  ì¼ì‹œì •ì§€
- **ì—°ì† í…ŒìŠ¤íŠ¸**: ìŠ¹ì ì…€ ê¸°ë°˜ í›„ì† ìµœì í™” í…ŒìŠ¤íŠ¸ ìë™ ìƒì„±
- **í•™ìŠµ ë£¨í”„**: í…ŒìŠ¤íŠ¸ ê²°ê³¼ ê¸°ë°˜ í–¥í›„ ìº í˜ì¸ ìë™ ê°œì„ 

#### í†µê³„ì  ìœ ì˜ì„± ê²€ì¦
- **ì‹ ë¢°ë„ êµ¬ê°„ ê³„ì‚°**: 95% ì‹ ë¢°êµ¬ê°„ ìë™ ê³„ì‚° ë° í•´ì„
- **p-value ë¶„ì„**: í†µê³„ì  ìœ ì˜ì„± ìë™ ê²€ì •
- **ë² ì´ì§€ì•ˆ ë¶„ì„**: ì‚¬ì „ í™•ë¥  ì—…ë°ì´íŠ¸ë¥¼ í†µí•œ ë” ì •í™•í•œ ì¶”ë¡ 
- **íš¨ê³¼ í¬ê¸° ì¸¡ì •**: ì‹¤ì§ˆì  ì˜ë¯¸ê°€ ìˆëŠ” íš¨ê³¼ì¸ì§€ íŒë‹¨

#### ì¦ë¶„ íš¨ê³¼ ì¸¡ì •
- **ìˆœìˆ˜ ì¦ë¶„ íš¨ê³¼**: ê´‘ê³ ë¡œ ì¸í•œ ì‹¤ì œ ì¶”ê°€ ì „í™˜ ì •ëŸ‰í™”
- **CPiC ê³„ì‚°**: Cost Per Incremental Conversion ìë™ ì‚°ì¶œ
- **ì¥ê¸° íš¨ê³¼ ì¶”ì **: ìº í˜ì¸ ì¢…ë£Œ í›„ ì§€ì† íš¨ê³¼ ì¸¡ì •
- **ë¸Œëœë“œ íš¨ê³¼ ë¶„ì„**: ì§ì ‘ ì „í™˜ ì™¸ ë¸Œëœë“œ ì¸ì§€ë„ ì˜í–¥ ì¸¡ì •

#### ì˜ì‚¬ê²°ì • ì§€ì› ì‹œìŠ¤í…œ
- **ìë™ ê¶Œì¥ì‚¬í•­**: í†µê³„ì  ìœ ì˜ì„± ê¸°ë°˜ ì•¡ì…˜ í”Œëœ ì œì‹œ
- **ì˜ˆì‚° ì¬ë°°ë¶„**: ì‹¤í—˜ ê²°ê³¼ ê¸°ë°˜ ì‹¤ì‹œê°„ ì˜ˆì‚° ìµœì í™”
- **ìº í˜ì¸ ì œì–´**: ì„±ê³¼ ê¸°ì¤€ì— ë”°ë¥¸ ìë™ ìº í˜ì¸ ì¡°ì •
- **ë¦¬ìŠ¤í¬ ê´€ë¦¬**: ì‹¤í—˜ ì‹¤íŒ¨ ì‹œ ìë™ ë¡¤ë°± ì‹œìŠ¤í…œ

### 8. ì¶”ì  ë° ì „í™˜ ê´€ë¦¬ ì‹œìŠ¤í…œ

#### ì¶”ì  ì‚¬ì–‘ ê´€ë¦¬
- **í…œí”Œë¦¿ ë¼ì´ë¸ŒëŸ¬ë¦¬**: ê´‘ê³  ëª©í‘œë³„ ê¸°ë³¸ ì¶”ì  ì‚¬ì–‘ í…œí”Œë¦¿
- **ì»¤ìŠ¤í…€ ë¹Œë”**: ì‚¬ìš©ì ì •ì˜ ì¶”ì  ì‚¬ì–‘ ìƒì„± ë„êµ¬
- **ë‹¤ì¤‘ ì¶”ì **: ì—¬ëŸ¬ í”½ì…€/ì´ë²¤íŠ¸ ë™ì‹œ ì¶”ì  ì„¤ì •

#### ì „í™˜ í¼ë„ ë¶„ì„
- **ë‹¨ê³„ë³„ ë¶„ì„**: ë…¸ì¶œ â†’ í´ë¦­ â†’ ì „í™˜ ê° ë‹¨ê³„ ì„±ê³¼
- **ì´íƒˆ ì§€ì  ì‹ë³„**: ì „í™˜ìœ¨ì´ ë–¨ì–´ì§€ëŠ” êµ¬ê°„ íŒŒì•…
- **ìµœì í™” ì œì•ˆ**: í¼ë„ ê°œì„ ì„ ìœ„í•œ ì•¡ì…˜ í”Œëœ

#### ì„±ê³¼ ì¸¡ì • í™•ì¥
- **í–‰ë™ë³„ ë¦¬í¬íŒ…**: ì¶”ì ëœ ëª¨ë“  í–‰ë™ì˜ ì„¸ë¶„í™”ëœ ë¶„ì„
- **ì „í™˜ ê°€ì¹˜ ì¶”ì **: ë§¤ì¶œ ê¸°ë°˜ ROI/ROAS ì •í™•í•œ ê³„ì‚°
- **ì–´íŠ¸ë¦¬ë·°ì…˜ ëª¨ë¸ë§**: ë‹¤ì–‘í•œ ì–´íŠ¸ë¦¬ë·°ì…˜ ëª¨ë¸ ì ìš©

### 9. ê´‘ê³  ê·œì¹™ ì—”ì§„ ëª¨ë“ˆ (Ad Rules Engine)

#### ì¤‘ì•™ ê·œì¹™ ê´€ë¦¬ ì‹œìŠ¤í…œ
- **í†µí•© ê·œì¹™ ëŒ€ì‹œë³´ë“œ**: ëª¨ë“  ìë™í™” ê·œì¹™ì˜ ì¤‘ì•™ ê´€ë¦¬ ë° ëª¨ë‹ˆí„°ë§
- **ê·œì¹™ í…œí”Œë¦¿ ë¼ì´ë¸ŒëŸ¬ë¦¬**: ì—…ì¢…ë³„/ëª©í‘œë³„ ì‚¬ì „ ì •ì˜ëœ ê·œì¹™ í…œí”Œë¦¿
- **ì‹œê°ì  ê·œì¹™ ë¹Œë”**: ë“œë˜ê·¸ ì•¤ ë“œë¡­ ë°©ì‹ì˜ ì§ê´€ì  ê·œì¹™ ìƒì„± ë„êµ¬
- **ê·œì¹™ ì‹œë®¬ë ˆì´ì…˜**: ì ìš© ì „ ê·œì¹™ì˜ ì˜ˆìƒ íš¨ê³¼ ë¯¸ë¦¬ë³´ê¸°

#### ì´ì¤‘ ì‹¤í–‰ ëª¨ë“œ ì‹œìŠ¤í…œ

**ìŠ¤ì¼€ì¤„ ê¸°ë°˜ ì‹¤í–‰ (Schedule-Based Rules)**
- **DAILY**: ê´‘ê³  ê³„ì • ì‹œê°„ëŒ€ ìì • ì‹¤í–‰
- **HOURLY**: ë§¤ì‹œê°„ ì •ì‹œ ì‹¤í–‰
- **SEMI_HOURLY**: 30ë¶„ ê°„ê²© ì‹¤í–‰
- **CUSTOM**: ì •êµí•œ ë§ì¶¤ ìŠ¤ì¼€ì¤„
  - start_minute/end_minute: ì •í™•í•œ ì‹¤í–‰ ì‹œê°„ ì œì–´ (30ë¶„ ë‹¨ìœ„)
  - days: íŠ¹ì • ìš”ì¼ ì§€ì • (0=ì¼ìš”ì¼, 6=í† ìš”ì¼)
  - ì‹œê°„ ë²”ìœ„ ë° ë‹¤ì¤‘ ìŠ¤ì¼€ì¤„ ì¡°í•© ì§€ì›

**íŠ¸ë¦¬ê±° ê¸°ë°˜ ì‹¤í–‰ (Trigger-Based Rules) - ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§**
- **METADATA_CREATION**: ê´‘ê³  ê°ì²´ ìƒì„± ì¦‰ì‹œ íŠ¸ë¦¬ê±°
- **METADATA_UPDATE**: ë©”íƒ€ë°ì´í„° ë³€ê²½ ì‹œ íŠ¸ë¦¬ê±° (ëŒ€ê¸°ì‹œê°„: ëª‡ ì´ˆ)
- **STATS_CHANGE**: ì¸ì‚¬ì´íŠ¸ ë°ì´í„° falseâ†’true ë³€í™” ì‹œ íŠ¸ë¦¬ê±° (ëŒ€ê¸°ì‹œê°„: ~7.5ë¶„)
- **STATS_MILESTONE**: íŠ¹ì • ê°’ì˜ ë°°ìˆ˜ ë„ë‹¬ ì‹œ íŠ¸ë¦¬ê±° (impressionsâ‰¥1000, clicksâ‰¥10 ë“±)
- **DELIVERY_INSIGHTS_CHANGE**: ê²Œì¬ ìµœì í™” ì¸ì‚¬ì´íŠ¸ ë³€ê²½ ì‹œ íŠ¸ë¦¬ê±° (ë² íƒ€)

**ê³ ê¸‰ íŠ¸ë¦¬ê±° ì œì–´**
- **debounce_time**: ì¤‘ë³µ ì‹¤í–‰ ë°©ì§€ë¥¼ ìœ„í•œ ëŒ€ê¸° ì‹œê°„
- **operator ì§€ì›**: GREATER_THAN, LESS_THAN, IN_RANGE, NOT_IN_RANGE
- **ë³µí•© ì¡°ê±´**: íŠ¸ë¦¬ê±° + í•„í„°ì˜ ë…¼ë¦¬ì  AND ì¡°í•©

#### ê³ ê¸‰ ì¡°ê±´ í•„í„°ë§ ì‹œìŠ¤í…œ
- **ë©”íƒ€ë°ì´í„° í•„í„°**: ìº í˜ì¸ëª…, ê´‘ê³  ì„¸íŠ¸ëª…, íƒœê·¸ ë“± ê¸°ë³¸ ì •ë³´ ê¸°ë°˜ ì¡°ê±´
- **ì¸ì‚¬ì´íŠ¸ ë°ì´í„° í•„í„°**: CPA, ROAS, CTR, ì „í™˜ìœ¨ ë“± ì„±ê³¼ ì§€í‘œ ê¸°ë°˜ ì¡°ê±´
- **ë³µí•© ì¡°ê±´**: AND/OR ë…¼ë¦¬ ì—°ì‚°ìë¥¼ í™œìš©í•œ ë³µì¡í•œ ì¡°ê±´ ì¡°í•©
- **ë™ì  ì„ê³„ê°’**: ê³¼ê±° ì„±ê³¼ ëŒ€ë¹„ ìƒëŒ€ì  ì„ê³„ê°’ ë° ì‹œì¥ ë²¤ì¹˜ë§ˆí¬ ë¹„êµ

#### ìë™ ì•¡ì…˜ ì‹¤í–‰ ì‹œìŠ¤í…œ (9ê°€ì§€ ì‹¤í–‰ ìœ í˜•)

**Meta ê³µì‹ ì‹¤í–‰ ìœ í˜• ì™„ì „ ì§€ì›**
- **NOTIFICATION**: ê°•ì¡°ëœ ì•Œë¦¼ ì „ì†¡ ë° ì¼ì¼ ìš”ì•½ ì´ë©”ì¼
- **PAUSE/UNPAUSE**: ê´‘ê³  ê°ì²´ ì¼ì‹œì •ì§€ ë° ì¬ê°œ
- **CHANGE_BUDGET**: ê´‘ê³  ì„¸íŠ¸ ì˜ˆì‚° ë™ì  ì¡°ì •
- **CHANGE_CAMPAIGN_BUDGET**: ìº í˜ì¸ ì˜ˆì‚° ë™ì  ì¡°ì •
- **CHANGE_BID**: ê´‘ê³  ì„¸íŠ¸ ì…ì°°ê°€ ë™ì  ì¡°ì •
- **ROTATE**: ê´‘ê³  ìˆœí™˜ ì‹œìŠ¤í…œ (í™œì„± ê´‘ê³  ì¼ì‹œì •ì§€ â†’ ë‹¤ìŒ ê´‘ê³  í™œì„±í™”)
- **REBALANCE_BUDGET**: ì§€ëŠ¥í˜• ì˜ˆì‚° ì¬ë°°ë¶„ ì‹œìŠ¤í…œ
- **PING_ENDPOINT**: Webhook ì—°ë™ì„ í†µí•œ ì™¸ë¶€ ì‹œìŠ¤í…œ ì•Œë¦¼

**ê³ ê¸‰ ì‹¤í–‰ ì œì–´ ì˜µì…˜**
- **execution_count_limit**: ê°œë³„ ê´‘ê³ ë³„ ìµœëŒ€ ì‹¤í–‰ íšŸìˆ˜ ì œí•œ
- **action_frequency**: ë™ì¼ ì•¡ì…˜ ê°„ ìµœì†Œ ëŒ€ê¸° ì‹œê°„ (ë¶„ ë‹¨ìœ„)
- **user_ids**: ì•Œë¦¼ ìˆ˜ì‹ ì ë° ì¼ì¼ ìš”ì•½ ì´ë©”ì¼ êµ¬ë…ì ì„¤ì •
- **change_spec**: ì •êµí•œ ì˜ˆì‚°/ì…ì°°ê°€ ë³€ê²½ ì‚¬ì–‘ (amount, limit, unit, target_field)

#### ìŠ¤ë§ˆíŠ¸ í•™ìŠµ ì‹œìŠ¤í…œ
- **ì„±ê³¼ íŒ¨í„´ í•™ìŠµ**: ê³¼ê±° ê·œì¹™ ì‹¤í–‰ ê²°ê³¼ë¥¼ í•™ìŠµí•˜ì—¬ ì„ê³„ê°’ ìë™ ì¡°ì •
- **ê³„ì ˆì„± ì¸ì‹**: ì‹œì¦Œ, ìš”ì¼, ì‹œê°„ëŒ€ë³„ ì„±ê³¼ íŒ¨í„´ ì¸ì‹ ë° ì ìš©
- **ì˜ˆì™¸ ìƒí™© ì²˜ë¦¬**: íŠ¹ìˆ˜ ì´ë²¤íŠ¸, í”„ë¡œëª¨ì…˜ ê¸°ê°„ ë“± ì˜ˆì™¸ ìƒí™© ìë™ ê°ì§€
- **A/B í…ŒìŠ¤íŠ¸ í†µí•©**: ê·œì¹™ íš¨ê³¼ì„±ì„ ìœ„í•œ ìë™ A/B í…ŒìŠ¤íŠ¸ ì‹¤í–‰

#### ê·œì¹™ ëª¨ë‹ˆí„°ë§ ë° ê±°ë²„ë„ŒìŠ¤
- **ì‹¤í–‰ ë¡œê·¸**: ëª¨ë“  ê·œì¹™ ì‹¤í–‰ì˜ ìƒì„¸ ê¸°ë¡ ë° ì¶”ì 
- **ì„±ê³¼ ë¶„ì„**: ê·œì¹™ë³„ ROI ë° íš¨ê³¼ì„± ì¸¡ì •
- **ì•ˆì „ì¥ì¹˜**: ê³¼ë„í•œ ë³€ê²½ ë°©ì§€ë¥¼ ìœ„í•œ ì•ˆì „ ì„ê³„ê°’ ì„¤ì •
- **ìŠ¹ì¸ ì›Œí¬í”Œë¡œìš°**: ì¤‘ìš” ê·œì¹™ì˜ ìˆ˜ë™ ìŠ¹ì¸ í”„ë¡œì„¸ìŠ¤

#### ì‹¤ë¬´ ê·œì¹™ ì˜ˆì‹œ (Meta API ê³µì‹ ì‚¬ì–‘ ê¸°ë°˜)

**1. ìŠ¤ì¼€ì¤„ ê¸°ë°˜ ì˜ˆì‚° ì¡°ì • ê·œì¹™ (CHANGE_BUDGET)**
```json
{
  "name": "High Frequency Budget Reducer",
  "schedule_spec": {
    "schedule_type": "CUSTOM",
    "schedule": [
      {
        "start_minute": 0,
        "days": [2, 5]  // í™”ìš”ì¼, ê¸ˆìš”ì¼ ìì •
      }
    ]
  },
  "evaluation_spec": {
    "evaluation_type": "SCHEDULE",
    "filters": [
      {
        "field": "entity_type",
        "value": "ADSET",
        "operator": "EQUAL"
      },
      {
        "field": "time_preset",
        "value": "LIFETIME",
        "operator": "EQUAL"
      },
      {
        "field": "impressions",
        "value": 8000,
        "operator": "GREATER_THAN"
      },
      {
        "field": "frequency",
        "value": 5.0,
        "operator": "GREATER_THAN"
      }
    ]
  },
  "execution_spec": {
    "execution_type": "CHANGE_BUDGET",
    "execution_options": [
      {
        "field": "change_spec",
        "value": {
          "amount": -30,
          "unit": "PERCENTAGE"
        },
        "operator": "EQUAL"
      },
      {
        "field": "execution_count_limit",
        "value": 5,
        "operator": "EQUAL"
      },
      {
        "field": "action_frequency",
        "value": 10080,  // 1ì£¼ì¼ ê°„ê²©
        "operator": "EQUAL"
      }
    ]
  }
}
```

**2. target_field ê¸°ë°˜ ë™ì  ì…ì°°ê°€ ì¡°ì • ê·œì¹™ (CHANGE_BID)**
```json
{
  "name": "Dynamic CPA Bid Adjustment",
  "schedule_spec": {
    "schedule_type": "DAILY"
  },
  "evaluation_spec": {
    "evaluation_type": "SCHEDULE",
    "filters": [
      {
        "field": "id",
        "value": [123, 456, 789],
        "operator": "IN"
      },
      {
        "field": "time_preset",
        "value": "LIFETIME",
        "operator": "EQUAL"
      },
      {
        "field": "mobile_app_install",
        "value": 100,
        "operator": "GREATER_THAN"
      },
      {
        "field": "cost_per_mobile_app_install",
        "value": [4.5, 5.5],
        "operator": "NOT_IN_RANGE"  // 10% í—ˆìš© ì˜¤ì°¨ ë²”ìœ„
      }
    ]
  },
  "execution_spec": {
    "execution_type": "CHANGE_BID",
    "execution_options": [
      {
        "field": "change_spec",
        "value": {
          "amount": 5.0,                    // ëª©í‘œ CPA $5.0
          "limit": [2.0, 10.0],            // ì…ì°°ê°€ ë²”ìœ„ ì œí•œ
          "target_field": "cost_per_mobile_app_install"
        },
        "operator": "EQUAL"
      }
    ]
  }
}
```

**3. íŠ¸ë¦¬ê±° ê¸°ë°˜ ì‹¤ì‹œê°„ ì•Œë¦¼ ê·œì¹™ (STATS_CHANGE)**
```json
{
  "name": "High CPA Real-time Alert",
  "evaluation_spec": {
    "evaluation_type": "TRIGGER",
    "trigger": {
      "type": "STATS_CHANGE",
      "field": "cost_per_purchase_fb",
      "value": 1000,  // $10.00 = 1000 ì„¼íŠ¸
      "operator": "GREATER_THAN"
    },
    "filters": [
      {
        "field": "entity_type",
        "value": "AD",
        "operator": "EQUAL"
      },
      {
        "field": "time_preset",
        "value": "LAST_3_DAYS",
        "operator": "EQUAL"
      },
      {
        "field": "reach",
        "value": 5000,
        "operator": "GREATER_THAN"
      }
    ]
  },
  "execution_spec": {
    "execution_type": "PAUSE",
    "execution_options": [
      {
        "field": "user_ids",
        "value": [123456, 789012],
        "operator": "EQUAL"
      }
    ]
  }
}
```

**4. ë©”íƒ€ë°ì´í„° ìƒì„± ëª¨ë‹ˆí„°ë§ ê·œì¹™ (METADATA_CREATION)**
```json
{
  "name": "New Ad Creation Monitor",
  "evaluation_spec": {
    "evaluation_type": "TRIGGER",
    "trigger": {
      "type": "METADATA_CREATION"
    },
    "filters": [
      {
        "field": "entity_type",
        "value": "AD",
        "operator": "EQUAL"
      },
      {
        "field": "campaign.objective",
        "value": ["APP_INSTALLS"],
        "operator": "IN"
      }
    ]
  },
  "execution_spec": {
    "execution_type": "PING_ENDPOINT"
  }
}
```

**5. í†µê³„ ë§ˆì¼ìŠ¤í†¤ ê·œì¹™ (STATS_MILESTONE)**
```json
{
  "name": "Comment Milestone Tracker",
  "evaluation_spec": {
    "evaluation_type": "TRIGGER",
    "trigger": {
      "type": "STATS_MILESTONE",
      "field": "post_comment",
      "value": 1,
      "operator": "EQUAL"
    },
    "filters": [
      {
        "field": "entity_type",
        "value": "CAMPAIGN",
        "operator": "EQUAL"
      },
      {
        "field": "time_preset",
        "value": "LIFETIME",
        "operator": "EQUAL"
      }
    ]
  },
  "execution_spec": {
    "execution_type": "NOTIFICATION",
    "execution_options": [
      {
        "field": "user_ids",
        "value": [123456],
        "operator": "EQUAL"
      }
    ]
  }
}
```

**6. ì˜ˆì‚° ì¬ì¡°ì • ê·œì¹™ (REBALANCE_BUDGET)**
```json
{
  "name": "Smart Budget Rebalancing",
  "schedule_spec": {
    "schedule_type": "DAILY"
  },
  "evaluation_spec": {
    "evaluation_type": "SCHEDULE",
    "filters": [
      {
        "field": "entity_type",
        "value": "ADSET",
        "operator": "EQUAL"
      },
      {
        "field": "effective_status",
        "value": ["ACTIVE"],
        "operator": "IN"
      },
      {
        "field": "frequency",
        "value": 4.0,
        "operator": "GREATER_THAN"
      }
    ]
  },
  "execution_spec": {
    "execution_type": "REBALANCE_BUDGET",
    "execution_options": [
      {
        "field": "rebalance_spec",
        "value": {
          "rebalance_method": "PROPORTIONAL",
          "performance_metric": "cost_per_result",
          "rebalance_threshold": 0.8
        },
        "operator": "EQUAL"
      }
    ]
  }
}
```

**7. ê³ ê¸‰ í•„í„°ë§ ì§‘ê³„ ê·œì¹™ (AGGREGATE)**
```json
{
  "name": "Multi-Ad Reach Optimization",
  "schedule_spec": {
    "schedule_type": "CUSTOM",
    "schedule": [
      {
        "start_minute": 390,  // ì˜¤ì „ 6ì‹œ 30ë¶„
        "days": [1, 3, 5]     // ì›”, ìˆ˜, ê¸ˆ
      }
    ]
  },
  "evaluation_spec": {
    "evaluation_type": "SCHEDULE",
    "filters": [
      {
        "field": "aggregation_id",
        "value": [1234, 5678, 9012],
        "operator": "IN"
      },
      {
        "field": "aggregate(reach)",
        "value": 50000,
        "operator": "GREATER_THAN"
      },
      {
        "field": "aggregate(frequency)",
        "value": 3.5,
        "operator": "GREATER_THAN"
      }
    ]
  },
  "execution_spec": {
    "execution_type": "CHANGE_BUDGET",
    "execution_options": [
      {
        "field": "change_spec",
        "value": {
          "amount": -15,
          "unit": "PERCENTAGE"
        },
        "operator": "EQUAL"
      }
    ]
  }
}
```

**8. ê³µì‹ í•„ë“œ í™œìš© íš¨ìœ¨ì„± ê·œì¹™ (FORMULA)**
```json
{
  "name": "Budget Utilization Efficiency",
  "schedule_spec": {
    "schedule_type": "DAILY"
  },
  "evaluation_spec": {
    "evaluation_type": "SCHEDULE",
    "filters": [
      {
        "field": "entity_type",
        "value": "ADSET",
        "operator": "EQUAL"
      },
      {
        "field": "today_spent / adset.daily_budget",
        "value": 0.9,
        "operator": "GREATER_THAN"
      },
      {
        "field": "0.7 * cost_per_result + 0.3 * frequency",
        "value": 8.0,
        "operator": "LESS_THAN"
      }
    ]
  },
  "execution_spec": {
    "execution_type": "CHANGE_BUDGET",
    "execution_options": [
      {
        "field": "change_spec",
        "value": {
          "amount": 25,
          "unit": "PERCENTAGE"
        },
        "operator": "EQUAL"
      }
    ]
  }
}
```

**9. í”„ë¦¬í”½ìŠ¤ ì¸ì‚¬ì´íŠ¸ ê³ ê¸‰ í•„í„°ë§ (PREFIXED_INSIGHTS)**
```json
{
  "name": "Campaign Level Performance Monitor",
  "schedule_spec": {
    "schedule_type": "SEMI_HOURLY"
  },
  "evaluation_spec": {
    "evaluation_type": "SCHEDULE",
    "filters": [
      {
        "field": "entity_type",
        "value": "AD",
        "operator": "EQUAL"
      },
      {
        "field": "campaign.28d_view_7d_click:last_7d_spent",
        "value": 5000,
        "operator": "GREATER_THAN"
      },
      {
        "field": "adset.yesterday_cost_per_result",
        "value": 12.0,
        "operator": "GREATER_THAN"
      }
    ]
  },
  "execution_spec": {
    "execution_type": "PAUSE"
  }
}
```

**10. Webhook í†µí•© PING_ENDPOINT ê·œì¹™**
```json
{
  "name": "Real-time Performance Alert System",
  "evaluation_spec": {
    "evaluation_type": "TRIGGER",
    "trigger": {
      "type": "STATS_CHANGE",
      "field": "cost_per_purchase",
      "value": 2000,  // $20.00 = 2000 ì„¼íŠ¸
      "operator": "GREATER_THAN"
    },
    "filters": [
      {
        "field": "entity_type",
        "value": "ADSET",
        "operator": "EQUAL"
      },
      {
        "field": "time_preset",
        "value": "TODAY",
        "operator": "EQUAL"
      },
      {
        "field": "purchases",
        "value": 10,
        "operator": "GREATER_THAN"
      }
    ]
  },
  "execution_spec": {
    "execution_type": "PING_ENDPOINT",
    "execution_options": [
      {
        "field": "webhook_url",
        "value": "https://api.example.com/alerts/meta-rules",
        "operator": "EQUAL"
      },
      {
        "field": "payload_template",
        "value": {
          "alert_type": "high_cpa",
          "object_id": "{object_id}",
          "current_cpa": "{cost_per_purchase}",
          "threshold": 2000,
          "timestamp": "{execution_time}"
        },
        "operator": "EQUAL"
      }
    ]
  }
}
```

**11. ë³µí•© ìŠ¤ì¼€ì¤„ ì‹¤í–‰ ê·œì¹™ (COMPLEX_SCHEDULE)**
```json
{
  "name": "Business Hours Campaign Optimization",
  "schedule_spec": {
    "schedule_type": "CUSTOM",
    "schedule": [
      {
        "start_minute": 540,   // ì˜¤ì „ 9ì‹œ
        "end_minute": 1080,    // ì˜¤í›„ 6ì‹œ
        "days": [1, 2, 3, 4, 5] // í‰ì¼
      },
      {
        "start_minute": 720,   // ì˜¤í›„ 12ì‹œ
        "end_minute": 840,     // ì˜¤í›„ 2ì‹œ
        "days": [0, 6]         // ì£¼ë§
      }
    ]
  },
  "evaluation_spec": {
    "evaluation_type": "SCHEDULE",
    "filters": [
      {
        "field": "entity_type",
        "value": "CAMPAIGN",
        "operator": "EQUAL"
      },
      {
        "field": "objective",
        "value": ["CONVERSIONS", "LEAD_GENERATION"],
        "operator": "IN"
      },
      {
        "field": "last_3d_cost_per_result",
        "value": 15.0,
        "operator": "LESS_THAN"
      }
    ]
  },
  "execution_spec": {
    "execution_type": "CHANGE_CAMPAIGN_BUDGET",
    "execution_options": [
      {
        "field": "change_spec",
        "value": {
          "amount": 20,
          "unit": "PERCENTAGE",
          "limit": [1000, 50000]  // $10 - $500 ë²”ìœ„
        },
        "operator": "EQUAL"
      }
    ]
  }
}
```

**12. ROAS ê¸°ë°˜ ë™ì  ìµœì í™” ê·œì¹™ (ROAS_OPTIMIZATION)**
```json
{
  "name": "Dynamic ROAS Target Adjustment",
  "schedule_spec": {
    "schedule_type": "DAILY"
  },
  "evaluation_spec": {
    "evaluation_type": "SCHEDULE",
    "filters": [
      {
        "field": "id",
        "value": [123, 456, 789],
        "operator": "IN"
      },
      {
        "field": "time_preset",
        "value": "LAST_ND_14_8",
        "operator": "EQUAL"
      },
      {
        "field": "attribution_window",
        "value": "7D_VIEW_1D_CLICK",
        "operator": "EQUAL"
      },
      {
        "field": "hours_since_creation",
        "value": 168,  // 7ì¼
        "operator": "GREATER_THAN"
      },
      {
        "field": "website_purchase_roas",
        "value": [0.95, 1.05],  // Â±5% í—ˆìš© ë²”ìœ„
        "operator": "NOT_IN_RANGE"
      }
    ]
  },
  "execution_spec": {
    "execution_type": "CHANGE_BID",
    "execution_options": [
      {
        "field": "change_spec",
        "value": {
          "amount": 1.0,  // ëª©í‘œ ROAS 1.0
          "target_field": "website_purchase_roas",
          "limit": [0.5, 5.0]  // ì…ì°°ê°€ ì¡°ì • ë²”ìœ„
        },
        "operator": "EQUAL"
      },
      {
        "field": "execution_count_limit",
        "value": 3,
        "operator": "EQUAL"
      },
      {
        "field": "action_frequency",
        "value": 1440,  // 24ì‹œê°„ ê°„ê²©
        "operator": "EQUAL"
      }
    ]
  }
}
```

---

## ğŸ›ï¸ ê¸°ìˆ  ì•„í‚¤í…ì²˜

### ì ì‘í˜• Rate Limiting ì‹œìŠ¤í…œ

#### ë™ì  ì¡°ì ˆ ì•Œê³ ë¦¬ì¦˜
```typescript
interface RateLimitConfig {
  appUtilThreshold: number;    // app_id_util_pct ì„ê³„ê°’
  accUtilThreshold: number;    // acc_id_util_pct ì„ê³„ê°’
  backoffMultiplier: number;   // ë°±ì˜¤í”„ ë°°ìˆ˜
  maxRetries: number;          // ìµœëŒ€ ì¬ì‹œë„
}

class AdaptiveThrottler {
  adjustRequestInterval(utilization: number): number {
    if (utilization > 90) return 5000;  // 5ì´ˆ ëŒ€ê¸°
    if (utilization > 80) return 3000;  // 3ì´ˆ ëŒ€ê¸°
    if (utilization > 70) return 1000;  // 1ì´ˆ ëŒ€ê¸°
    return 500;  // ê¸°ë³¸ 500ms
  }
}
```

### 3ë‹¨ê³„ ìºì‹± ì‹œìŠ¤í…œ

#### ê³„ì¸µë³„ ìºì‹± ì „ëµ
- **L1 - Memory Cache**: ì´ˆë‹¨ê¸° ë°ì´í„° (1-5ë¶„)
- **L2 - Redis**: ë‹¨ê¸° ë°ì´í„° (1-24ì‹œê°„)
- **L3 - Database**: ì¥ê¸° ë°ì´í„° (1ì¼-1ë…„)

#### ìºì‹œ ë¬´íš¨í™” ì „ëµ
- **TTL ê¸°ë°˜**: ì‹œê°„ ê¸°ë°˜ ìë™ ë§Œë£Œ
- **ì´ë²¤íŠ¸ ê¸°ë°˜**: ë°ì´í„° ë³€ê²½ ì‹œ ì¦‰ì‹œ ë¬´íš¨í™”
- **LRU ì •ì±…**: ë©”ëª¨ë¦¬ ì••ë°• ì‹œ ìµœê·¼ ì‚¬ìš©ë„ ê¸°ë°˜ ì œê±°

### ë¹„ë™ê¸° ì‘ì—… ì²˜ë¦¬ ì‹œìŠ¤í…œ

#### Job Queue Architecture
```typescript
interface AsyncJob {
  id: string;
  type: 'COMPLEX_QUERY' | 'BULK_OPERATION' | 'REPORT_GENERATION' | 'MMM_COLLECTION' | 'LIFT_STUDY';
  payload: any;
  priority: 'HIGH' | 'MEDIUM' | 'LOW';
  retryCount: number;
  status: 'PENDING' | 'RUNNING' | 'COMPLETED' | 'FAILED';
}

class JobManager {
  async processComplexQuery(query: InsightsQuery): Promise<JobResult> {
    // 13ê°œì›” ì´ˆê³¼ ë°ì´í„° ì²˜ë¦¬
    // ë³µì¡í•œ breakdown ì¡°í•© ìµœì í™”
    // ë°°ì¹˜ ì²˜ë¦¬ë¡œ API í˜¸ì¶œ ìµœì†Œí™”
  }

  async processMMMCollection(businessId: string): Promise<MMMJobResult> {
    // ë¹„ì¦ˆë‹ˆìŠ¤ ê´€ë¦¬ì ìˆ˜ì¤€ MMM ë°ì´í„° ìˆ˜ì§‘
    // ë‹¤ì¤‘ ê³„ì • ìˆœì°¨ ì²˜ë¦¬
    // CSV ë‚´ë³´ë‚´ê¸° ìµœì í™”
    // ëŒ€ìš©ëŸ‰ ë°ì´í„° ìŠ¤íŠ¸ë¦¬ë° ì²˜ë¦¬
  }

  async processLiftStudy(studyConfig: LiftStudyConfig): Promise<LiftStudyJobResult> {
    // Lift Study ìƒì„± ë° ê´€ë¦¬
    // ì‹¤í—˜ ì§„í–‰ ìƒí™© ëª¨ë‹ˆí„°ë§
    // ê²°ê³¼ ë¶„ì„ ë° í†µê³„ì  ê²€ì¦
    // ìë™ ê¶Œì¥ì‚¬í•­ ìƒì„±
  }

  async processSplitTest(testConfig: SplitTestConfig): Promise<SplitTestJobResult> {
    // Split Test ìƒì„± ë° ê´€ë¦¬
    // í…ŒìŠ¤íŠ¸ ì§„í–‰ ìƒí™© ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§
    // í†µê³„ì  ìœ ì˜ì„± ìë™ ê²€ì¦
    // ìŠ¹ì ì…€ ì‹ë³„ ë° ìë™ ìµœì í™”
    // ì—°ì† í…ŒìŠ¤íŠ¸ ìë™ ìƒì„±
  }

  async processVolumeOptimization(accountId: string): Promise<VolumeOptimizationJobResult> {
    // ê´‘ê³  ë³¼ë¥¨ ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§
    // ì„ê³„ê°’ ê¸°ë°˜ ìë™ ì•Œë¦¼ ë° ìµœì í™”
    // ì„±ê³¼ ê¸°ë°˜ ê´‘ê³  ì •ë¦¬ ë° í†µí•©
    // ë¯¸ë˜ ì œí•œ ì˜ˆì¸¡ ë° ì„ ì œì  ëŒ€ì‘
    // ë‹¤ì¤‘ ê³„ì • ë³¼ë¥¨ ë°¸ëŸ°ì‹±
  }
}
```

### ê´‘ê³  ë³¼ë¥¨ ê´€ë¦¬ ì‹œìŠ¤í…œ

#### ë³¼ë¥¨ ëª¨ë‹ˆí„°ë§ ì—”ì§„
```typescript
interface VolumeMonitoringConfig {
  accountId: string;
  pageIds?: string[];
  thresholds: {
    warning: number;    // 80% ê²½ê³ 
    critical: number;   // 90% ìœ„í—˜
    emergency: number;  // 95% ê¸´ê¸‰
  };
  monitoringInterval: number; // ë¶„ ë‹¨ìœ„
}

class VolumeMonitoringEngine {
  async startContinuousMonitoring(config: VolumeMonitoringConfig): Promise<void> {
    // 1. ì‹¤ì‹œê°„ ë³¼ë¥¨ ìƒíƒœ ì¶”ì 
    const monitoringLoop = setInterval(async () => {
      const volumeStatus = await this.checkVolumeStatus(config.accountId);

      // 2. ì„ê³„ê°’ ê¸°ë°˜ ì•Œë¦¼ ìƒì„±
      const alerts = this.generateThresholdAlerts(volumeStatus, config.thresholds);

      // 3. ìë™ ëŒ€ì‘ ì•¡ì…˜ ì‹¤í–‰
      if (alerts.length > 0) {
        await this.executeEmergencyActions(alerts, volumeStatus);
      }
    }, config.monitoringInterval * 60 * 1000);
  }

  async executeEmergencyActions(alerts: VolumeAlert[], status: VolumeStatus): Promise<void> {
    for (const alert of alerts) {
      switch (alert.severity) {
        case 'emergency':
          await this.pauseLowPerformingAds(status.accountId);
          break;
        case 'critical':
          await this.consolidateSimilarAds(status.accountId);
          break;
        case 'warning':
          await this.flagForReview(status.accountId);
          break;
      }
    }
  }
}
```

#### ìë™ ë³¼ë¥¨ ìµœì í™” ì‹œìŠ¤í…œ
```typescript
interface VolumeOptimizationStrategy {
  type: 'zero_impression_cleanup' | 'learning_limited_fix' | 'campaign_consolidation' | 'budget_redistribution';
  priority: number;
  automationLevel: 'automatic' | 'assisted' | 'manual';
}

class AutoVolumeOptimizer {
  async optimizeAccountVolume(accountId: string): Promise<OptimizationReport> {
    // 1. í˜„ì¬ ìƒíƒœ ë¶„ì„
    const analysis = await this.analyzeVolumeEfficiency(accountId);

    // 2. ìµœì í™” ì „ëµ ìˆ˜ë¦½
    const strategies = this.planOptimizationStrategies(analysis);

    // 3. ìë™ ìµœì í™” ì‹¤í–‰
    const results = await this.executeOptimizations(strategies);

    return {
      beforeOptimization: analysis.currentState,
      afterOptimization: analysis.projectedState,
      actionsExecuted: results.actions,
      volumeReduction: results.volumeReduction,
      performanceImpact: results.performanceImpact
    };
  }

  async handleZeroImpressionAds(accountId: string): Promise<CleanupResult> {
    // ë…¸ì¶œ ì—†ëŠ” ê´‘ê³  ìë™ ì‹ë³„ ë° ì •ë¦¬
    const zeroImpressionAds = await this.identifyZeroImpressionAds(accountId);

    // ì„±ê³¼ ê¸°ë¡ ë¶„ì„ í›„ ì•ˆì „í•œ ê´‘ê³ ë§Œ ì •ë¦¬
    const safeToRemove = this.filterSafeToRemoveAds(zeroImpressionAds);

    // ìë™ ì •ë¦¬ ì‹¤í–‰
    const cleanupResults = await this.pauseAds(safeToRemove);

    return {
      totalAdsAnalyzed: zeroImpressionAds.length,
      adsPaused: cleanupResults.length,
      volumeReduction: cleanupResults.length,
      estimatedPerformanceImpact: 'none'
    };
  }
}
```

### ë¶„í•  í…ŒìŠ¤íŠ¸ ê´€ë¦¬ ì‹œìŠ¤í…œ

#### í…ŒìŠ¤íŠ¸ ë¼ì´í”„ì‚¬ì´í´ ê´€ë¦¬
```typescript
interface SplitTestLifecycle {
  testId: string;
  businessId: string;
  status: 'DRAFT' | 'PENDING' | 'ACTIVE' | 'COMPLETED' | 'FAILED';
  createdAt: Date;
  startTime: Date;
  endTime: Date;
  cells: SplitTestCell[];
  results?: SplitTestResults[];
}

class SplitTestOrchestrator {
  async manageSplitTestLifecycle(testId: string): Promise<void> {
    // 1. í…ŒìŠ¤íŠ¸ ìƒíƒœ ëª¨ë‹ˆí„°ë§
    const test = await this.getTestStatus(testId);

    // 2. í…ŒìŠ¤íŠ¸ ë‹¨ê³„ë³„ ìë™ ì²˜ë¦¬
    switch (test.status) {
      case 'ACTIVE':
        await this.monitorActiveTest(testId);
        break;
      case 'COMPLETED':
        await this.processCompletedTest(testId);
        break;
    }

    // 3. ìë™ ìµœì í™” ë° í™•ì¥
    await this.applyOptimizations(testId);
  }

  async optimizeTestDesign(config: SplitTestConfig): Promise<OptimizedSplitTestConfig> {
    // í†µê³„ì  ê²€ì •ë ¥ ê³„ì‚°
    const power = this.calculateStatisticalPower(config);

    // ìµœì†Œ í‘œë³¸ í¬ê¸° ê³„ì‚°
    const minSampleSize = this.calculateMinSampleSize(config);

    // ìµœì  ì…€ ë¶„í•  ë¹„ìœ¨ ê³„ì‚°
    const optimalRatio = this.calculateOptimalCellRatio(minSampleSize, power);

    return { ...config, optimizedCells: optimalRatio };
  }
}
```

#### ìë™ ìµœì í™” ì—”ì§„
```typescript
interface AutoOptimizationRule {
  trigger: 'statistical_significance' | 'performance_threshold' | 'time_limit';
  action: 'scale_winner' | 'pause_loser' | 'create_follow_up' | 'redistribute_budget';
  threshold: number;
  confidence: number;
}

class SplitTestOptimizer {
  async applyAutoOptimization(testId: string, rules: AutoOptimizationRule[]): Promise<OptimizationResult> {
    const results = await this.getTestResults(testId);
    const significance = this.calculateStatisticalSignificance(results);

    for (const rule of rules) {
      if (this.shouldTriggerRule(rule, results, significance)) {
        await this.executeOptimization(rule, results);
      }
    }
  }

  async createFollowUpTest(winnerCell: SplitTestResults): Promise<string> {
    // ìŠ¹ì ì…€ ê¸°ë°˜ í›„ì† í…ŒìŠ¤íŠ¸ ì„¤ê³„
    // ìƒˆë¡œìš´ ë³€ìˆ˜ í…ŒìŠ¤íŠ¸ (ì˜ˆ: í¬ë¦¬ì—ì´í‹°ë¸Œ ìµœì í™”)
    // ìë™ í…ŒìŠ¤íŠ¸ ìƒì„± ë° ì‹œì‘
  }
}
```

### Lift Studies ì‹¤í—˜ ê´€ë¦¬ ì‹œìŠ¤í…œ

#### ì‹¤í—˜ ë¼ì´í”„ì‚¬ì´í´ ê´€ë¦¬
```typescript
interface LiftStudyLifecycle {
  studyId: string;
  businessId: string;
  status: 'DRAFT' | 'PENDING' | 'ACTIVE' | 'COMPLETED' | 'FAILED';
  createdAt: Date;
  startTime: Date;
  endTime: Date;
  observationEndTime: Date;
}

class LiftStudyOrchestrator {
  async manageLiftStudyLifecycle(studyId: string): Promise<void> {
    // 1. ì‹¤í—˜ ìƒíƒœ ëª¨ë‹ˆí„°ë§
    const study = await this.getStudyStatus(studyId);

    // 2. ì‹¤í—˜ ë‹¨ê³„ë³„ ìë™ ì²˜ë¦¬
    switch (study.status) {
      case 'ACTIVE':
        await this.monitorActiveStudy(studyId);
        break;
      case 'COMPLETED':
        await this.processCompletedStudy(studyId);
        break;
    }

    // 3. ì•Œë¦¼ ë° ë³´ê³ ì„œ ìƒì„±
    await this.generateStudyReports(studyId);
  }

  async optimizeExperimentDesign(config: LiftStudyConfig): Promise<OptimizedConfig> {
    // í†µê³„ì  ê²€ì •ë ¥ ê³„ì‚°
    const power = this.calculateStatisticalPower(config);

    // ìµœì†Œ í‘œë³¸ í¬ê¸° ê³„ì‚°
    const minSampleSize = this.calculateMinSampleSize(config.objectives);

    // ìµœì  ì‹¤í—˜êµ°/ëŒ€ì¡°êµ° ë¹„ìœ¨ ê³„ì‚°
    const optimalRatio = this.calculateOptimalRatio(minSampleSize, power);

    return { ...config, optimizedCells: optimalRatio };
  }
}
```

#### í†µê³„ ë¶„ì„ ì—”ì§„
```typescript
interface StatisticalAnalysis {
  pValue: number;
  confidenceInterval: [number, number];
  effectSize: number;
  statisticalPower: number;
  practicalSignificance: boolean;
}

class LiftStatisticsEngine {
  async performStatisticalTest(results: LiftStudyResults): Promise<StatisticalAnalysis> {
    // 1. í†µê³„ì  ìœ ì˜ì„± ê²€ì •
    const pValue = this.calculatePValue(results);

    // 2. ì‹ ë¢°êµ¬ê°„ ê³„ì‚°
    const confidenceInterval = this.calculateConfidenceInterval(results);

    // 3. íš¨ê³¼ í¬ê¸° ì¸¡ì •
    const effectSize = this.calculateEffectSize(results);

    // 4. ê²€ì •ë ¥ ë¶„ì„
    const statisticalPower = this.calculatePower(results);

    // 5. ì‹¤ì§ˆì  ì˜ë¯¸ í‰ê°€
    const practicalSignificance = this.assessPracticalSignificance(effectSize);

    return { pValue, confidenceInterval, effectSize, statisticalPower, practicalSignificance };
  }

  async generateRecommendations(analysis: StatisticalAnalysis): Promise<ActionRecommendations> {
    // í†µê³„ì  ê²°ê³¼ ê¸°ë°˜ ì•¡ì…˜ í”Œëœ ìƒì„±
    if (analysis.pValue < 0.05 && analysis.practicalSignificance) {
      return this.generateScaleUpRecommendations(analysis);
    } else {
      return this.generateOptimizationRecommendations(analysis);
    }
  }
}
```

### MMM ì „ìš© ë°ì´í„° ì²˜ë¦¬ ì‹œìŠ¤í…œ

#### MMM ë°ì´í„° ìˆ˜ì§‘ê¸°
```typescript
interface MMMDataCollector {
  businessId: string;
  timeRange: DateRange;
  exportFormat: 'json' | 'csv';
  timeIncrement: number; // 1ì¼ ë‹¨ìœ„ ê¶Œì¥
}

class MMMCollectionEngine {
  async collectBusinessManagerMMM(config: MMMDataCollector): Promise<MMMResult> {
    // 1ë‹¨ê³„: ê³„ì • ëª©ë¡ ìˆ˜ì§‘
    const accounts = await this.getAllAccounts(config.businessId);

    // 2ë‹¨ê³„: ê° ê³„ì •ë³„ MMM ë°ì´í„° ìˆ˜ì§‘
    const mmmResults = await this.batchCollectMMM(accounts, config);

    // 3ë‹¨ê³„: ë°ì´í„° ì§‘ê³„ ë° ì •ê·œí™”
    return this.aggregateAndNormalize(mmmResults);
  }

  private validateMMMFilter(filter: any): boolean {
    // MMM ì „ìš© í•„í„°ë§ ê·œì¹™ ê²€ì¦
    const validator = new MMMFilterValidator();
    return validator.validateAllFilters(filter);
  }
}
```

#### MMM ë°ì´í„° ë¶„ì„ ì—”ì§„
```typescript
interface MMMAnalysisConfig {
  baseline: 'historical' | 'seasonal' | 'trend';
  incrementality: boolean;
  crossChannelSynergy: boolean;
  saturationModeling: boolean;
}

class MMMAnalyzer {
  async analyzeMarketingMix(data: MMMData[], config: MMMAnalysisConfig): Promise<MMMInsights> {
    // ê¸°ì—¬ë„ ë¶„ì„ (Attribution Analysis)
    const attribution = await this.calculateAttribution(data);

    // ì¦ë¶„ íš¨ê³¼ ê³„ì‚° (Incrementality)
    const incrementality = config.incrementality
      ? await this.calculateIncrementality(data)
      : null;

    // ì±„ë„ ê°„ ì‹œë„ˆì§€ ë¶„ì„
    const synergy = config.crossChannelSynergy
      ? await this.analyzeCrossChannelSynergy(data)
      : null;

    // í¬í™”ë„ ëª¨ë¸ë§
    const saturation = config.saturationModeling
      ? await this.modelSaturationCurves(data)
      : null;

    return { attribution, incrementality, synergy, saturation };
  }
}
```

### ê´‘ê³  ê·œì¹™ ì—”ì§„ ì‹œìŠ¤í…œ (Meta API ì™„ì „ í†µí•©)

#### ê·œì¹™ ì‹¤í–‰ ì—”ì§„
```typescript
interface MetaAdRuleConfig {
  name: string;
  schedule_spec?: {
    schedule_type: 'DAILY' | 'HOURLY' | 'SEMI_HOURLY' | 'CUSTOM';
    schedule?: CustomSchedule[];
  };
  evaluation_spec: {
    evaluation_type: 'SCHEDULE' | 'TRIGGER';
    trigger?: TriggerSpec;
    filters: FilterSpec[];
  };
  execution_spec: {
    execution_type: 'NOTIFICATION' | 'PAUSE' | 'UNPAUSE' | 'CHANGE_BUDGET' |
                   'CHANGE_CAMPAIGN_BUDGET' | 'CHANGE_BID' | 'ROTATE' |
                   'REBALANCE_BUDGET' | 'PING_ENDPOINT';
    execution_options?: ExecutionOption[];
  };
}

interface TriggerSpec {
  type: 'METADATA_CREATION' | 'METADATA_UPDATE' | 'STATS_CHANGE' |
        'STATS_MILESTONE' | 'DELIVERY_INSIGHTS_CHANGE';
  field?: string;
  value?: any;
  operator?: 'EQUAL' | 'GREATER_THAN' | 'LESS_THAN' | 'IN_RANGE' | 'NOT_IN_RANGE';
}

interface ExecutionOption {
  field: 'user_ids' | 'change_spec' | 'rebalance_spec' | 'execution_count_limit' | 'action_frequency';
  value: any;
  operator: 'EQUAL';
}

class MetaAdRuleOrchestrator {
  private scheduleManager: MetaScheduleManager;
  private triggerManager: MetaTriggerManager;
  private webhookManager: WebhookManager;
  private executionQueue: Queue<RuleExecution>;

  async initializeRuleEngine(): Promise<void> {
    // 1. Meta Ad Rules Library API ì—°ë™ ì´ˆê¸°í™”
    await this.initializeMetaAPI();

    // 2. í™œì„± ê·œì¹™ ë™ê¸°í™”
    const activeRules = await this.syncActiveRulesFromMeta();

    // 3. ìŠ¤ì¼€ì¤„ ê¸°ë°˜ ê·œì¹™ ë“±ë¡
    await this.scheduleManager.registerScheduledRules(
      activeRules.filter(rule => rule.evaluation_spec.evaluation_type === 'SCHEDULE')
    );

    // 4. íŠ¸ë¦¬ê±° ê¸°ë°˜ ê·œì¹™ ë“±ë¡ ë° Webhook ì„¤ì •
    await this.triggerManager.registerTriggerRules(
      activeRules.filter(rule => rule.evaluation_spec.evaluation_type === 'TRIGGER')
    );

    // 5. Webhook ì—”ë“œí¬ì¸íŠ¸ ì„¤ì • (PING_ENDPOINTìš©)
    await this.webhookManager.setupWebhookSubscription();

    // 6. ì‹¤í–‰ í ë° ì›Œì»¤ ì‹œì‘
    await this.startExecutionWorkers();
  }

  async createMetaAdRule(ruleConfig: MetaAdRuleConfig): Promise<string> {
    // Meta Ad Rules Library APIë¥¼ í†µí•œ ê·œì¹™ ìƒì„±
    const response = await fetch(`https://graph.facebook.com/${this.apiVersion}/${this.adAccountId}/adrules_library`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${this.accessToken}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        name: ruleConfig.name,
        schedule_spec: ruleConfig.schedule_spec,
        evaluation_spec: ruleConfig.evaluation_spec,
        execution_spec: ruleConfig.execution_spec
      })
    });

    const result = await response.json();

    if (result.error) {
      throw new Error(`Meta API Error: ${result.error.message}`);
    }

    // ë¡œì»¬ ê·œì¹™ ê´€ë¦¬ ì‹œìŠ¤í…œì— ë“±ë¡
    await this.registerLocalRule(result.id, ruleConfig);

    return result.id;
  }

  async executeMetaActions(executionSpec: ExecutionSpec, targetEntities: string[]): Promise<ActionResult[]> {
    const results: ActionResult[] = [];

    switch (executionSpec.execution_type) {
      case 'NOTIFICATION':
        results.push(await this.sendNotification(executionSpec.execution_options, targetEntities));
        break;

      case 'PAUSE':
        results.push(await this.pauseEntities(targetEntities));
        break;

      case 'UNPAUSE':
        results.push(await this.unpauseEntities(targetEntities));
        break;

      case 'CHANGE_BUDGET':
        results.push(await this.changeBudget(targetEntities, executionSpec.execution_options));
        break;

      case 'CHANGE_CAMPAIGN_BUDGET':
        results.push(await this.changeCampaignBudget(targetEntities, executionSpec.execution_options));
        break;

      case 'CHANGE_BID':
        results.push(await this.changeBid(targetEntities, executionSpec.execution_options));
        break;

      case 'ROTATE':
        results.push(await this.rotateAds(targetEntities));
        break;

      case 'REBALANCE_BUDGET':
        results.push(await this.rebalanceBudget(targetEntities, executionSpec.execution_options));
        break;

      case 'PING_ENDPOINT':
        results.push(await this.pingWebhookEndpoint(targetEntities));
        break;
    }

    return results;
  }

  private async changeBudget(adsetIds: string[], executionOptions: ExecutionOption[]): Promise<ActionResult> {
    const changeSpec = this.extractChangeSpec(executionOptions);
    const results = [];

    for (const adsetId of adsetIds) {
      // change_specì— ë”°ë¥¸ ì˜ˆì‚° ê³„ì‚°
      let newBudget = await this.calculateNewBudget(adsetId, changeSpec);

      // limit ì ìš©
      if (changeSpec.limit) {
        newBudget = this.applyBudgetLimits(newBudget, changeSpec.limit);
      }

      // target_field ê¸°ë°˜ ë™ì  ì¡°ì •
      if (changeSpec.target_field) {
        newBudget = await this.calculateTargetFieldBasedBudget(adsetId, changeSpec);
      }

      // Meta APIë¥¼ í†µí•œ ì˜ˆì‚° ì—…ë°ì´íŠ¸
      const response = await this.updateAdsetBudget(adsetId, newBudget);
      results.push({ adsetId, newBudget, success: response.success });
    }

    return { action: 'CHANGE_BUDGET', results };
  }

  private async calculateTargetFieldBasedBudget(adsetId: string, changeSpec: ChangeSpec): Promise<number> {
    // target_fieldì˜ í˜„ì¬ ê°’ ì¡°íšŒ
    const currentMetrics = await this.getAdsetInsights(adsetId, [changeSpec.target_field]);
    const currentValue = currentMetrics[changeSpec.target_field];

    // ëª©í‘œê°’(amount)ê³¼ í˜„ì¬ê°’ì˜ ì°¨ì´ ê³„ì‚°
    const targetValue = changeSpec.amount;
    const proportionalDifference = (targetValue - currentValue) / currentValue;

    // í˜„ì¬ ì˜ˆì‚° ì¡°íšŒ
    const currentBudget = await this.getCurrentBudget(adsetId);

    // ë¹„ë¡€ì  ì˜ˆì‚° ì¡°ì • ê³„ì‚°
    const adjustmentFactor = 1 + proportionalDifference;
    let newBudget = currentBudget * adjustmentFactor;

    // limit ë²”ìœ„ ì ìš©
    if (changeSpec.limit && Array.isArray(changeSpec.limit)) {
      const [minLimit, maxLimit] = changeSpec.limit;
      newBudget = Math.max(minLimit, Math.min(maxLimit, newBudget));
    }

    return newBudget;
  }
}
```

#### ìŠ¤ì¼€ì¤„ ê¸°ë°˜ ì‹¤í–‰ ê´€ë¦¬ (Meta Schedule Spec ì™„ì „ ì§€ì›)
```typescript
interface MetaScheduleSpec {
  schedule_type: 'DAILY' | 'HOURLY' | 'SEMI_HOURLY' | 'CUSTOM';
  schedule?: CustomScheduleEntry[];
}

interface CustomScheduleEntry {
  start_minute?: number;    // ìì •ë¶€í„° ë¶„ ë‹¨ìœ„ (30ë¶„ ë°°ìˆ˜)
  end_minute?: number;      // ì‹œê°„ ë²”ìœ„ ì§€ì •
  days?: number[];          // 0=ì¼ìš”ì¼, 1=ì›”ìš”ì¼, ..., 6=í† ìš”ì¼
}

class MetaScheduleManager {
  private scheduledJobs: Map<string, ScheduleHandler> = new Map();
  private adAccountTimeZone: string;

  async registerScheduledRules(rules: MetaAdRuleConfig[]): Promise<void> {
    // ê´‘ê³  ê³„ì • ì‹œê°„ëŒ€ ì¡°íšŒ
    this.adAccountTimeZone = await this.getAdAccountTimeZone();

    for (const rule of rules) {
      if (rule.evaluation_spec.evaluation_type === 'SCHEDULE' && rule.schedule_spec) {
        await this.createScheduledJob(rule);
      }
    }
  }

  private async createScheduledJob(rule: MetaAdRuleConfig): Promise<void> {
    const scheduleSpec = rule.schedule_spec!;

    switch (scheduleSpec.schedule_type) {
      case 'DAILY':
        await this.createDailySchedule(rule);
        break;
      case 'HOURLY':
        await this.createHourlySchedule(rule);
        break;
      case 'SEMI_HOURLY':
        await this.createSemiHourlySchedule(rule);
        break;
      case 'CUSTOM':
        await this.createCustomSchedule(rule, scheduleSpec.schedule!);
        break;
    }
  }

  private async createDailySchedule(rule: MetaAdRuleConfig): Promise<void> {
    // ê´‘ê³  ê³„ì • ì‹œê°„ëŒ€ ìì • ì‹¤í–‰
    const cronExpression = `0 0 * * *`;  // ë§¤ì¼ 00:00

    const job = new CronJob(cronExpression, async () => {
      await this.executeScheduledRule(rule);
    }, null, true, this.adAccountTimeZone);

    this.scheduledJobs.set(rule.name, {
      job,
      rule,
      nextExecution: job.nextDate().toDate()
    });
  }

  private async createCustomSchedule(rule: MetaAdRuleConfig, customSchedule: CustomScheduleEntry[]): Promise<void> {
    for (const scheduleEntry of customSchedule) {
      const cronExpressions = this.convertCustomScheduleToCron(scheduleEntry);

      for (const cronExpression of cronExpressions) {
        const job = new CronJob(cronExpression, async () => {
          await this.executeScheduledRule(rule);
        }, null, true, this.adAccountTimeZone);

        this.scheduledJobs.set(`${rule.name}_${JSON.stringify(scheduleEntry)}`, {
          job,
          rule,
          scheduleEntry,
          nextExecution: job.nextDate().toDate()
        });
      }
    }
  }

  private convertCustomScheduleToCron(entry: CustomScheduleEntry): string[] {
    const cronExpressions: string[] = [];

    if (entry.start_minute !== undefined) {
      const hour = Math.floor(entry.start_minute / 60);
      const minute = entry.start_minute % 60;

      if (entry.end_minute !== undefined) {
        // ì‹œê°„ ë²”ìœ„ ì§€ì •ëœ ê²½ìš° - 30ë¶„ ê°„ê²©ìœ¼ë¡œ ì‹¤í–‰
        const endHour = Math.floor(entry.end_minute / 60);
        const endMinute = entry.end_minute % 60;

        for (let h = hour; h <= endHour; h++) {
          for (let m = (h === hour ? minute : 0); m < 60 && (h < endHour || m <= endMinute); m += 30) {
            const dayPattern = entry.days ? entry.days.join(',') : '*';
            cronExpressions.push(`${m} ${h} * * ${dayPattern}`);
          }
        }
      } else {
        // ì •í™•í•œ ì‹œê°„ ì§€ì •ëœ ê²½ìš°
        const dayPattern = entry.days ? entry.days.join(',') : '*';
        cronExpressions.push(`${minute} ${hour} * * ${dayPattern}`);
      }
    } else if (entry.days) {
      // daysë§Œ ì§€ì •ëœ ê²½ìš° - í•´ë‹¹ ìš”ì¼ì— SEMI_HOURLY ì‹¤í–‰
      const dayPattern = entry.days.join(',');
      cronExpressions.push(`0,30 * * * ${dayPattern}`);
    }

    return cronExpressions;
  }

  private async executeScheduledRule(rule: MetaAdRuleConfig): Promise<void> {
    try {
      // 1. ì¼ì¼ ìš”ì•½ ì´ë©”ì¼ ìƒì„± (user_ids ì„¤ì •ëœ ê²½ìš°)
      const shouldSendSummary = this.shouldSendDailySummary(rule);

      // 2. ê·œì¹™ ì‹¤í–‰
      const executionResult = await this.ruleOrchestrator.executeRule(rule);

      // 3. ì‹¤í–‰ ê²°ê³¼ ë¡œê¹…
      await this.logScheduledExecution(rule, executionResult);

      // 4. ì¼ì¼ ìš”ì•½ ì´ë©”ì¼ ì „ì†¡ (ì˜¤ì „ 12:30)
      if (shouldSendSummary && this.isTimeForDailySummary()) {
        await this.sendDailySummaryEmail(rule);
      }

    } catch (error) {
      await this.handleScheduleError(rule, error);
    }
  }

  private shouldSendDailySummary(rule: MetaAdRuleConfig): boolean {
    return rule.execution_spec.execution_options?.some(
      option => option.field === 'user_ids'
    ) || false;
  }

  private isTimeForDailySummary(): boolean {
    const now = new Date();
    return now.getHours() === 0 && now.getMinutes() === 30; // ì˜¤ì „ 12:30
  }
}
```

#### íŠ¸ë¦¬ê±° ê¸°ë°˜ ì‹¤í–‰ ê´€ë¦¬ (5ê°€ì§€ íŠ¸ë¦¬ê±° ìœ í˜• ì™„ì „ ì§€ì›)
```typescript
interface MetaTriggerManager {
  metadataMonitors: Map<string, MetadataMonitor>;
  statsMonitors: Map<string, StatsMonitor>;
  webhookHandlers: Map<string, WebhookHandler>;
  deliveryInsightMonitors: Map<string, DeliveryInsightMonitor>;
}

class MetaTriggerManager {
  private webSocketConnections: Map<string, WebSocket> = new Map();
  private pollIntervals: Map<string, NodeJS.Timeout> = new Map();

  async registerTriggerRules(rules: MetaAdRuleConfig[]): Promise<void> {
    for (const rule of rules) {
      if (rule.evaluation_spec.evaluation_type === 'TRIGGER' && rule.evaluation_spec.trigger) {
        await this.createTriggerHandler(rule);
      }
    }
  }

  private async createTriggerHandler(rule: MetaAdRuleConfig): Promise<void> {
    const trigger = rule.evaluation_spec.trigger!;

    switch (trigger.type) {
      case 'METADATA_CREATION':
        await this.createMetadataCreationMonitor(rule);
        break;
      case 'METADATA_UPDATE':
        await this.createMetadataUpdateMonitor(rule, trigger);
        break;
      case 'STATS_CHANGE':
        await this.createStatsChangeMonitor(rule, trigger);
        break;
      case 'STATS_MILESTONE':
        await this.createStatsMilestoneMonitor(rule, trigger);
        break;
      case 'DELIVERY_INSIGHTS_CHANGE':
        await this.createDeliveryInsightsMonitor(rule, trigger);
        break;
    }
  }

  private async createMetadataCreationMonitor(rule: MetaAdRuleConfig): Promise<void> {
    // Meta Webhookì„ í†µí•œ ê´‘ê³  ê°ì²´ ìƒì„± ëª¨ë‹ˆí„°ë§
    const webhookHandler = new MetadataCreationHandler({
      ruleId: rule.name,
      filters: rule.evaluation_spec.filters,
      onObjectCreated: async (createdObject) => {
        // í•„í„° ì¡°ê±´ ê²€ì¦
        const passesFilter = await this.evaluateFilters(createdObject, rule.evaluation_spec.filters);

        if (passesFilter) {
          await this.executeTriggerRule(rule, {
            triggerType: 'METADATA_CREATION',
            objectId: createdObject.id,
            objectType: createdObject.entity_type,
            createdAt: new Date()
          });
        }
      }
    });

    this.webhookHandlers.set(`creation_${rule.name}`, webhookHandler);
  }

  private async createMetadataUpdateMonitor(rule: MetaAdRuleConfig, trigger: TriggerSpec): Promise<void> {
    // ì‹¤ì‹œê°„ ë©”íƒ€ë°ì´í„° ë³€ê²½ ëª¨ë‹ˆí„°ë§ (WebSocket + Polling)
    const monitor = new MetadataUpdateMonitor({
      ruleId: rule.name,
      monitoredField: trigger.field!,
      targetValue: trigger.value,
      operator: trigger.operator,
      filters: rule.evaluation_spec.filters,
      checkInterval: 30000, // 30ì´ˆ ê°„ê²© (ë©”íƒ€ë°ì´í„°ëŠ” ëª‡ ì´ˆ ëŒ€ê¸°ì‹œê°„)
      onMetadataChanged: async (changeData) => {
        await this.executeTriggerRule(rule, {
          triggerType: 'METADATA_UPDATE',
          field: trigger.field!,
          oldValue: changeData.oldValue,
          newValue: changeData.newValue,
          objectId: changeData.objectId,
          changedAt: new Date()
        });
      }
    });

    this.metadataMonitors.set(`metadata_${rule.name}`, monitor);
    await monitor.start();
  }

  private async createStatsChangeMonitor(rule: MetaAdRuleConfig, trigger: TriggerSpec): Promise<void> {
    // ì¸ì‚¬ì´íŠ¸ ë°ì´í„° falseâ†’true ë³€í™” ê°ì§€ (~7.5ë¶„ ëŒ€ê¸°ì‹œê°„)
    const monitor = new StatsChangeMonitor({
      ruleId: rule.name,
      triggerField: trigger.field!,
      triggerValue: trigger.value,
      triggerOperator: trigger.operator!,
      filters: rule.evaluation_spec.filters,
      checkInterval: 450000, // 7.5ë¶„ ê°„ê²©
      previousStates: new Map(), // ì´ì „ ìƒíƒœ ì¶”ì  (falseâ†’true ê°ì§€ìš©)
      onStatsChanged: async (changeData) => {
        // falseì—ì„œ trueë¡œ ë³€ê²½ëœ ê²½ìš°ì—ë§Œ íŠ¸ë¦¬ê±°
        if (!changeData.previousCondition && changeData.currentCondition) {
          await this.executeTriggerRule(rule, {
            triggerType: 'STATS_CHANGE',
            field: trigger.field!,
            currentValue: changeData.currentValue,
            previousValue: changeData.previousValue,
            objectId: changeData.objectId,
            changedAt: new Date()
          });
        }
      }
    });

    this.statsMonitors.set(`stats_change_${rule.name}`, monitor);
    await monitor.start();
  }

  private async createStatsMilestoneMonitor(rule: MetaAdRuleConfig, trigger: TriggerSpec): Promise<void> {
    // íŠ¹ì • ê°’ì˜ ë°°ìˆ˜ ë„ë‹¬ ê°ì§€
    const supportedFields = this.getSupportedMilestoneFields();

    if (!supportedFields.includes(trigger.field!)) {
      throw new Error(`Unsupported milestone field: ${trigger.field}`);
    }

    const minValue = this.getMinimumValueForField(trigger.field!);
    if (trigger.value < minValue) {
      throw new Error(`Value ${trigger.value} is below minimum ${minValue} for field ${trigger.field}`);
    }

    const monitor = new StatsMilestoneMonitor({
      ruleId: rule.name,
      milestoneField: trigger.field!,
      milestoneValue: trigger.value,
      filters: rule.evaluation_spec.filters,
      checkInterval: 300000, // 5ë¶„ ê°„ê²©
      lastMilestones: new Map(), // ë§ˆì§€ë§‰ ë‹¬ì„±í•œ ë§ˆì¼ìŠ¤í†¤ ì¶”ì 
      onMilestoneReached: async (milestoneData) => {
        await this.executeTriggerRule(rule, {
          triggerType: 'STATS_MILESTONE',
          field: trigger.field!,
          milestoneValue: milestoneData.milestoneReached,
          currentValue: milestoneData.currentValue,
          objectId: milestoneData.objectId,
          reachedAt: new Date()
        });
      }
    });

    this.statsMonitors.set(`milestone_${rule.name}`, monitor);
    await monitor.start();
  }

  private async createDeliveryInsightsMonitor(rule: MetaAdRuleConfig, trigger: TriggerSpec): Promise<void> {
    // ê²Œì¬ ì¸ì‚¬ì´íŠ¸ ë³€ê²½ ëª¨ë‹ˆí„°ë§ (ë² íƒ€ ê¸°ëŠ¥)
    const monitor = new DeliveryInsightsMonitor({
      ruleId: rule.name,
      trigger: trigger,
      filters: rule.evaluation_spec.filters,
      checkInterval: 600000, // 10ë¶„ ê°„ê²© (ë² íƒ€ ê¸°ëŠ¥ìœ¼ë¡œ ë” ë³´ìˆ˜ì )
      onDeliveryInsightChanged: async (changeData) => {
        await this.executeTriggerRule(rule, {
          triggerType: 'DELIVERY_INSIGHTS_CHANGE',
          field: trigger.field!,
          changeData: changeData,
          objectId: changeData.objectId,
          changedAt: new Date()
        });
      }
    });

    this.deliveryInsightMonitors.set(`delivery_${rule.name}`, monitor);
    await monitor.start();
  }

  private getSupportedMilestoneFields(): string[] {
    return [
      'impressions', 'unique_impressions', 'reach', 'clicks', 'unique_clicks',
      'spent', 'results', 'app_custom_event', 'leadgen', 'like', 'link_click',
      'mobile_app_install', 'offsite_conversion', 'post_engagement', 'video_view'
      // ... ì „ì²´ ì§€ì› í•„ë“œ ëª©ë¡
    ];
  }

  private getMinimumValueForField(field: string): number {
    const minimumValues = {
      'impressions': 1000,
      'unique_impressions': 1000,
      'reach': 1000,
      'clicks': 10,
      'unique_clicks': 10,
      'spent': 1000, // ì„¼íŠ¸ ë‹¨ìœ„
      'results': 5,
      'mobile_app_install': 1,
      'offsite_conversion': 1
      // ... ì „ì²´ ìµœì†Œê°’ ë§¤í•‘
    };

    return minimumValues[field] || 1;
  }

  private async executeTriggerRule(rule: MetaAdRuleConfig, triggerContext: TriggerContext): Promise<void> {
    try {
      // 1. ì¶”ê°€ í•„í„° ì¡°ê±´ ê²€ì¦
      const passesAllFilters = await this.evaluateAllFilters(triggerContext.objectId, rule.evaluation_spec.filters);

      if (!passesAllFilters) {
        return; // í•„í„° ì¡°ê±´ ë¯¸ì¶©ì¡±
      }

      // 2. ì‹¤í–‰ ì•¡ì…˜ ìˆ˜í–‰
      const actionResults = await this.ruleOrchestrator.executeMetaActions(
        rule.execution_spec,
        [triggerContext.objectId]
      );

      // 3. Webhook ì•Œë¦¼ ì „ì†¡ (PING_ENDPOINTì¸ ê²½ìš°)
      if (rule.execution_spec.execution_type === 'PING_ENDPOINT') {
        await this.sendWebhookNotification(rule, triggerContext, actionResults);
      }

      // 4. ì‹¤í–‰ ê²°ê³¼ ë¡œê¹…
      await this.logTriggerExecution(rule, triggerContext, actionResults);

    } catch (error) {
      await this.handleTriggerError(rule, triggerContext, error);
    }
  }

  private async sendWebhookNotification(rule: MetaAdRuleConfig, context: TriggerContext, results: ActionResult[]): Promise<void> {
    const webhookPayload = {
      object: 'application',
      entry: [{
        id: this.applicationId,
        time: Math.floor(Date.now() / 1000),
        changes: [{
          field: 'ads_rules_engine',
          value: {
            'rule_id': rule.name,
            'object_id': context.objectId,
            'object_type': context.objectType || 'UNKNOWN',
            'trigger_type': context.triggerType,
            'trigger_field': context.field,
            'current_value': JSON.stringify(context.currentValue)
          }
        }]
      }]
    };

    // ë“±ë¡ëœ Webhook URLë¡œ POST ìš”ì²­
    await this.webhookClient.sendNotification(webhookPayload);
  }
}
```

#### Webhook í†µí•© ì‹œìŠ¤í…œ (PING_ENDPOINT ì§€ì›)
```typescript
interface WebhookManager {
  appId: string;
  appAccessToken: string;
  callbackUrl: string;
  verifyToken: string;
  subscriptionActive: boolean;
}

class MetaWebhookManager {
  async setupWebhookSubscription(): Promise<void> {
    // 1. Facebook ì•±ì— ads_rules_engine Webhook êµ¬ë… ì„¤ì •
    const subscriptionResponse = await fetch(`https://graph.facebook.com/${this.apiVersion}/${this.appId}/subscriptions`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${this.appAccessToken}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        object: 'application',
        callback_url: this.callbackUrl,
        fields: 'ads_rules_engine',
        verify_token: this.verifyToken
      })
    });

    if (!subscriptionResponse.ok) {
      throw new Error('Failed to setup webhook subscription');
    }

    // 2. Webhook ì—”ë“œí¬ì¸íŠ¸ ê²€ì¦ ë° ë“±ë¡
    await this.setupWebhookEndpoint();
  }

  async setupWebhookEndpoint(): Promise<void> {
    // Express.js ê¸°ë°˜ Webhook ì—”ë“œí¬ì¸íŠ¸ ì„¤ì •
    this.app.get('/webhook', (req, res) => {
      // ì¸ì¦ ì±Œë¦°ì§€ ì²˜ë¦¬
      const mode = req.query['hub.mode'];
      const token = req.query['hub.verify_token'];
      const challenge = req.query['hub.challenge'];

      if (mode && token) {
        if (mode === 'subscribe' && token === this.verifyToken) {
          console.log('Webhook verified');
          res.status(200).send(challenge);
        } else {
          res.status(403).send('Forbidden');
        }
      }
    });

    this.app.post('/webhook', (req, res) => {
      // ê·œì¹™ ì—”ì§„ ì•Œë¦¼ ì²˜ë¦¬
      const body = req.body;

      if (body.object === 'application') {
        body.entry.forEach((entry) => {
          entry.changes.forEach((change) => {
            if (change.field === 'ads_rules_engine') {
              this.processRuleEngineWebhook(change.value);
            }
          });
        });
      }

      res.status(200).send('EVENT_RECEIVED');
    });
  }

  async processRuleEngineWebhook(webhookData: any): Promise<void> {
    // Webhook ë°ì´í„° êµ¬ì¡°:
    // {
    //   'rule_id': 1234,
    //   'object_id': 5678,
    //   'object_type': 'ADSET',
    //   'trigger_type': 'STATS_CHANGE',
    //   'trigger_field': 'COST_PER_LINK_CLICK',
    //   'current_value': '15.8'
    // }

    const ruleId = webhookData.rule_id;
    const objectId = webhookData.object_id;
    const triggerType = webhookData.trigger_type;
    const currentValue = this.parseWebhookValue(webhookData.current_value);

    // 1. ë¡œì»¬ ê·œì¹™ ì‹¤í–‰ ë¡œê·¸ ì—…ë°ì´íŠ¸
    await this.updateRuleExecutionLog(ruleId, {
      objectId,
      triggerType,
      currentValue,
      triggeredAt: new Date()
    });

    // 2. í›„ì† ì•¡ì…˜ ì²˜ë¦¬ (í•„ìš”í•œ ê²½ìš°)
    await this.handleWebhookTriggeredAction(ruleId, objectId, triggerType);

    // 3. ì‹¤ì‹œê°„ ëŒ€ì‹œë³´ë“œ ì—…ë°ì´íŠ¸
    await this.notifyRealTimeDashboard(ruleId, webhookData);
  }

  private parseWebhookValue(valueString: string): any {
    // current_valueëŠ” JSON ì¸ì½”ë”© ë¬¸ìì—´
    try {
      return JSON.parse(valueString);
    } catch {
      return valueString; // ë‹¨ìˆœ ë¬¸ìì—´ì¸ ê²½ìš°
    }
  }
}
```

#### ê·œì¹™ í•™ìŠµ ë° ìµœì í™” ì‹œìŠ¤í…œ
```typescript
interface MetaRuleLearningEngine {
  ruleId: string;
  executionHistory: RuleExecutionHistory[];
  performanceMetrics: PerformanceMetrics;
  optimizationRecommendations: OptimizationRecommendation[];
}

class MetaAdRuleLearningSystem {
  async optimizeRuleParameters(ruleId: string): Promise<OptimizationResult> {
    // 1. Meta APIë¥¼ í†µí•œ ê·œì¹™ ì‹¤í–‰ ì´ë ¥ ìˆ˜ì§‘
    const executionHistory = await this.getMetaRuleExecutionHistory(ruleId, 90);

    // 2. ì„±ê³¼ ë¶„ì„ (ROI, ì‹¤í–‰ ì„±ê³µë¥ , ëª©í‘œ ë‹¬ì„±ë¥ )
    const performanceAnalysis = await this.analyzeRulePerformance(executionHistory);

    // 3. change_spec ìµœì í™”
    const optimizedChangeSpecs = await this.optimizeChangeSpecs(performanceAnalysis);

    // 4. ì‹¤í–‰ ë¹ˆë„ ìµœì í™” (execution_count_limit, action_frequency)
    const optimizedFrequency = await this.optimizeExecutionFrequency(performanceAnalysis);

    // 5. í•„í„° ì¡°ê±´ ìµœì í™”
    const optimizedFilters = await this.optimizeFilterConditions(performanceAnalysis);

    return {
      currentParameters: performanceAnalysis.currentParams,
      optimizedChangeSpecs: optimizedChangeSpecs,
      optimizedFrequency: optimizedFrequency,
      optimizedFilters: optimizedFilters,
      expectedImprovement: this.calculateExpectedImprovement(performanceAnalysis)
    };
  }

  async optimizeChangeSpecs(analysis: PerformanceAnalysis): Promise<OptimizedChangeSpec[]> {
    // target_field ê¸°ë°˜ ë™ì  ì¡°ì • ìµœì í™”
    const recommendations = [];

    for (const changeSpec of analysis.changeSpecs) {
      if (changeSpec.target_field) {
        // ëª©í‘œê°’(amount) ìµœì í™”
        const optimalTargetValue = await this.calculateOptimalTargetValue(
          changeSpec.target_field,
          analysis.historicalPerformance
        );

        // limit ë²”ìœ„ ìµœì í™”
        const optimalLimits = await this.calculateOptimalLimits(
          changeSpec.target_field,
          analysis.riskTolerance
        );

        recommendations.push({
          field: changeSpec.target_field,
          currentAmount: changeSpec.amount,
          optimizedAmount: optimalTargetValue,
          currentLimits: changeSpec.limit,
          optimizedLimits: optimalLimits,
          expectedImprovement: this.calculateFieldImprovement(changeSpec, optimalTargetValue)
        });
      }
    }

    return recommendations;
  }

  async optimizeExecutionFrequency(analysis: PerformanceAnalysis): Promise<FrequencyOptimization> {
    // execution_count_limit ìµœì í™”
    const optimalCountLimit = this.calculateOptimalExecutionCount(
      analysis.successRate,
      analysis.diminishingReturns
    );

    // action_frequency ìµœì í™” (ë¶„ ë‹¨ìœ„)
    const optimalFrequency = this.calculateOptimalActionFrequency(
      analysis.marketDynamics,
      analysis.performanceVolatility
    );

    return {
      currentCountLimit: analysis.currentCountLimit,
      optimizedCountLimit: optimalCountLimit,
      currentFrequency: analysis.currentFrequency,
      optimizedFrequency: optimalFrequency,
      reasoning: {
        countLimitReason: this.explainCountLimitOptimization(optimalCountLimit),
        frequencyReason: this.explainFrequencyOptimization(optimalFrequency)
      }
    };
  }

  private async getMetaRuleExecutionHistory(ruleId: string, days: number): Promise<RuleExecutionHistory[]> {
    // Meta APIì—ì„œ ê·œì¹™ ì‹¤í–‰ ì´ë ¥ ì¡°íšŒ (ì‹¤ì œ API ì—”ë“œí¬ì¸íŠ¸ëŠ” ë¬¸ì„œì—ì„œ í™•ì¸)
    const response = await fetch(`https://graph.facebook.com/${this.apiVersion}/${this.adAccountId}/adrules_library/${ruleId}/execution_history`, {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${this.accessToken}`
      },
      params: {
        since: new Date(Date.now() - days * 24 * 60 * 60 * 1000).toISOString(),
        limit: 1000
      }
    });

    return response.json();
  }
}
```

#### ê³ ê¸‰ ìŠ¤ì¼€ì¤„ë§ ì‹œìŠ¤í…œ (Enhanced MetaScheduleManager)
```typescript
interface ComplexCustomSchedule extends CustomScheduleEntry {
  scheduleId?: string;
  priority?: number;
  timeZoneOverride?: string;
  condition?: 'AND' | 'OR'; // ë³µìˆ˜ ìŠ¤ì¼€ì¤„ ì¡°í•© ë°©ì‹
}

class EnhancedMetaScheduleManager extends MetaScheduleManager {
  private complexScheduleHandlers: Map<string, ComplexScheduleHandler> = new Map();

  async createComplexCustomSchedule(rule: MetaAdRuleConfig, schedules: ComplexCustomSchedule[]): Promise<void> {
    // ë³µí•© ìŠ¤ì¼€ì¤„ ì²˜ë¦¬: ì£¼ì¤‘ê³¼ ì£¼ë§ ë‹¤ë¥¸ ì‹¤í–‰ íŒ¨í„´
    const scheduleGroups = this.groupSchedulesByPattern(schedules);

    for (const [groupId, group] of scheduleGroups) {
      const handler = this.createComplexScheduleHandler(rule, group);
      this.complexScheduleHandlers.set(`${rule.name}_${groupId}`, handler);
    }
  }

  private createComplexScheduleHandler(rule: MetaAdRuleConfig, schedules: ComplexCustomSchedule[]): ComplexScheduleHandler {
    // ì˜ˆì‹œ: ì£¼ì¤‘ ë§¤ì¼ + ì£¼ë§ íŠ¹ì • ì‹œê°„ëŒ€
    return {
      weekdaySchedules: schedules.filter(s => s.days && s.days.some(d => d >= 1 && d <= 5)),
      weekendSchedules: schedules.filter(s => s.days && s.days.some(d => d === 0 || d === 6)),
      timeRangeSchedules: schedules.filter(s => s.start_minute && s.end_minute),
      exactTimeSchedules: schedules.filter(s => s.start_minute && !s.end_minute)
    };
  }

  async createTimeRangeExecution(rule: MetaAdRuleConfig, schedule: ComplexCustomSchedule): Promise<void> {
    // ì‹œê°„ ë²”ìœ„ ê¸°ë°˜ ì‹¤í–‰ (ì˜ˆ: ì˜¤í›„ 12ì‹œ~1ì‹œ, 30ë¶„ ê°„ê²©)
    if (!schedule.start_minute || !schedule.end_minute) return;

    const startHour = Math.floor(schedule.start_minute / 60);
    const startMin = schedule.start_minute % 60;
    const endHour = Math.floor(schedule.end_minute / 60);
    const endMin = schedule.end_minute % 60;

    // 30ë¶„ ê°„ê²©ìœ¼ë¡œ ì‹œê°„ ë²”ìœ„ ë‚´ ëª¨ë“  ì‹¤í–‰ ì‹œì  ìƒì„±
    const executionTimes = this.generateTimeRangeExecutions(startHour, startMin, endHour, endMin);

    for (const execTime of executionTimes) {
      const cronExpression = this.buildCronForTimeRange(execTime, schedule.days);
      await this.scheduleTimeRangeJob(rule, cronExpression, schedule);
    }
  }

  private generateTimeRangeExecutions(startH: number, startM: number, endH: number, endM: number): ExecutionTime[] {
    const times: ExecutionTime[] = [];

    for (let h = startH; h <= endH; h++) {
      const minStart = (h === startH) ? startM : 0;
      const minEnd = (h === endH) ? endM : 59;

      // 30ë¶„ ê°„ê²©ìœ¼ë¡œ ì‹¤í–‰ ì‹œì  ìƒì„±
      for (let m = minStart; m <= minEnd; m += 30) {
        if (m <= minEnd) {
          times.push({ hour: h, minute: m });
        }
      }
    }

    return times;
  }

  async createWeekdayWeekendDifferentialSchedule(rule: MetaAdRuleConfig): Promise<void> {
    // ì‹¤ë¬´ ì˜ˆì‹œ: ì£¼ì¤‘ ë§¤ì¼ vs ì£¼ë§ íŠ¹ì • ì‹œê°„ëŒ€
    const weekdaySchedule: ComplexCustomSchedule = {
      days: [1, 2, 3, 4, 5], // ì›”-ê¸ˆ
      scheduleId: 'weekday_daily',
      priority: 1
    };

    const weekendSchedule: ComplexCustomSchedule = {
      start_minute: 720, // ì˜¤í›„ 12ì‹œ
      end_minute: 780,   // ì˜¤í›„ 1ì‹œ
      days: [0, 6],      // ì¼, í† 
      scheduleId: 'weekend_lunch',
      priority: 2
    };

    await this.createComplexCustomSchedule(rule, [weekdaySchedule, weekendSchedule]);
  }
}

// ì‹¤ë¬´ ì ìš© ì˜ˆì‹œë“¤
interface ScheduleExample {
  name: string;
  description: string;
  schedule_spec: any;
}

const advancedScheduleExamples: ScheduleExample[] = [
  {
    name: "ë§¤ì¼ ì˜¤ì „ 10ì‹œ ì •í™• ì‹¤í–‰",
    description: "days ìƒëµì‹œ ë§¤ì¼ ìë™ ì ìš©",
    schedule_spec: {
      "schedule_type": "CUSTOM",
      "schedule": [{ "start_minute": 600 }]
    }
  },
  {
    name: "ì£¼ë§ì—ë§Œ 30ë¶„ë§ˆë‹¤ ì‹¤í–‰",
    description: "start_minute ìƒëµì‹œ SEMI_HOURLY ì ìš©",
    schedule_spec: {
      "schedule_type": "CUSTOM",
      "schedule": [{ "days": [0, 6] }]
    }
  },
  {
    name: "ìˆ˜ìš”ì¼ ì˜¤ì „ 2ì‹œì—ë§Œ ì‹¤í–‰",
    description: "íŠ¹ì • ìš”ì¼ íŠ¹ì • ì‹œê°„ ì‹¤í–‰",
    schedule_spec: {
      "schedule_type": "CUSTOM",
      "schedule": [{ "start_minute": 120, "days": [3] }]
    }
  },
  {
    name: "ì£¼ì¤‘ ë§¤ì¼ + ì£¼ë§ ì ì‹¬ì‹œê°„",
    description: "ë³µí•© ìŠ¤ì¼€ì¤„: OR ì¡°ê±´ìœ¼ë¡œ ë…ë¦½ ì‹¤í–‰",
    schedule_spec: {
      "schedule_type": "CUSTOM",
      "schedule": [
        { "days": [1, 2, 3, 4, 5] },
        { "start_minute": 720, "end_minute": 780, "days": [0, 6] }
      ]
    }
  }
];
```

#### ê³ ê¸‰ í•„í„° ì—”ì§„ (Advanced Meta Filter Engine)
```typescript
interface PrefixedInsightField {
  objectLevelPrefix?: 'ad' | 'adset' | 'campaign';
  attributionWindowPrefix?: string;
  timePresetPrefix?: string;
  fieldName: string;
}

interface AggregateField {
  function: 'aggregate';
  field: string;
  aggregationIds: string[];
}

interface FormulaField {
  expression: string;
  fields: string[];
  constants: number[];
  operators: ('+' | '-' | '*' | '/')[];
}

class MetaAdvancedFilterEngine {
  private supportedObjectPrefixes = ['ad', 'adset', 'campaign'];
  private supportedAttributionWindows = [
    'account_default', 'default', 'inline', '1d_view', '7d_view', '28d_view',
    '1d_click', '7d_click', '28d_click', '1d_view_1d_click', '7d_view_1d_click',
    '28d_view_1d_click', '1d_view_7d_click', '7d_view_7d_click', '28d_view_7d_click',
    '7d_view_28d_click', '28d_view_28d_click'
  ];
  private supportedTimePresets = [
    'lifetime', 'today', 'last_2_days', 'last_3_days', 'last_7_days',
    'last_14_days', 'last_28_days', 'last_30_days', 'this_month',
    'this_week_mon_today', 'this_week_sun_today', 'yesterday',
    'last_2d', 'last_3d', 'last_7d', 'last_14d', 'last_28d', 'last_30d',
    'last_nd_14_8', 'last_nd_30_8', 'last_nd_60_8', 'last_nd_120_8',
    'last_nd_180_8', 'last_nd_lifetime_8', 'last_nd_60_29', 'last_nd_120_20',
    'last_nd_180_29', 'last_nd_lifetime_29'
  ];

  parsePrefixedField(fieldString: string): PrefixedInsightField | null {
    // í˜•ì‹: {object_level_prefix?} {attribution_window_prefix?} {time_preset_prefix?} {field_name}
    const parts = fieldString.split('.');
    let objectLevelPrefix: string | undefined;
    let remainingField = fieldString;

    // 1. ê°ì²´ ìˆ˜ì¤€ í”„ë¦¬í”½ìŠ¤ í™•ì¸
    if (parts.length > 1 && this.supportedObjectPrefixes.includes(parts[0])) {
      objectLevelPrefix = parts[0] as 'ad' | 'adset' | 'campaign';
      remainingField = parts.slice(1).join('.');
    }

    // 2. ê¸°ì—¬ ê¸°ê°„ ë° ì‹œê°„ ê¸°ë³¸ ì„¤ì • í”„ë¦¬í”½ìŠ¤ íŒŒì‹±
    const { attributionWindowPrefix, timePresetPrefix, fieldName } =
      this.parseAttributionAndTimePresets(remainingField);

    return {
      objectLevelPrefix: objectLevelPrefix as any,
      attributionWindowPrefix,
      timePresetPrefix,
      fieldName
    };
  }

  private parseAttributionAndTimePresets(field: string): {
    attributionWindowPrefix?: string;
    timePresetPrefix?: string;
    fieldName: string;
  } {
    let attributionWindowPrefix: string | undefined;
    let timePresetPrefix: string | undefined;
    let fieldName = field;

    // ê¸°ì—¬ ê¸°ê°„ í”„ë¦¬í”½ìŠ¤ í™•ì¸
    for (const prefix of this.supportedAttributionWindows) {
      if (field.startsWith(prefix + ':')) {
        attributionWindowPrefix = prefix;
        fieldName = field.substring(prefix.length + 1);
        break;
      }
    }

    // ì‹œê°„ ê¸°ë³¸ ì„¤ì • í”„ë¦¬í”½ìŠ¤ í™•ì¸
    for (const prefix of this.supportedTimePresets) {
      if (fieldName.startsWith(prefix + '_')) {
        timePresetPrefix = prefix;
        fieldName = fieldName.substring(prefix.length + 1);
        break;
      }
    }

    return { attributionWindowPrefix, timePresetPrefix, fieldName };
  }

  parseAggregateField(fieldString: string): AggregateField | null {
    // í˜•ì‹: aggregate({field})
    const aggregateMatch = fieldString.match(/^aggregate\((.+)\)$/);
    if (!aggregateMatch) return null;

    const innerField = aggregateMatch[1];
    const parsedField = this.parsePrefixedField(innerField);

    return {
      function: 'aggregate',
      field: parsedField ? this.reconstructFieldString(parsedField) : innerField,
      aggregationIds: [] // ë³„ë„ë¡œ aggregation_id í•„í„°ì—ì„œ ì„¤ì •
    };
  }

  parseFormulaField(fieldString: string): FormulaField | null {
    // í˜•ì‹: {field_or_constant_1} {+|-|*|/} {field_or_constant_2} ...
    const tokens = fieldString.split(/\s+/);
    if (tokens.length < 3 || tokens.length % 2 === 0) return null;

    const fields: string[] = [];
    const constants: number[] = [];
    const operators: ('+' | '-' | '*' | '/')[] = [];

    for (let i = 0; i < tokens.length; i++) {
      if (i % 2 === 0) {
        // í•„ë“œ ë˜ëŠ” ìƒìˆ˜
        const token = tokens[i];
        const numValue = parseFloat(token);

        if (isNaN(numValue)) {
          fields.push(token);
        } else {
          constants.push(numValue);
        }
      } else {
        // ì—°ì‚°ì
        const operator = tokens[i] as '+' | '-' | '*' | '/';
        if (['+', '-', '*', '/'].includes(operator)) {
          operators.push(operator);
        } else {
          return null; // ì˜ëª»ëœ ì—°ì‚°ì
        }
      }
    }

    // ìƒìˆ˜ê°€ ì•„ë‹Œ í•„ë“œëŠ” ìµœëŒ€ 6ê°œê¹Œì§€
    if (fields.length > 6) return null;

    return {
      expression: fieldString,
      fields,
      constants,
      operators
    };
  }

  private reconstructFieldString(parsed: PrefixedInsightField): string {
    let result = '';

    if (parsed.objectLevelPrefix) {
      result += parsed.objectLevelPrefix + '.';
    }

    if (parsed.attributionWindowPrefix) {
      result += parsed.attributionWindowPrefix + ':';
    }

    if (parsed.timePresetPrefix) {
      result += parsed.timePresetPrefix + '_';
    }

    result += parsed.fieldName;
    return result;
  }

  validateAdvancedFilter(filter: any): { isValid: boolean; type: 'prefixed' | 'aggregate' | 'formula' | 'standard'; error?: string } {
    const field = filter.field;

    // ì§‘ê³„ í•„ë“œ í™•ì¸
    if (field.startsWith('aggregate(')) {
      const aggregateField = this.parseAggregateField(field);
      if (!aggregateField) {
        return { isValid: false, type: 'aggregate', error: 'Invalid aggregate field format' };
      }
      return { isValid: true, type: 'aggregate' };
    }

    // ê³µì‹ í•„ë“œ í™•ì¸ (ê³µë°± í¬í•¨ ì—¬ë¶€ë¡œ íŒë‹¨)
    if (field.includes(' ') && /[+\-*/]/.test(field)) {
      const formulaField = this.parseFormulaField(field);
      if (!formulaField) {
        return { isValid: false, type: 'formula', error: 'Invalid formula field format' };
      }
      return { isValid: true, type: 'formula' };
    }

    // í”„ë¦¬í”½ìŠ¤ í•„ë“œ í™•ì¸
    const prefixedField = this.parsePrefixedField(field);
    if (prefixedField && (prefixedField.objectLevelPrefix || prefixedField.attributionWindowPrefix || prefixedField.timePresetPrefix)) {
      return { isValid: true, type: 'prefixed' };
    }

    // í‘œì¤€ í•„ë“œ
    return { isValid: true, type: 'standard' };
  }

  // ì‹¤ë¬´ ê³ ê¸‰ í•„í„° ì˜ˆì‹œ
  generateAdvancedFilterExamples(): any[] {
    return [
      {
        field: "adset.yesterday_spent",
        operator: "GREATER_THAN",
        value: 1000,
        description: "ì–´ì œ ê´‘ê³  ì„¸íŠ¸ ìˆ˜ì¤€ì—ì„œ ì§€ì¶œí•œ ì´ê¸ˆì•¡"
      },
      {
        field: "campaign.28d_view_1d_click:lifetime_results",
        operator: "GREATER_THAN",
        value: 50,
        description: "ì „ì²´ ê¸°ê°„ì— ê±¸ì³ ê´‘ê³  ìº í˜ì¸ ìˆ˜ì¤€ì˜ ì´ ê²°ê³¼ (ê¸°ì—¬: ì¡°íšŒ 28ì¼, í´ë¦­ 1ì¼)"
      },
      {
        field: "aggregate(reach)",
        operator: "GREATER_THAN",
        value: 10000,
        description: "ì—¬ëŸ¬ ê´‘ê³  ê°ì²´ì˜ ì§‘ê³„ëœ ë„ë‹¬ ë²”ìœ„"
      },
      {
        field: "today_spent / adset.daily_budget",
        operator: "GREATER_THAN",
        value: 0.8,
        description: "ì¼ì¼ ì§€ì¶œ ë¹„ìœ¨ (ê³µì‹ í•„ë“œ)"
      },
      {
        field: "0.8 * cpc + 0.2 * cpm",
        operator: "LESS_THAN",
        value: 5.0,
        description: "ê°€ì¤‘ í‰ê·  ë¹„ìš© ì§€í‘œ (ê³µì‹ í•„ë“œ)"
      }
    ];
  }
}
```

#### ì˜ˆì‚° ì¡°ì • ìë™í™” ì‹œìŠ¤í…œ (Budget Rebalancing System)
```typescript
interface RebalanceSpec {
  type: 'EVEN' | 'PROPORTIONAL' | 'NO_PAUSE_PROPORTIONAL' | 'MATCHED_ONLY_PROPORTIONAL' | 'INVERSE_PROPORTIONAL';
  target_field?: string;
  target_count?: number;
  is_cross_campaign?: boolean;
  is_inverse?: boolean;
}

interface BudgetRebalanceResult {
  donors: RebalanceDonor[];
  recipients: RebalanceRecipient[];
  totalTransferred: number;
  rebalanceType: string;
  executionSummary: string;
}

interface RebalanceDonor {
  objectId: string;
  objectType: 'ADSET' | 'CAMPAIGN';
  currentBudget: number;
  donatedAmount: number;
  wasPaused: boolean;
  performanceScore: number;
}

interface RebalanceRecipient {
  objectId: string;
  objectType: 'ADSET' | 'CAMPAIGN';
  currentBudget: number;
  receivedAmount: number;
  newBudget: number;
  performanceScore: number;
  allocationPercentage: number;
}

class MetaBudgetRebalancer {
  async executeRebalance(rule: MetaAdRuleConfig, rebalanceSpec: RebalanceSpec): Promise<BudgetRebalanceResult> {
    // 1. í‰ê°€ í†µê³¼ ê°ì²´ë“¤ (ê¸°ë¶€ìë“¤) ì‹ë³„
    const donors = await this.identifyDonors(rule);

    // 2. ìˆ˜í˜œìë“¤ ê²°ì • (rebalance_spec.typeì— ë”°ë¼)
    const recipients = await this.identifyRecipients(rule, rebalanceSpec, donors);

    // 3. ì˜ˆì‚° ë¶„ë°° ê³„ì‚°
    const rebalanceCalculation = await this.calculateRebalanceAmounts(
      donors, recipients, rebalanceSpec
    );

    // 4. ì‹¤ì œ ì˜ˆì‚° ì¡°ì • ì‹¤í–‰
    const executionResult = await this.executeRebalanceActions(rebalanceCalculation);

    return executionResult;
  }

  private async identifyDonors(rule: MetaAdRuleConfig): Promise<RebalanceDonor[]> {
    // ê·œì¹™ì˜ evaluation_spec í•„í„°ë¥¼ í†µê³¼í•˜ëŠ” ëª¨ë“  ê°ì²´ë“¤
    const matchingObjects = await this.evaluateRuleFilters(rule.evaluation_spec.filters);

    const donors: RebalanceDonor[] = [];
    for (const obj of matchingObjects) {
      const budget = await this.getCurrentBudget(obj.id, obj.entity_type);
      const performanceScore = await this.calculatePerformanceScore(obj.id, rule);

      donors.push({
        objectId: obj.id,
        objectType: obj.entity_type,
        currentBudget: budget,
        donatedAmount: 0, // ê³„ì‚° í›„ ì„¤ì •
        wasPaused: false,
        performanceScore
      });
    }

    return donors;
  }

  private async identifyRecipients(rule: MetaAdRuleConfig, spec: RebalanceSpec, donors: RebalanceDonor[]): Promise<RebalanceRecipient[]> {
    switch (spec.type) {
      case 'EVEN':
      case 'PROPORTIONAL':
        // í‰ê°€ í†µê³¼í•˜ì§€ ì•Šì€ ê°ì²´ë“¤ì´ ìˆ˜í˜œì
        return this.identifyNonMatchingRecipients(rule, spec);

      case 'NO_PAUSE_PROPORTIONAL':
        // ëª¨ë“  ê°ì²´ë¥¼ í•¨ê»˜ ê²€í† í•˜ì—¬ ì„±ê³¼ ìˆœìœ„ ë§¤ê¹€
        return this.identifyAllObjectsAsRecipients(rule, spec, donors);

      case 'MATCHED_ONLY_PROPORTIONAL':
        // ê¸°ë¶€ìë“¤ ìì‹ ì´ ìˆ˜í˜œìê°€ ë¨ (ì„±ê³¼ ê¸°ë°˜ ì¬ë¶„ë°°)
        return this.convertDonorsToRecipients(donors, spec);

      default:
        throw new Error(`Unsupported rebalance type: ${spec.type}`);
    }
  }

  private async calculateRebalanceAmounts(
    donors: RebalanceDonor[],
    recipients: RebalanceRecipient[],
    spec: RebalanceSpec
  ): Promise<BudgetRebalanceCalculation> {

    // 1. ì¼ì¼ ì˜ˆì‚°ê³¼ ì´ ì˜ˆì‚° ë¶„ë¦¬
    const { dailyBudgetDonors, lifetimeBudgetDonors } = this.separateBudgetTypes(donors);

    // 2. ê° ìœ í˜•ë³„ë¡œ ë¶„ë°° ê³„ì‚°
    const dailyRebalance = await this.calculateTypeSpecificRebalance(
      dailyBudgetDonors, recipients.filter(r => r.objectType === 'ADSET'), spec, 'DAILY'
    );

    const lifetimeRebalance = await this.calculateTypeSpecificRebalance(
      lifetimeBudgetDonors, recipients.filter(r => r.objectType === 'ADSET'), spec, 'LIFETIME'
    );

    return this.combineRebalanceCalculations(dailyRebalance, lifetimeRebalance);
  }

  private async calculateProportionalDistribution(
    totalBudgetPool: number,
    recipients: RebalanceRecipient[],
    spec: RebalanceSpec
  ): Promise<void> {
    if (!spec.target_field) {
      throw new Error('target_field is required for proportional distribution');
    }

    // 1. ê° ìˆ˜í˜œìì˜ target_field ê°’ ì¡°íšŒ
    for (const recipient of recipients) {
      const fieldValue = await this.getFieldValue(recipient.objectId, spec.target_field);
      recipient.performanceScore = spec.is_inverse ? (1 / fieldValue) : fieldValue;
    }

    // 2. target_count ì ìš© (ìƒìœ„ Këª…ë§Œ ì„ íƒ)
    let selectedRecipients = recipients;
    if (spec.target_count && spec.target_count < recipients.length) {
      selectedRecipients = recipients
        .sort((a, b) => b.performanceScore - a.performanceScore)
        .slice(0, spec.target_count);
    }

    // 3. ë¹„ë¡€ì  ë¶„ë°° ê³„ì‚°
    const totalPerformanceScore = selectedRecipients.reduce((sum, r) => sum + r.performanceScore, 0);

    for (const recipient of selectedRecipients) {
      recipient.allocationPercentage = recipient.performanceScore / totalPerformanceScore;
      recipient.receivedAmount = totalBudgetPool * recipient.allocationPercentage;
      recipient.newBudget = recipient.currentBudget + recipient.receivedAmount;
    }
  }

  private async handleCrossCampaignRebalance(spec: RebalanceSpec, donors: RebalanceDonor[], recipients: RebalanceRecipient[]): Promise<void> {
    if (!spec.is_cross_campaign) {
      // ìº í˜ì¸ ë‚´ì—ì„œë§Œ ì˜ˆì‚° ì´ë™
      const campaignGroups = this.groupByCampaign([...donors, ...recipients]);

      for (const [campaignId, objects] of campaignGroups) {
        const campaignDonors = objects.filter(o => donors.includes(o as any)) as RebalanceDonor[];
        const campaignRecipients = objects.filter(o => recipients.includes(o as any)) as RebalanceRecipient[];

        await this.rebalanceWithinCampaign(campaignDonors, campaignRecipients, spec);
      }
    } else {
      // ìº í˜ì¸ ê°„ ì˜ˆì‚° ì´ë™ í—ˆìš©
      await this.rebalanceAcrossCampaigns(donors, recipients, spec);
    }
  }

  // ì‹¤ë¬´ rebalance_spec ì˜ˆì‹œë“¤
  generateRebalanceExamples(): any[] {
    return [
      {
        name: "ê· ë“± ë¶„ë°° (EVEN)",
        description: "ì„±ê³¼ ë‚®ì€ ê´‘ê³  ì„¸íŠ¸ ì¼ì‹œì •ì§€, ë‚˜ë¨¸ì§€ì— ê· ë“± ë¶„ë°°",
        rebalance_spec: {
          type: "EVEN"
        }
      },
      {
        name: "ì„±ê³¼ ë¹„ë¡€ ë¶„ë°° (PROPORTIONAL)",
        description: "CPA ê¸°ì¤€ ìƒìœ„ 10ê°œ ê´‘ê³  ì„¸íŠ¸ì— ë¹„ë¡€ ë¶„ë°°",
        rebalance_spec: {
          type: "PROPORTIONAL",
          target_field: "cost_per_mobile_app_install",
          target_count: 10,
          is_inverse: true
        }
      },
      {
        name: "ì¼ì‹œì •ì§€ ì—†ëŠ” ë¹„ë¡€ ë¶„ë°° (NO_PAUSE_PROPORTIONAL)",
        description: "ì¼ì‹œì •ì§€ ì—†ì´ ì„±ê³¼ ê¸°ë°˜ ì˜ˆì‚° ì¬ë¶„ë°°",
        rebalance_spec: {
          type: "NO_PAUSE_PROPORTIONAL",
          target_field: "video_view"
        }
      },
      {
        name: "ë§¤ì¹­ëœ ê°ì²´ë§Œ ë¶„ë°° (MATCHED_ONLY_PROPORTIONAL)",
        description: "í•„í„° í†µê³¼ ê°ì²´ë“¤ ê°„ì—ë§Œ ì„±ê³¼ ë¹„ë¡€ ì¬ë¶„ë°°",
        rebalance_spec: {
          type: "MATCHED_ONLY_PROPORTIONAL",
          target_field: "video_view"
        }
      },
      {
        name: "ìº í˜ì¸ ê°„ ì˜ˆì‚° ì´ë™",
        description: "ìº í˜ì¸ ê²½ê³„ë¥¼ ë„˜ë‚˜ë“œëŠ” ì˜ˆì‚° ì¬ë¶„ë°°",
        rebalance_spec: {
          type: "PROPORTIONAL",
          target_field: "cost_per_mobile_app_install",
          target_count: 10,
          is_cross_campaign: true,
          is_inverse: true
        }
      }
    ];
  }
}
```

#### ROAS ìµœì í™” ì „ìš© ëª¨ë“ˆ (ROAS Optimization Module)
```typescript
interface ROASRuleConfig {
  ruleId: string;
  targetROAS: number;
  attributionWindow: string;
  timePreset: string;
  minimumMaturityHours: number;
  toleranceRange: [number, number]; // [min, max] í—ˆìš© ë²”ìœ„
  roasType: 'mobile_app_purchase_roas' | 'website_purchase_roas';
}

interface ROASOptimizationResult {
  currentROAS: number;
  targetROAS: number;
  adjustmentNeeded: boolean;
  recommendedBidChange: number;
  recommendedBudgetChange: number;
  maturityStatus: 'mature' | 'immature';
  confidenceLevel: number;
}

class MetaROASOptimizer {
  private supportedROASFields = ['mobile_app_purchase_roas', 'website_purchase_roas'];
  private supportedAttributionWindows = [
    '1D_CLICK', '7D_CLICK', '28D_CLICK',
    '1D_VIEW', '7D_VIEW', '28D_VIEW',
    '1D_VIEW_1D_CLICK', '7D_VIEW_1D_CLICK', '28D_VIEW_1D_CLICK',
    '1D_VIEW_7D_CLICK', '7D_VIEW_7D_CLICK', '28D_VIEW_7D_CLICK',
    '7D_VIEW_28D_CLICK', '28D_VIEW_28D_CLICK'
  ];

  async optimizeROASRule(config: ROASRuleConfig, adsetIds: string[]): Promise<ROASOptimizationResult[]> {
    const results: ROASOptimizationResult[] = [];

    for (const adsetId of adsetIds) {
      // 1. ë°ì´í„° ì„±ìˆ™ë„ í™•ì¸
      const maturityStatus = await this.checkDataMaturity(adsetId, config);

      if (maturityStatus === 'immature') {
        results.push(this.createImmatureResult(adsetId, config));
        continue;
      }

      // 2. í˜„ì¬ ROAS ê³„ì‚°
      const currentROAS = await this.calculateCurrentROAS(adsetId, config);

      // 3. ëª©í‘œ ëŒ€ë¹„ ë¶„ì„
      const optimizationResult = await this.analyzeROASPerformance(
        adsetId, currentROAS, config
      );

      results.push(optimizationResult);
    }

    return results;
  }

  private async checkDataMaturity(adsetId: string, config: ROASRuleConfig): Promise<'mature' | 'immature'> {
    // 1. ìƒì„± í›„ ê²½ê³¼ ì‹œê°„ í™•ì¸
    const adsetInfo = await this.getAdsetCreationInfo(adsetId);
    const hoursSinceCreation = (Date.now() - adsetInfo.created_time.getTime()) / (1000 * 60 * 60);

    if (hoursSinceCreation < config.minimumMaturityHours) {
      return 'immature';
    }

    // 2. ê¸°ì—¬ ê¸°ê°„ì— ë”°ë¥¸ ì¶”ê°€ ì„±ìˆ™ë„ í™•ì¸
    const attributionDays = this.extractAttributionDays(config.attributionWindow);
    const requiredMaturityHours = attributionDays * 24 + 24; // ê¸°ì—¬ ê¸°ê°„ + 1ì¼ ë²„í¼

    return hoursSinceCreation >= requiredMaturityHours ? 'mature' : 'immature';
  }

  private async calculateCurrentROAS(adsetId: string, config: ROASRuleConfig): Promise<number> {
    // ì„±ìˆ™í•œ ë°ì´í„°ë§Œ ì‚¬ìš©í•˜ì—¬ ROAS ê³„ì‚°
    const insights = await this.getAdsetInsights(adsetId, {
      fields: [config.roasType, 'spent'],
      time_preset: config.timePreset,
      attribution_window: config.attributionWindow
    });

    const roasValue = insights[config.roasType];
    return roasValue || 0;
  }

  private async analyzeROASPerformance(
    adsetId: string,
    currentROAS: number,
    config: ROASRuleConfig
  ): Promise<ROASOptimizationResult> {

    const [minTolerance, maxTolerance] = config.toleranceRange;
    const isWithinTolerance = currentROAS >= minTolerance && currentROAS <= maxTolerance;

    let recommendedBidChange = 0;
    let recommendedBudgetChange = 0;

    if (!isWithinTolerance) {
      // target_field ê¸°ë°˜ ë™ì  ì¡°ì • ê³„ì‚°
      const targetROAS = config.targetROAS;
      const roasDifference = targetROAS - currentROAS;
      const adjustmentRatio = roasDifference / currentROAS;

      // ROASê°€ ëª©í‘œë³´ë‹¤ ë‚®ìœ¼ë©´ ì…ì°°ê°€ ìƒí–¥, ë†’ìœ¼ë©´ í•˜í–¥
      recommendedBidChange = this.calculateBidAdjustment(adjustmentRatio);
      recommendedBudgetChange = this.calculateBudgetAdjustment(adjustmentRatio);
    }

    return {
      currentROAS,
      targetROAS: config.targetROAS,
      adjustmentNeeded: !isWithinTolerance,
      recommendedBidChange,
      recommendedBudgetChange,
      maturityStatus: 'mature',
      confidenceLevel: this.calculateConfidenceLevel(currentROAS, config)
    };
  }

  private calculateBidAdjustment(adjustmentRatio: number): number {
    // ROAS ì°¨ì´ì— ë¹„ë¡€í•œ ì…ì°°ê°€ ì¡°ì •
    // ì˜ˆ: ROASê°€ 20% ë¶€ì¡±í•˜ë©´ ì…ì°°ê°€ 15% ì¦ê°€
    const bidAdjustmentFactor = 0.75; // ì¡°ì • ê°•ë„
    return adjustmentRatio * bidAdjustmentFactor;
  }

  private calculateBudgetAdjustment(adjustmentRatio: number): number {
    // ROAS ì°¨ì´ì— ë¹„ë¡€í•œ ì˜ˆì‚° ì¡°ì •
    // ì˜ˆ: ROASê°€ ì¢‹ìœ¼ë©´ ì˜ˆì‚° ì¦ê°€, ë‚˜ì˜ë©´ ì˜ˆì‚° ê°ì†Œ
    const budgetAdjustmentFactor = 0.5; // ì˜ˆì‚° ì¡°ì •ì€ ë” ë³´ìˆ˜ì 
    return -adjustmentRatio * budgetAdjustmentFactor; // ROAS ë†’ìœ¼ë©´ ì˜ˆì‚° ì¦ê°€
  }

  private extractAttributionDays(attributionWindow: string): number {
    // ê¸°ì—¬ ê¸°ê°„ì—ì„œ ìµœëŒ€ ì¼ìˆ˜ ì¶”ì¶œ
    const clickMatch = attributionWindow.match(/(\d+)d_click/i);
    const viewMatch = attributionWindow.match(/(\d+)d_view/i);

    const clickDays = clickMatch ? parseInt(clickMatch[1]) : 0;
    const viewDays = viewMatch ? parseInt(viewMatch[1]) : 0;

    return Math.max(clickDays, viewDays);
  }

  // ì‹¤ë¬´ ROAS ê·œì¹™ ì˜ˆì‹œë“¤
  generateROASRuleExamples(): any[] {
    return [
      {
        name: "7ì¼ í´ë¦­ ì›¹ì‚¬ì´íŠ¸ ROAS ì˜ˆì‚° ì¦ê°€ ê·œì¹™",
        description: "ROAS > 0.50 ì‹œ ì˜ˆì‚° 20% ì¦ê°€",
        rule: {
          schedule_spec: { schedule_type: "DAILY" },
          evaluation_spec: {
            evaluation_type: "SCHEDULE",
            filters: [
              { field: "id", value: [123], operator: "IN" },
              { field: "time_preset", value: "LAST_ND_14_8", operator: "EQUAL" },
              { field: "attribution_window", value: "7D_CLICK", operator: "EQUAL" },
              { field: "hours_since_creation", value: 192, operator: "GREATER_THAN" },
              { field: "website_purchase_roas", value: 0.50, operator: "GREATER_THAN" }
            ]
          },
          execution_spec: {
            execution_type: "CHANGE_BUDGET",
            execution_options: [{
              field: "change_spec",
              value: { amount: 20, unit: "PERCENTAGE" },
              operator: "EQUAL"
            }]
          }
        }
      },
      {
        name: "1ì¼ ì¡°íšŒ 1ì¼ í´ë¦­ ëª¨ë°”ì¼ ì•± ROAS ì…ì°°ê°€ ì¡°ì •",
        description: "ëª©í‘œ ROAS 0.80 ë‹¬ì„±ì„ ìœ„í•œ ë™ì  ì…ì°°ê°€ ì¡°ì •",
        rule: {
          schedule_spec: { schedule_type: "DAILY" },
          evaluation_spec: {
            evaluation_type: "SCHEDULE",
            filters: [
              { field: "id", value: [123], operator: "IN" },
              { field: "time_preset", value: "LAST_7D", operator: "EQUAL" },
              { field: "attribution_window", value: "1D_VIEW_1D_CLICK", operator: "EQUAL" },
              { field: "hours_since_creation", value: 48, operator: "GREATER_THAN" },
              { field: "mobile_app_purchase_roas", value: [0.76, 0.84], operator: "NOT_IN_RANGE" }
            ]
          },
          execution_spec: {
            execution_type: "CHANGE_BID",
            execution_options: [{
              field: "change_spec",
              value: { amount: 0.80, target_field: "mobile_app_purchase_roas" },
              operator: "EQUAL"
            }]
          }
        }
      },
      {
        name: "28ì¼ ê¸°ì—¬ ê¸°ê°„ ROAS ìµœì í™”",
        description: "ì¥ê¸° ê¸°ì—¬ ê¸°ê°„ ê³ ë ¤í•œ ì„±ìˆ™í•œ ë°ì´í„° ê¸°ë°˜ ìµœì í™”",
        config: {
          targetROAS: 1.2,
          attributionWindow: "28D_VIEW_28D_CLICK",
          timePreset: "LAST_ND_60_29", // ìµœê·¼ 60ì¼ ~ 28ì¼ ì „
          minimumMaturityHours: 720, // 30ì¼
          toleranceRange: [1.14, 1.26], // Â±5% í—ˆìš© ë²”ìœ„
          roasType: "website_purchase_roas"
        }
      }
    ];
  }
}
```

#### ì™„ì „í•œ API ë˜í¼ ì‹œìŠ¤í…œ (Complete API Wrapper System)
```typescript
interface MetaRulesAPIResponse<T> {
  data: T;
  success: boolean;
  error?: string;
  executionTime: number;
  rateLimit?: {
    remaining: number;
    resetTime: Date;
  };
}

interface RuleExecutionHistory {
  execution_time: string;
  rule_id: string;
  object_id: string;
  action: string;
  status: 'SUCCESS' | 'FAILED' | 'NO_CHANGE';
  details: any;
  rule_state_at_execution: any;
}

interface RulePreviewResult {
  matching_objects: Array<{
    id: string;
    entity_type: string;
    current_values: Record<string, any>;
    would_execute: boolean;
  }>;
  total_objects_evaluated: number;
  execution_preview: string;
}

class MetaRulesAPIClient {
  private baseUrl: string;
  private accessToken: string;
  private apiVersion: string;
  private rateLimiter: RateLimiter;

  constructor(accessToken: string, apiVersion: string = 'v19.0') {
    this.accessToken = accessToken;
    this.apiVersion = apiVersion;
    this.baseUrl = `https://graph.facebook.com/${apiVersion}`;
    this.rateLimiter = new RateLimiter({ maxRequests: 200, timeWindow: 3600000 });
  }

  // CRUD ì‘ì—…ë“¤
  async createRule(adAccountId: string, ruleConfig: MetaAdRuleConfig): Promise<MetaRulesAPIResponse<{ id: string }>> {
    const startTime = Date.now();

    try {
      await this.rateLimiter.checkLimit();

      const response = await fetch(`${this.baseUrl}/${adAccountId}/adrules_library`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.accessToken}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          name: ruleConfig.name,
          schedule_spec: ruleConfig.schedule_spec,
          evaluation_spec: ruleConfig.evaluation_spec,
          execution_spec: ruleConfig.execution_spec
        })
      });

      const result = await response.json();
      const executionTime = Date.now() - startTime;

      if (result.error) {
        return {
          data: null as any,
          success: false,
          error: result.error.message,
          executionTime
        };
      }

      return {
        data: { id: result.id },
        success: true,
        executionTime,
        rateLimit: this.extractRateLimitInfo(response.headers)
      };
    } catch (error) {
      return {
        data: null as any,
        success: false,
        error: error.message,
        executionTime: Date.now() - startTime
      };
    }
  }

  async getRules(adAccountId: string, fields?: string[]): Promise<MetaRulesAPIResponse<any[]>> {
    const startTime = Date.now();

    try {
      await this.rateLimiter.checkLimit();

      const queryParams = new URLSearchParams({
        access_token: this.accessToken
      });

      if (fields && fields.length > 0) {
        queryParams.append('fields', fields.join(','));
      }

      const response = await fetch(`${this.baseUrl}/${adAccountId}/adrules_library?${queryParams}`);
      const result = await response.json();
      const executionTime = Date.now() - startTime;

      return {
        data: result.data || [],
        success: !result.error,
        error: result.error?.message,
        executionTime,
        rateLimit: this.extractRateLimitInfo(response.headers)
      };
    } catch (error) {
      return {
        data: [],
        success: false,
        error: error.message,
        executionTime: Date.now() - startTime
      };
    }
  }

  async getRule(ruleId: string, fields?: string[]): Promise<MetaRulesAPIResponse<any>> {
    const startTime = Date.now();

    try {
      await this.rateLimiter.checkLimit();

      const queryParams = new URLSearchParams({
        access_token: this.accessToken
      });

      if (fields && fields.length > 0) {
        queryParams.append('fields', fields.join(','));
      }

      const response = await fetch(`${this.baseUrl}/${ruleId}?${queryParams}`);
      const result = await response.json();
      const executionTime = Date.now() - startTime;

      return {
        data: result,
        success: !result.error,
        error: result.error?.message,
        executionTime,
        rateLimit: this.extractRateLimitInfo(response.headers)
      };
    } catch (error) {
      return {
        data: null as any,
        success: false,
        error: error.message,
        executionTime: Date.now() - startTime
      };
    }
  }

  async updateRule(ruleId: string, updateData: Partial<MetaAdRuleConfig>): Promise<MetaRulesAPIResponse<{ success: boolean }>> {
    const startTime = Date.now();

    try {
      await this.rateLimiter.checkLimit();

      const response = await fetch(`${this.baseUrl}/${ruleId}`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.accessToken}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(updateData)
      });

      const result = await response.json();
      const executionTime = Date.now() - startTime;

      return {
        data: { success: result.success || false },
        success: !result.error,
        error: result.error?.message,
        executionTime,
        rateLimit: this.extractRateLimitInfo(response.headers)
      };
    } catch (error) {
      return {
        data: { success: false },
        success: false,
        error: error.message,
        executionTime: Date.now() - startTime
      };
    }
  }

  async deleteRule(ruleId: string): Promise<MetaRulesAPIResponse<{ success: boolean }>> {
    const startTime = Date.now();

    try {
      await this.rateLimiter.checkLimit();

      const response = await fetch(`${this.baseUrl}/${ruleId}`, {
        method: 'DELETE',
        headers: {
          'Authorization': `Bearer ${this.accessToken}`
        }
      });

      const result = await response.json();
      const executionTime = Date.now() - startTime;

      return {
        data: { success: result.success || false },
        success: !result.error,
        error: result.error?.message,
        executionTime,
        rateLimit: this.extractRateLimitInfo(response.headers)
      };
    } catch (error) {
      return {
        data: { success: false },
        success: false,
        error: error.message,
        executionTime: Date.now() - startTime
      };
    }
  }

  // ì‹¤í–‰ ì´ë ¥ ì¡°íšŒ
  async getRuleExecutionHistory(
    ruleId: string,
    filters?: { object_id?: string; action?: string; hide_no_changes?: boolean }
  ): Promise<MetaRulesAPIResponse<RuleExecutionHistory[]>> {
    const startTime = Date.now();

    try {
      await this.rateLimiter.checkLimit();

      const queryParams = new URLSearchParams({
        access_token: this.accessToken
      });

      if (filters) {
        Object.entries(filters).forEach(([key, value]) => {
          if (value !== undefined) {
            queryParams.append(key, value.toString());
          }
        });
      }

      const response = await fetch(`${this.baseUrl}/${ruleId}/history?${queryParams}`);
      const result = await response.json();
      const executionTime = Date.now() - startTime;

      return {
        data: result.data || [],
        success: !result.error,
        error: result.error?.message,
        executionTime,
        rateLimit: this.extractRateLimitInfo(response.headers)
      };
    } catch (error) {
      return {
        data: [],
        success: false,
        error: error.message,
        executionTime: Date.now() - startTime
      };
    }
  }

  // ê³„ì • ì „ì²´ ì‹¤í–‰ ì´ë ¥
  async getAccountExecutionHistory(
    adAccountId: string,
    filters?: { object_id?: string; action?: string; hide_no_changes?: boolean }
  ): Promise<MetaRulesAPIResponse<RuleExecutionHistory[]>> {
    const startTime = Date.now();

    try {
      await this.rateLimiter.checkLimit();

      const queryParams = new URLSearchParams({
        access_token: this.accessToken
      });

      if (filters) {
        Object.entries(filters).forEach(([key, value]) => {
          if (value !== undefined) {
            queryParams.append(key, value.toString());
          }
        });
      }

      const response = await fetch(`${this.baseUrl}/${adAccountId}/adrules_history?${queryParams}`);
      const result = await response.json();
      const executionTime = Date.now() - startTime;

      return {
        data: result.data || [],
        success: !result.error,
        error: result.error?.message,
        executionTime,
        rateLimit: this.extractRateLimitInfo(response.headers)
      };
    } catch (error) {
      return {
        data: [],
        success: false,
        error: error.message,
        executionTime: Date.now() - startTime
      };
    }
  }

  // ê·œì¹™ ë¯¸ë¦¬ë³´ê¸°
  async previewRule(ruleId: string): Promise<MetaRulesAPIResponse<RulePreviewResult>> {
    const startTime = Date.now();

    try {
      await this.rateLimiter.checkLimit();

      const response = await fetch(`${this.baseUrl}/${ruleId}/preview`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.accessToken}`
        }
      });

      const result = await response.json();
      const executionTime = Date.now() - startTime;

      return {
        data: result,
        success: !result.error,
        error: result.error?.message,
        executionTime,
        rateLimit: this.extractRateLimitInfo(response.headers)
      };
    } catch (error) {
      return {
        data: null as any,
        success: false,
        error: error.message,
        executionTime: Date.now() - startTime
      };
    }
  }

  // ìˆ˜ë™ ê·œì¹™ ì‹¤í–‰
  async executeRule(ruleId: string): Promise<MetaRulesAPIResponse<{ execution_id: string }>> {
    const startTime = Date.now();

    try {
      await this.rateLimiter.checkLimit();

      const response = await fetch(`${this.baseUrl}/${ruleId}/execute`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.accessToken}`
        }
      });

      const result = await response.json();
      const executionTime = Date.now() - startTime;

      return {
        data: { execution_id: result.execution_id || 'unknown' },
        success: !result.error,
        error: result.error?.message,
        executionTime,
        rateLimit: this.extractRateLimitInfo(response.headers)
      };
    } catch (error) {
      return {
        data: { execution_id: 'failed' },
        success: false,
        error: error.message,
        executionTime: Date.now() - startTime
      };
    }
  }

  // ê°œì²´ì— ì ìš©ë˜ëŠ” ê·œì¹™ ì¡°íšŒ
  async getObjectRules(
    objectId: string,
    passEvaluation?: boolean | 'previewed'
  ): Promise<MetaRulesAPIResponse<any[]>> {
    const startTime = Date.now();

    try {
      await this.rateLimiter.checkLimit();

      const queryParams = new URLSearchParams({
        access_token: this.accessToken
      });

      if (passEvaluation !== undefined) {
        queryParams.append('pass_evaluation', passEvaluation.toString());
      }

      const response = await fetch(`${this.baseUrl}/${objectId}/adrules_governed?${queryParams}`);
      const result = await response.json();
      const executionTime = Date.now() - startTime;

      return {
        data: result.data || [],
        success: !result.error,
        error: result.error?.message,
        executionTime,
        rateLimit: this.extractRateLimitInfo(response.headers)
      };
    } catch (error) {
      return {
        data: [],
        success: false,
        error: error.message,
        executionTime: Date.now() - startTime
      };
    }
  }

  private extractRateLimitInfo(headers: Headers): { remaining: number; resetTime: Date } | undefined {
    const remaining = headers.get('x-business-use-case-usage');
    const resetTime = headers.get('x-business-use-case-reset-time');

    if (remaining && resetTime) {
      return {
        remaining: parseInt(remaining),
        resetTime: new Date(parseInt(resetTime) * 1000)
      };
    }

    return undefined;
  }
}

// ì†ë„ ì œí•œ ê´€ë¦¬
class RateLimiter {
  private requests: number[] = [];
  private maxRequests: number;
  private timeWindow: number;

  constructor(config: { maxRequests: number; timeWindow: number }) {
    this.maxRequests = config.maxRequests;
    this.timeWindow = config.timeWindow;
  }

  async checkLimit(): Promise<void> {
    const now = Date.now();

    // ì‹œê°„ ìœˆë„ìš° ë°–ì˜ ìš”ì²­ë“¤ ì œê±°
    this.requests = this.requests.filter(time => now - time < this.timeWindow);

    if (this.requests.length >= this.maxRequests) {
      const oldestRequest = Math.min(...this.requests);
      const waitTime = this.timeWindow - (now - oldestRequest);

      if (waitTime > 0) {
        await new Promise(resolve => setTimeout(resolve, waitTime));
      }
    }

    this.requests.push(now);
  }
}
```

### í”ŒëŸ¬ê·¸ì¸ ì•„í‚¤í…ì²˜

#### ëª¨ë“ˆ ì‹œìŠ¤í…œ ì„¤ê³„
```typescript
interface PluginInterface {
  name: string;
  version: string;
  dependencies: string[];

  initialize(): Promise<void>;
  destroy(): Promise<void>;

  // ì´ë²¤íŠ¸ í›…
  onCampaignCreate?(campaign: Campaign): Promise<void>;
  onPerformanceUpdate?(metrics: Metrics): Promise<void>;
}

class PluginManager {
  plugins: Map<string, PluginInterface> = new Map();

  async loadPlugin(plugin: PluginInterface): Promise<void> {
    // ì˜ì¡´ì„± í™•ì¸
    // í”ŒëŸ¬ê·¸ì¸ ë“±ë¡
    // ì´ë²¤íŠ¸ í›… ì—°ê²°
  }
}
```

#### í•µì‹¬ í”ŒëŸ¬ê·¸ì¸ ëª¨ë“ˆ
- **Analytics Plugin**: ê³ ê¸‰ ë°ì´í„° ë¶„ì„ ê¸°ëŠ¥
- **Automation Plugin**: ìë™í™” ë£° ë° ì›Œí¬í”Œë¡œìš°
- **Ad Rules Engine Plugin**: ì¤‘ì•™ ì§‘ì¤‘ì‹ ê´‘ê³  ê·œì¹™ ê´€ë¦¬ ë° ìë™í™” ì‹¤í–‰
- **Reporting Plugin**: ì»¤ìŠ¤í…€ ë¦¬í¬íŠ¸ ìƒì„±
- **Notification Plugin**: ë‹¤ì–‘í•œ ì±„ë„ ì•Œë¦¼ ì—°ë™
- **Integration Plugin**: ì™¸ë¶€ ë„êµ¬ ì—°ë™ (CRM, ì´ë©”ì¼ ë“±)
- **MMM Plugin**: ë§ˆì¼€íŒ… ë¯¹ìŠ¤ ëª¨ë¸ë§ ì „ìš© ë¶„ì„ ë„êµ¬
- **Lift Studies Plugin**: ë¬´ì‘ìœ„ ëŒ€ì¡° ì‹¤í—˜ ê´€ë¦¬ ë° ë¶„ì„
- **Split Test Plugin**: A/B í…ŒìŠ¤íŠ¸ ìë™í™” ë° ìµœì í™” ë„êµ¬
- **Volume Management Plugin**: ê´‘ê³  ë³¼ë¥¨ ëª¨ë‹ˆí„°ë§ ë° ìë™ ìµœì í™” ë„êµ¬

### ì¿¼ë¦¬ ìµœì í™” ì—”ì§„

#### ìµœì í™” ì „ëµ
```typescript
class QueryOptimizer {
  optimizeInsightsQuery(query: InsightsQuery): OptimizedQuery[] {
    // 13ê°œì›” ì œí•œ íšŒí”¼: ì¿¼ë¦¬ ë¶„í• 
    if (this.exceedsTimeLimit(query)) {
      return this.splitByTimeRange(query);
    }

    // ë³µì¡í•œ breakdown ìµœì í™”: ë‹¨ê³„ë³„ ìš”ì²­
    if (this.isComplexBreakdown(query)) {
      return this.optimizeBreakdowns(query);
    }

    // ë°°ì¹˜ ì²˜ë¦¬: ì—¬ëŸ¬ ìš”ì²­ ë¬¶ê¸°
    return this.batchRequests([query]);
  }
}
```

### ë³´ì•ˆ ë° í† í° ê´€ë¦¬

#### í† í° ìˆœí™˜ ì‹œìŠ¤í…œ
```typescript
class TokenManager {
  async refreshAccessToken(): Promise<string> {
    // ë§Œë£Œ ì „ ìë™ ê°±ì‹ 
    // ì•ˆì „í•œ ì €ì¥ì†Œì— ë³´ê´€
    // ë¡œê·¸ ë° ëª¨ë‹ˆí„°ë§
  }

  async validateToken(token: string): Promise<boolean> {
    // í† í° ìœ íš¨ì„± ê²€ì¦
    // ê¶Œí•œ ë²”ìœ„ í™•ì¸
  }
}
```

---

## ğŸ¯ êµ¬í˜„ ìš°ì„ ìˆœìœ„

### Phase 1: ê¸°ë°˜ ì¸í”„ë¼ (4ì£¼) - 2025ë…„ Q4 ì‹œì‘
1. **Meta API í´ë¼ì´ì–¸íŠ¸** - OAuth 2.1 ë° ìµœì‹  ì¸ì¦ í‘œì¤€ ì ìš©
2. **Rate Limiter** - Redis 7.x ê¸°ë°˜ ì ì‘í˜• ìš”ì²­ ì œí•œ ì‹œìŠ¤í…œ
3. **ìºì‹œ ì‹œìŠ¤í…œ** - Redis Stack + PostgreSQL 16 3ë‹¨ê³„ ìºì‹±
4. **ë°ì´í„°ë² ì´ìŠ¤ ì„¤ê³„** - PostgreSQL 16 + TimescaleDB í™•ì¥ (ì‹œê³„ì—´ ë°ì´í„°)

### Phase 2: í•µì‹¬ ê¸°ëŠ¥ (6ì£¼) - 2026ë…„ Q1
1. **Insights API ì—°ë™** - GraphQL + REST API í•˜ì´ë¸Œë¦¬ë“œ ë°ì´í„° ìˆ˜ì§‘
2. **ê¸°ë³¸ ëŒ€ì‹œë³´ë“œ** - Next.js 15 + React 19 ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§
3. **ìº í˜ì¸ ìƒì„±** - AI ì§€ì› ê´‘ê³  ìƒì„± (OpenAI GPT-4o í†µí•©)
4. **ì¶”ì  ì‹œìŠ¤í…œ** - ì„œë²„ì‚¬ì´ë“œ ì¶”ì  + GA4 ì—°ë™
5. **ê´‘ê³  ê·œì¹™ ì—”ì§„ ê¸°ë³¸** - ìŠ¤ì¼€ì¤„ ê¸°ë°˜ ìë™í™” ë° ê¸°ë³¸ ê·œì¹™ ê´€ë¦¬
6. **MMM ê¸°ë³¸ ì—°ë™** - Python 3.12 + Pandas 2.x ë°ì´í„° ì²˜ë¦¬
7. **Lift Studies ê¸°ë³¸ ì—°ë™** - í†µê³„ ë¶„ì„ ì—”ì§„ (SciPy + NumPy)
8. **Split Test ê¸°ë³¸ ì—°ë™** - ë² ì´ì§€ì•ˆ A/B í…ŒìŠ¤íŠ¸ í”„ë ˆì„ì›Œí¬
9. **ê´‘ê³  ë³¼ë¥¨ ëª¨ë‹ˆí„°ë§** - WebSocket ì‹¤ì‹œê°„ ì•Œë¦¼ ì‹œìŠ¤í…œ

### Phase 3: ê³ ê¸‰ ê¸°ëŠ¥ (8ì£¼) - 2026ë…„ Q2
1. **ê´‘ê³  ê·œì¹™ ì—”ì§„ ê³ ê¸‰** - íŠ¸ë¦¬ê±° ê¸°ë°˜ ì‹¤ì‹œê°„ ìë™í™” + ë¨¸ì‹ ëŸ¬ë‹ ìµœì í™”
2. **AI ìë™í™” ì—”ì§„** - LangChain + GPT-4o ë£° ì—”ì§„
3. **ê³ ê¸‰ ë¶„ì„** - Apache Superset + DuckDB ê³ ì„±ëŠ¥ ë¶„ì„
4. **í”ŒëŸ¬ê·¸ì¸ ì‹œìŠ¤í…œ** - ë§ˆì´í¬ë¡œí”„ë¡ íŠ¸ì—”ë“œ + Module Federation
5. **ì „í™˜ í¼ë„ ë¶„ì„** - ì‹¤ì‹œê°„ ì´ë²¤íŠ¸ ìŠ¤íŠ¸ë¦¬ë° (Apache Kafka)
6. **MMM ê³ ê¸‰ ë¶„ì„** - MLflow + PyTorch ë¨¸ì‹ ëŸ¬ë‹ íŒŒì´í”„ë¼ì¸
7. **Lift Studies ê³ ê¸‰ ê¸°ëŠ¥** - ë² ì´ì§€ì•ˆ í†µê³„ + ì¸ê³¼ì¶”ë¡  (DoWhy)
8. **Split Test ê³ ê¸‰ ê¸°ëŠ¥** - ë©€í‹° armed bandit + ë² ì´ì§€ì•ˆ ìµœì í™”
9. **ë³¼ë¥¨ ê´€ë¦¬ ìë™í™”** - ì˜ˆì¸¡ ëª¨ë¸ë§ + ìë™ ìŠ¤ì¼€ì¼ë§

### Phase 4: ìµœì í™” ë° í™•ì¥ (4ì£¼) - 2026ë…„ Q3
1. **ì„±ëŠ¥ ìµœì í™”** - Rust ê¸°ë°˜ í•«íŒ¨ìŠ¤ ìµœì í™” + Edge Computing (Cloudflare Workers)
2. **ë©€í‹°ëª¨ë‹¬ AI ì˜ˆì¸¡** - GPT-4o Vision + Claude 3.5 Sonnet ê´‘ê³  í¬ë¦¬ì—ì´í‹°ë¸Œ ìƒì„±
3. **ì™¸ë¶€ ì—°ë™** - Zapier/Make.com API + 2000+ ì„œë¹„ìŠ¤ í†µí•©
4. **ëª¨ë°”ì¼ ì•±** - React Native 0.75 + Expo Router v4
5. **MMM ì˜ˆì‚° ìµœì í™” AI** - ê°•í™”í•™ìŠµ (Ray RLlib) ê¸°ë°˜ ë™ì  ë°°ë¶„
6. **í†µí•© ë¶„ì„ ëŒ€ì‹œë³´ë“œ** - ì‹¤ì‹œê°„ ì¸ì‚¬ì´íŠ¸ + AI ì¶”ì²œ ì‹œìŠ¤í…œ
7. **ì—”í„°í”„ë¼ì´ì¦ˆ ê¸°ëŠ¥** - SSO, RBAC, ê°ì‚¬ ë¡œê·¸, ê·œì • ì¤€ìˆ˜
8. **AI ì—ì´ì „íŠ¸ ì‹œìŠ¤í…œ** - ììœ¨ ê´‘ê³  ê´€ë¦¬ + ë‹¤ì¤‘ ì—ì´ì „íŠ¸ í˜‘ì—…

---

## ğŸš€ í™•ì¥ ê³„íš

### ë‹¨ê¸° í™•ì¥ (6ê°œì›”) - 2026ë…„ Q4
- **ë‹¤ì¤‘ ê³„ì • ê´€ë¦¬**: í†µí•© ëŒ€ì‹œë³´ë“œ + ì¡°ì§ ê³„ì¸µ ê´€ë¦¬
- **íŒ€ í˜‘ì—… ê¸°ëŠ¥**: ì‹¤ì‹œê°„ í˜‘ì—… (WebRTC) + ì—­í•  ê¸°ë°˜ ì ‘ê·¼ ì œì–´
- **AI ë¦¬í¬íŒ…**: GPT-4o ê¸°ë°˜ ìë™ ì¸ì‚¬ì´íŠ¸ ìƒì„± + ì˜ˆì¸¡ ë¶„ì„
- **GraphQL API ì œê³µ**: ê°œë°œì ì¹œí™”ì  API + OpenAPI 3.1 ë¬¸ì„œí™”

### ì¤‘ê¸° í™•ì¥ (1ë…„)
- **ìƒì„±í˜• AI í†µí•©**: GPT-4o, Claude 3.5 ê¸°ë°˜ ê´‘ê³  ì¹´í”¼ ìë™ ìƒì„± ë° ìµœì í™”
- **í¬ë¡œìŠ¤ í”Œë«í¼**: Google Ads, ë„¤ì´ë²„, TikTok Ads ë“± ì—°ë™
- **í™”ì´íŠ¸ë¼ë²¨**: B2B SaaS í”Œë«í¼ìœ¼ë¡œ í™•ì¥
- **ëª¨ë°”ì¼ ë„¤ì´í‹°ë¸Œ**: iOS/Android ì•± ê°œë°œ (React Native ë˜ëŠ” Flutter)

### ì¥ê¸° ë¹„ì „ (2-3ë…„)
- **ê¸€ë¡œë²Œ í™•ì¥**: ë‹¤êµ­ê°€/ë‹¤ì–¸ì–´ ì§€ì› (AI ë²ˆì—­ í†µí•©)
- **ì—”í„°í”„ë¼ì´ì¦ˆ**: ëŒ€ê¸°ì—… ë§ì¶¤ ì†”ë£¨ì…˜
- **AI ìƒíƒœê³„**: ì„œë“œíŒŒí‹° AI ëª¨ë¸ í”ŒëŸ¬ê·¸ì¸ ë§ˆì¼“í”Œë ˆì´ìŠ¤
- **ì°¨ì„¸ëŒ€ AI ì–´ì‹œìŠ¤í„´íŠ¸**: ë©€í‹°ëª¨ë‹¬ AI ê¸°ë°˜ ê´‘ê³  ê´€ë¦¬ (í…ìŠ¤íŠ¸, ì´ë¯¸ì§€, ì˜ìƒ í†µí•©)

---

## ğŸ“Š ì„±ê³µ ì§€í‘œ (KPI)

### ê¸°ìˆ ì  ì§€í‘œ
- **ê°€ìš©ì„±**: 99.9% ì—…íƒ€ì„
- **ì‘ë‹µì‹œê°„**: API ì‘ë‹µ í‰ê·  200ms ì´í•˜
- **ì²˜ë¦¬ëŸ‰**: ì´ˆë‹¹ 1000+ API í˜¸ì¶œ ì²˜ë¦¬
- **ì •í™•ì„±**: ë°ì´í„° ì •í™•ë„ 99.95% ì´ìƒ

### ë¹„ì¦ˆë‹ˆìŠ¤ ì§€í‘œ
- **ì‚¬ìš©ì ì¦ê°€**: ì›”ê°„ í™œì„± ì‚¬ìš©ì 20% ì„±ì¥
- **ê¸°ëŠ¥ í™œìš©**: ìë™í™” ê¸°ëŠ¥ ì‚¬ìš©ë¥  60% ì´ìƒ
- **ê³ ê° ë§Œì¡±**: NPS ìŠ¤ì½”ì–´ 70+ ë‹¬ì„±
- **ìˆ˜ìµì„±**: ì—°ê°„ ë°˜ë³µ ìˆ˜ìµ(ARR) ëª©í‘œ ë‹¬ì„±

### íš¨ìœ¨ì„± ì§€í‘œ
- **ê´‘ê³  ì„±ê³¼ ê°œì„ **: ROAS í‰ê·  20% í–¥ìƒ
- **ì‹œê°„ ì ˆì•½**: ê´‘ê³  ê´€ë¦¬ ì‹œê°„ 50% ë‹¨ì¶•
- **ì—ëŸ¬ ê°ì†Œ**: ìˆ˜ë™ ì‹¤ìˆ˜ë¡œ ì¸í•œ ì˜¤ë¥˜ 80% ê°ì†Œ
- **ì¸ì‚¬ì´íŠ¸ í™œìš©**: ë°ì´í„° ê¸°ë°˜ ì˜ì‚¬ê²°ì • ì¦ê°€

---

## ğŸ›¡ï¸ ë¦¬ìŠ¤í¬ ê´€ë¦¬

### ê¸°ìˆ ì  ë¦¬ìŠ¤í¬
- **API ë³€ê²½**: Meta API ì •ì±… ë³€ê²½ ëŒ€ì‘ ê³„íš
- **Rate Limiting**: ì‚¬ìš©ëŸ‰ ê¸‰ì¦ ì‹œ ëŒ€ì‘ ì „ëµ
- **ë°ì´í„° ì •í™•ì„±**: ì‹¤ì‹œê°„ ê²€ì¦ ë° ëª¨ë‹ˆí„°ë§
- **ë³´ì•ˆ**: í† í° ê´€ë¦¬ ë° ë°ì´í„° ë³´í˜¸

### ë¹„ì¦ˆë‹ˆìŠ¤ ë¦¬ìŠ¤í¬
- **ê²½ìŸ**: ì°¨ë³„í™”ëœ ê¸°ëŠ¥ ë° UX ì œê³µ
- **ê·œì œ**: ê°œì¸ì •ë³´ë³´í˜¸ ë° ê´‘ê³  ì •ì±… ì¤€ìˆ˜
- **í™•ì¥ì„±**: ì‚¬ìš©ì ì¦ê°€ì— ë”°ë¥¸ ì¸í”„ë¼ í™•ì¥
- **ìˆ˜ìµì„±**: ì§€ì† ê°€ëŠ¥í•œ ë¹„ì¦ˆë‹ˆìŠ¤ ëª¨ë¸

---

---

## ğŸ“ˆ MMM ë°ì´í„° ì»¬ëŸ¼ ë§¤í•‘

### ê¸°ë³¸ ë°ì´í„° êµ¬ì¡°
MMM APIì—ì„œ ë°˜í™˜ë˜ëŠ” ê¸°ë³¸ ì»¬ëŸ¼ êµ¬ì¡°:

| ì¸ë±ìŠ¤ | ì»¬ëŸ¼ëª… | ì„¤ëª… |
|--------|--------|------|
| 0 | account_id | ê´‘ê³  ê³„ì • ID |
| 1 | campaign_id | ìº í˜ì¸ ID |
| 2 | adset_id | ê´‘ê³  ì„¸íŠ¸ ID |
| 3 | date_start | ì‹œì‘ ë‚ ì§œ |
| 4 | date_stop | ì¢…ë£Œ ë‚ ì§œ |
| 5 | impressions | ë…¸ì¶œ ìˆ˜ |
| 6 | spend | ì§€ì¶œ ê¸ˆì•¡ (ì¶”ì‚°ì¹˜) |
| 7 | country | êµ­ê°€ |
| 8 | region | ì§€ì—­ |
| 9 | dma | DMA (ì§€ì • ì‹œì¥ ì§€ì—­) |
| 10 | device_platform | ë””ë°”ì´ìŠ¤ í”Œë«í¼ |
| 11 | platform_position | í”Œë«í¼ ìœ„ì¹˜ |
| 12 | publisher_platform | í¼ë¸”ë¦¬ì…” í”Œë«í¼ |
| 13 | creative_media_type | í¬ë¦¬ì—ì´í‹°ë¸Œ ë¯¸ë””ì–´ íƒ€ì… |

### ë°ì´í„° í™œìš© ê³„íš
- **ì§€ì—­ë³„ ë¶„ì„**: country, region, dmaë¥¼ í™œìš©í•œ ì§€ì—­ë³„ ì„±ê³¼ ë¶„ì„
- **ë””ë°”ì´ìŠ¤ ë¶„ì„**: device_platform ê¸°ë°˜ ë””ë°”ì´ìŠ¤ë³„ ìµœì í™”
- **í”Œë«í¼ ë¶„ì„**: publisher_platform, platform_position ê¸°ë°˜ ë…¸ì¶œ ìœ„ì¹˜ ìµœì í™”
- **í¬ë¦¬ì—ì´í‹°ë¸Œ ë¶„ì„**: creative_media_type ê¸°ë°˜ í¬ë¦¬ì—ì´í‹°ë¸Œ ì„±ê³¼ ë¶„ì„

---

## ğŸ§ª ë¶„í•  í…ŒìŠ¤íŠ¸ ì„¤ê³„ ê°€ì´ë“œ

### í…ŒìŠ¤íŠ¸ ë³€ìˆ˜ë³„ ì„¤ê³„ ì˜ˆì‹œ

**íƒ€ê²ŸíŒ… ì „ëµ í…ŒìŠ¤íŠ¸**
```json
{
  "name": "Audience Targeting Split Test",
  "type": "SPLIT_TEST",
  "cells": [
    {
      "name": "Lookalike Audience",
      "treatment_percentage": 50,
      "adsets": ["ADSET_ID_1"]
    },
    {
      "name": "Interest Targeting",
      "treatment_percentage": 50,
      "adsets": ["ADSET_ID_2"]
    }
  ]
}
```

**í¬ë¦¬ì—ì´í‹°ë¸Œ íš¨ê³¼ í…ŒìŠ¤íŠ¸**
```json
{
  "name": "Creative Format Split Test",
  "type": "SPLIT_TEST",
  "cells": [
    {
      "name": "Video Creative",
      "treatment_percentage": 33,
      "adsets": ["ADSET_ID_1"]
    },
    {
      "name": "Carousel Creative",
      "treatment_percentage": 33,
      "adsets": ["ADSET_ID_2"]
    },
    {
      "name": "Single Image Creative",
      "treatment_percentage": 34,
      "adsets": ["ADSET_ID_3"]
    }
  ]
}
```

**ì˜ˆì‚° ì „ëµ í…ŒìŠ¤íŠ¸**
```json
{
  "name": "Budget Strategy Split Test",
  "type": "SPLIT_TEST",
  "cells": [
    {
      "name": "High Budget Campaign",
      "treatment_percentage": 50,
      "campaigns": ["CAMPAIGN_ID_1"]
    },
    {
      "name": "Low Budget Campaign",
      "treatment_percentage": 50,
      "campaigns": ["CAMPAIGN_ID_2"]
    }
  ]
}
```

### ë¶„ì„ ê²°ê³¼ í•´ì„ ê°€ì´ë“œ

**í†µê³„ì  ìœ ì˜ì„± ê¸°ì¤€**
- **p-value < 0.05**: í†µê³„ì ìœ¼ë¡œ ìœ ì˜í•œ ì°¨ì´ ì¡´ì¬
- **ì‹ ë¢°êµ¬ê°„**: 95% ì‹ ë¢°êµ¬ê°„ì´ 0ì„ í¬í•¨í•˜ì§€ ì•Šìœ¼ë©´ ìœ ì˜í•œ íš¨ê³¼
- **íš¨ê³¼ í¬ê¸°**: ì‹¤ì§ˆì ìœ¼ë¡œ ì˜ë¯¸ ìˆëŠ” ì°¨ì´ì¸ì§€ í‰ê°€ (ì˜ˆ: CPA 10% ì´ìƒ ê°œì„ )

**ì˜ì‚¬ê²°ì • ë§¤íŠ¸ë¦­ìŠ¤**

| í†µê³„ì  ìœ ì˜ì„± | íš¨ê³¼ í¬ê¸° | ê¶Œì¥ ì•¡ì…˜ |
|-------------|---------|----------|
| ìœ ì˜í•¨ (p<0.05) | í¼ (>20% ê°œì„ ) | ìŠ¹ì ì…€ë¡œ ì¦‰ì‹œ í™•ì¥ |
| ìœ ì˜í•¨ (p<0.05) | ì¤‘ê°„ (10-20% ê°œì„ ) | ì¶”ê°€ í…ŒìŠ¤íŠ¸ í›„ í™•ì¥ |
| ìœ ì˜í•¨ (p<0.05) | ì‘ìŒ (<10% ê°œì„ ) | ë¹„ìš© ëŒ€ë¹„ íš¨ê³¼ ê²€í†  |
| ìœ ì˜í•˜ì§€ ì•ŠìŒ (pâ‰¥0.05) | - | ì¶”ê°€ ë°ì´í„° ìˆ˜ì§‘ ë˜ëŠ” ìƒˆë¡œìš´ í…ŒìŠ¤íŠ¸ |

## ğŸ§ª Lift Studies ì‹¤í—˜ ì„¤ê³„ ê°€ì´ë“œ

### ëª©í‘œë³„ ì‹¤í—˜ ì„¤ê³„ ì˜ˆì‹œ

**ì „í™˜ ìµœì í™” ì‹¤í—˜**
```json
{
  "name": "Conversion Optimization Study",
  "type": "LIFT",
  "cells": [
    {
      "name": "High Budget Test",
      "treatmentPercentage": 40,
      "controlPercentage": 20
    },
    {
      "name": "Low Budget Test",
      "treatmentPercentage": 30,
      "controlPercentage": 10
    }
  ],
  "objectives": [
    {
      "name": "Purchase Conversions",
      "type": "CONVERSIONS",
      "is_primary": true,
      "adspixels": [
        {
          "id": "PIXEL_ID",
          "event_names": ["fb_pixel_purchase"]
        }
      ]
    }
  ]
}
```

### ë¶„ì„ ë°ì´í„° í™œìš©

**ì§€ì›ë˜ëŠ” ë¶„ì„ ì°¨ì›** (2021ë…„ 7ì›” 13ì¼ ì´í›„ ì œí•œ)
- **cell_id**: ì‹¤í—˜êµ°ë³„ ê²°ê³¼ ë¶„ì„ (í•„ìˆ˜)
- **age**: ì—°ë ¹ëŒ€ë³„ ë¶„ì„ (ì œí•œì )
- **gender**: ì„±ë³„ ë¶„ì„ (ì œí•œì )
- **country**: êµ­ê°€ë³„ ë¶„ì„ (ì œí•œì )

### í•µì‹¬ ì„±ê³¼ ì§€í‘œ

**ì£¼ìš” ì¸¡ì • ì§€í‘œ**
- `conversions_incremental`: ìˆœìˆ˜ ì¦ë¶„ ì „í™˜ìˆ˜
- `conversions_confidence`: í†µê³„ì  ì‹ ë¢°ë„ (0-1)
- `conversions_CPiC`: ì¦ë¶„ ì „í™˜ë‹¹ ë¹„ìš©
- `conversions_incremental_share`: ì¦ë¶„ íš¨ê³¼ ë¹„ìœ¨

**í†µê³„ì  ê²€ì¦**
- p-value < 0.05: í†µê³„ì  ìœ ì˜ì„± í™•ë³´
- ì‹ ë¢°êµ¬ê°„: 95% ì‹ ë¢°êµ¬ê°„ ë‚´ íš¨ê³¼ í¬ê¸°
- ê²€ì •ë ¥ ë¶„ì„: íš¨ê³¼ íƒì§€ ëŠ¥ë ¥ í‰ê°€

---

---

## ğŸ”— í†µí•© í™œìš© ì‹œë‚˜ë¦¬ì˜¤

### Volume Management + Split Test + MMM + Lift Studies ì—°ê³„ ì „ëµ

#### 0ë‹¨ê³„: Volume Managementë¡œ ìµœì  í™˜ê²½ êµ¬ì¶•
- ê´‘ê³  ë³¼ë¥¨ í˜„í™© ë¶„ì„ ë° ì œí•œ ì„ê³„ê°’ í™•ì¸
- ë¹„íš¨ìœ¨ì  ê´‘ê³  ì •ë¦¬ë¥¼ í†µí•œ í…ŒìŠ¤íŠ¸ í™˜ê²½ ìµœì í™”
- ë³¼ë¥¨ ì—¬ìœ  í™•ë³´ë¡œ í…ŒìŠ¤íŠ¸ í™•ì¥ì„± ë³´ì¥

#### 1ë‹¨ê³„: Split Testë¡œ í›„ë³´ ì „ëµ ì‹ë³„
- ë³¼ë¥¨ ì œì•½ ë‚´ì—ì„œ ë‹¤ì–‘í•œ ê´‘ê³  ì „ëµ ë¶„í•  í…ŒìŠ¤íŠ¸
- í†µê³„ì  ìœ ì˜ì„± ê¸°ë°˜ ìµœì  ì „ëµ ì„ ë³„
- ìŠ¹ì ì…€ì˜ ì„±ê³¼ ì§€í‘œ ë° íŒ¨í„´ ë¶„ì„

#### 2ë‹¨ê³„: MMMìœ¼ë¡œ ì „ì²´ì  íš¨ê³¼ ì¸¡ì •
- Split Test ìŠ¹ì ì „ëµì„ MMM ë°ì´í„°ì— ë°˜ì˜
- ë‹¤ë¥¸ ë§ˆì¼€íŒ… ì±„ë„ê³¼ì˜ ì‹œë„ˆì§€ íš¨ê³¼ ë¶„ì„
- ì¥ê¸°ì  ê¸°ì—¬ë„ ë° í¬í™”ë„ ê³¡ì„  ëª¨ë¸ë§

#### 3ë‹¨ê³„: Lift Studiesë¡œ ì¸ê³¼ê´€ê³„ ê²€ì¦
- MMMì—ì„œ ì‹ë³„ëœ íš¨ê³¼ë¥¼ ë¬´ì‘ìœ„ ëŒ€ì¡° ì‹¤í—˜ìœ¼ë¡œ ê²€ì¦
- ì¦ë¶„ íš¨ê³¼(Incremental Effect) ì •í™•í•œ ì¸¡ì •
- ì‹¤ì œ ë¹„ì¦ˆë‹ˆìŠ¤ ì„íŒ©íŠ¸ì˜ ê³¼í•™ì  ì…ì¦

#### 4ë‹¨ê³„: Volume Optimizationìœ¼ë¡œ í™•ì¥ ì‹¤í–‰
- ê²€ì¦ëœ ì „ëµì˜ ëŒ€ê·œëª¨ í™•ì¥ ì‹œ ë³¼ë¥¨ ì˜í–¥ ì˜ˆì¸¡
- ìë™ ë³¼ë¥¨ ê´€ë¦¬ë¥¼ í†µí•œ ì•ˆì „í•œ í™•ì¥ ì‹¤í–‰
- ì„±ê³¼ ìœ ì§€í•˜ë©´ì„œ ìµœëŒ€ ë³¼ë¥¨ íš¨ìœ¨ì„± ë‹¬ì„±

#### í†µí•© ë¶„ì„ ì›Œí¬í”Œë¡œìš°
```typescript
interface IntegratedAnalysisWorkflow {
  volumeStatus: VolumeStatus;
  splitTestResults: SplitTestResults[];
  mmmAnalysis: MMMInsights;
  liftStudyResults: LiftInsights;

  integratedRecommendations: {
    volumeOptimization: VolumeOptimization;
    budgetOptimization: BudgetAllocation;
    strategyRefinement: StrategyUpdate;
    scalingPlan: ScalingStrategy;
    riskAssessment: RiskAnalysis;
  };
}

class IntegratedAnalysisEngine {
  async performComprehensiveAnalysis(
    volumeData: VolumeStatus,
    splitTests: SplitTestResults[],
    mmmData: MMMData[],
    liftStudies: LiftStudyResults[]
  ): Promise<IntegratedInsights> {
    // 0. ë³¼ë¥¨ ìµœì í™” ê¸°ë°˜ í™˜ê²½ ë¶„ì„
    const volumeOptimization = this.analyzeVolumeOptimization(volumeData);

    // 1. ê° ë°©ë²•ë¡ ì˜ ê²°ê³¼ ì •ê·œí™”
    const normalizedResults = this.normalizeResults(splitTests, mmmData, liftStudies, volumeData);

    // 2. êµì°¨ ê²€ì¦ ë° ì¼ê´€ì„± í™•ì¸
    const consistencyCheck = this.validateConsistency(normalizedResults);

    // 3. í†µí•© ì¸ì‚¬ì´íŠ¸ ìƒì„± (ë³¼ë¥¨ ì œì•½ ê³ ë ¤)
    const insights = this.generateIntegratedInsights(normalizedResults, volumeOptimization);

    // 4. ë³¼ë¥¨ íš¨ìœ¨ì„±ì„ ê³ ë ¤í•œ ì•¡ì…˜ í”Œëœ ìˆ˜ë¦½
    const actionPlan = this.createVolumeAwareActionPlan(insights, consistencyCheck, volumeOptimization);

    return { insights, actionPlan, consistencyCheck, volumeOptimization };
  }
}
```

### ì‹¤ë¬´ ì ìš© ì˜ˆì‹œ

**ì‹œë‚˜ë¦¬ì˜¤: ì „ììƒê±°ë˜ ê´‘ê³  ìµœì í™” (ë³¼ë¥¨ ì œì•½ í¬í•¨)**

0. **Volume Analysis**: ê´‘ê³  ë³¼ë¥¨ í˜„í™© ë¶„ì„
   - í˜„ì¬ ë³¼ë¥¨: í˜ì´ì§€ ì œí•œì˜ 85% ì‚¬ìš© ì¤‘ (ìœ„í—˜ ìˆ˜ì¤€)
   - ë¹„íš¨ìœ¨ ê´‘ê³ : 30ê°œ zero_impression ê´‘ê³  ì‹ë³„
   - ìµœì í™” ì ì¬ë ¥: ë³¼ë¥¨ 20% ì ˆì•½ ê°€ëŠ¥

1. **Split Test**: ì œí’ˆ ì¹´íƒˆë¡œê·¸ vs ë‹¨ì¼ ì œí’ˆ ê´‘ê³  ë¹„êµ (ë³¼ë¥¨ ì œì•½ ê³ ë ¤)
   - ê²°ê³¼: ì¹´íƒˆë¡œê·¸ ê´‘ê³ ê°€ CPA 15% ë‚®ìŒ (p<0.01)
   - ë³¼ë¥¨ íš¨ìœ¨ì„±: ì¹´íƒˆë¡œê·¸ ê´‘ê³ ê°€ 50% ì ì€ ê´‘ê³  ìˆ˜ë¡œ ë™ì¼ ì„±ê³¼

2. **MMM ë¶„ì„**: ì¹´íƒˆë¡œê·¸ ê´‘ê³ ì˜ ì±„ë„ë³„ ê¸°ì—¬ë„ ë¶„ì„
   - ê²°ê³¼: Instagramì—ì„œ 30% ë” ë†’ì€ ê¸°ì—¬ë„, Facebookì—ì„œëŠ” ë™ë“±
   - ë³¼ë¥¨ ì˜í–¥: ì±„ë„ë³„ ê´‘ê³  ìˆ˜ ìµœì í™” í•„ìš”

3. **Lift Study**: ì¹´íƒˆë¡œê·¸ ê´‘ê³ ì˜ ì‹¤ì œ ì¦ë¶„ íš¨ê³¼ ê²€ì¦
   - ê²°ê³¼: ì‹¤ì œ ì¦ë¶„ ì „í™˜ 12%, CPiC $25 (ê¸°ì¡´ CPA $30 ëŒ€ë¹„ ê°œì„ )
   - ë³¼ë¥¨ ê²€ì¦: ëŒ€ê·œëª¨ í™•ì¥ ì‹œì—ë„ íš¨ê³¼ ìœ ì§€ í™•ì¸

4. **Volume Optimization**: í™•ì¥ ì „ ë³¼ë¥¨ ìµœì í™”
   - ë¹„íš¨ìœ¨ ê´‘ê³  30ê°œ ì •ë¦¬ë¡œ 20% ë³¼ë¥¨ í™•ë³´
   - ì¹´íƒˆë¡œê·¸ ê´‘ê³  í™•ì¥ì„ ìœ„í•œ ì—¬ìœ  ê³µê°„ í™•ë³´

5. **í†µí•© ê¶Œì¥ì‚¬í•­**:
   - ë¹„íš¨ìœ¨ ê´‘ê³  ì •ë¦¬ í›„ Instagram ì˜ˆì‚° 30% ì¦ê°€
   - Facebook ë³¼ë¥¨ì€ íš¨ìœ¨ì  ê´‘ê³ ë¡œ ì¬êµ¬ì„±
   - ì¹´íƒˆë¡œê·¸ ê´‘ê³ ë¥¼ ë‹¨ê³„ì ìœ¼ë¡œ ëª¨ë“  ì œí’ˆêµ° í™•ì¥
   - ë³¼ë¥¨ ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œìœ¼ë¡œ ì§€ì†ì  ìµœì í™”
   - 3ê°œì›” í›„ ì¶”ê°€ Lift Studyë¡œ ì¥ê¸° íš¨ê³¼ ë° ë³¼ë¥¨ íš¨ìœ¨ì„± ê²€ì¦

---

---

## ğŸ“‹ ê´‘ê³  ë³¼ë¥¨ ê´€ë¦¬ ì‹¤ë¬´ ê°€ì´ë“œ

### ë³¼ë¥¨ ìƒíƒœ ëª¨ë‹ˆí„°ë§ ì²´í¬ë¦¬ìŠ¤íŠ¸

**ì¼ì¼ ì²´í¬ í•­ëª©**
- [ ] í˜„ì¬ ë³¼ë¥¨ ì‚¬ìš©ë¥  í™•ì¸ (80% ë¯¸ë§Œ ìœ ì§€ ê¶Œì¥)
- [ ] í˜ì´ì§€ë³„ ë³¼ë¥¨ ë¶„í¬ ë¶„ì„
- [ ] ë¯¸ë˜ ì œí•œ ì¼ì • í™•ì¸
- [ ] ë¹„íš¨ìœ¨ ê´‘ê³ (zero_impression, learning_limited) ì‹ë³„

**ì£¼ê°„ ì²´í¬ í•­ëª©**
- [ ] ë³¼ë¥¨ íŠ¸ë Œë“œ ë¶„ì„ ë° ì˜ˆì¸¡
- [ ] ì„±ê³¼ ê¸°ë°˜ ê´‘ê³  ìš°ì„ ìˆœìœ„ ì¬ì¡°ì •
- [ ] ìº í˜ì¸ë³„ ë³¼ë¥¨ íš¨ìœ¨ì„± í‰ê°€
- [ ] ê¶Œì¥ì‚¬í•­ ì‹œìŠ¤í…œ ê²°ê³¼ ê²€í†  ë° ì ìš©

**ì›”ê°„ ì²´í¬ í•­ëª©**
- [ ] ì „ì²´ ë³¼ë¥¨ ì „ëµ ë¦¬ë·°
- [ ] í˜ì´ì§€ ê°„ ë³¼ë¥¨ ë°¸ëŸ°ì‹± ìµœì í™”
- [ ] ë³¼ë¥¨ ê´€ë¦¬ ìë™í™” ê·œì¹™ ì—…ë°ì´íŠ¸
- [ ] ë¯¸ë˜ ì œí•œ ëŒ€ë¹„ ì¥ê¸° ê³„íš ìˆ˜ë¦½

### ë³¼ë¥¨ ìµœì í™” ê¶Œì¥ì‚¬í•­ í™œìš©

**Zero Impression ê´‘ê³  ì²˜ë¦¬**
1. 7ì¼ ì´ìƒ ë…¸ì¶œ ì—†ëŠ” ê´‘ê³  ì‹ë³„
2. ê³¼ê±° ì„±ê³¼ ë°ì´í„° ë¶„ì„
3. ë¹„ì¦ˆë‹ˆìŠ¤ ì¤‘ìš”ë„ í‰ê°€
4. ì•ˆì „í•œ ê´‘ê³ ë¶€í„° ë‹¨ê³„ì  ì •ë¦¬

**Learning Limited ê´‘ê³  í•´ê²°**
1. í•™ìŠµ ë‹¨ê³„ì— ë¨¸ë¬¼ëŸ¬ ìˆëŠ” ê´‘ê³  ì‹ë³„
2. íƒ€ê²ŸíŒ… ë²”ìœ„ í™•ëŒ€ ë˜ëŠ” ì˜ˆì‚° ì¦ê°€ ê²€í† 
3. ìœ ì‚¬í•œ ê´‘ê³  í†µí•©ìœ¼ë¡œ í•™ìŠµ ë°ì´í„° ì§‘ì¤‘
4. ì„±ê³¼ ê¸°ì¤€ ë¯¸ë‹¬ ì‹œ ì¼ì‹œì •ì§€ ê³ ë ¤

**ìº í˜ì¸/ê´‘ê³  ì„¸íŠ¸ í†µí•© ì „ëµ**
1. ìœ ì‚¬í•œ íƒ€ê²ŸíŒ…ê³¼ ëª©í‘œë¥¼ ê°€ì§„ ê´‘ê³  ê·¸ë£¹í™”
2. ì„±ê³¼ ë°ì´í„° ê¸°ë°˜ í†µí•© ìš°ì„ ìˆœìœ„ ê²°ì •
3. ì ì§„ì  í†µí•©ìœ¼ë¡œ ì„±ê³¼ ì˜í–¥ ìµœì†Œí™”
4. í†µí•© í›„ ì„±ê³¼ ëª¨ë‹ˆí„°ë§ ê°•í™”

---

*ë¬¸ì„œ ì‘ì„±ì¼: 2025ë…„ 10ì›” 28ì¼*
*ë²„ì „: v1.6 - ê´‘ê³  ê·œì¹™ ì—”ì§„ ê³ ê¸‰ ê¸°ëŠ¥ ì™„ì „ í†µí•©*
*ìµœì¢… ì—…ë°ì´íŠ¸: 2025ë…„ 10ì›” 29ì¼*
*ì‘ì„±ì: AI Assistant*